<!DOCTYPE html>

<html>
<head>
  <title>Dialogue.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="../../docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>Dialogue.coffee</h1>
        

        
      </div>

      
        
        <p>credit to lmarkus/hubot-conversation for the original concept
TODO: queue consquetive receive calls to process messages synchronously
TODO: save transcript to brain (here or in scene)</p>

        
          <div class='highlight'><pre>
_ = <span class="hljs-built_in">require</span> <span class="hljs-string">'underscore'</span>
{inspect} = <span class="hljs-built_in">require</span> <span class="hljs-string">'util'</span>
{EventEmitter} = <span class="hljs-built_in">require</span> <span class="hljs-string">'events'</span>

Helpers = <span class="hljs-built_in">require</span> <span class="hljs-string">'./Helpers'</span></pre></div>
        
      
        
        <p>multiple-choice dialogue interactions
the timeout will trigger a timeout message if nothing matches in time
@param res, incoming message initiating dialogue
@param opts, key/vals for config, e.g overide timeout default</p>

        
          <div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dialogue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span></span>
  constructor: <span class="hljs-function"><span class="hljs-params">(@res, opts={})</span> -&gt;</span>
    @log = @res.robot.logger
    @paths = {} <span class="hljs-comment"># builds as dialogue progresses</span>
    @pathId = <span class="hljs-literal">null</span> <span class="hljs-comment"># pointer for current path</span>
    @branches = [] <span class="hljs-comment"># branch options within current path</span>
    @ended = <span class="hljs-literal">false</span> <span class="hljs-comment"># state of dialogue completion</span>

    @config = _.defaults opts, <span class="hljs-comment"># use defaults for any missing options</span>
      reply: <span class="hljs-literal">false</span> <span class="hljs-comment"># will send without addressing reply to sender</span>
      timeout: parseInt process.env.DIALOGUE_TIMEOUT <span class="hljs-keyword">or</span> <span class="hljs-number">30000</span>
      timeoutLine: process.env.DIALOGUE_TIMEOUT_LINE <span class="hljs-keyword">or</span>
        <span class="hljs-string">'Timed out! Please start again.'</span>
    <span class="hljs-keyword">return</span> @

  startTimeout: <span class="hljs-function">-&gt;</span>
    @countdown = setTimeout () =&gt;
      @emit <span class="hljs-string">'timeout'</span>
      <span class="hljs-keyword">try</span> @onTimeout() <span class="hljs-keyword">catch</span> e <span class="hljs-keyword">then</span> @log.error <span class="hljs-string">"onTimeout: <span class="hljs-subst">#{ inspect e }</span>"</span>
      <span class="hljs-keyword">delete</span> @countdown
      @end()
    , @config.timeout
    <span class="hljs-keyword">return</span> @countdown

  clearTimeout: <span class="hljs-function">-&gt;</span>
    clearTimeout @countdown
    <span class="hljs-keyword">delete</span> @countdown
    <span class="hljs-keyword">return</span></pre></div>
        
      
        
        <p>default timeout method sends line unless null or method overriden
can override by passing in a function, or reassigning the property</p>

        
          <div class='highlight'><pre>  onTimeout: <span class="hljs-function"><span class="hljs-params">(override)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> override?
      @onTimeout = override
    <span class="hljs-keyword">else</span>
      @send @config.timeoutLine <span class="hljs-keyword">if</span> @config.timeoutLine?
    <span class="hljs-keyword">return</span></pre></div>
        
      
        
        <p>add a dialogue path - a prompt with one or more branches to follow
@param opts.prompt, (optional) string to send presenting the branches
@param opts.branches, 2D array of arguments to create branches
@param opts.key, (optional) string reference for querying results of path
returns key (either the one given or computed) for future reference
Can be called with just the branches array, not required as object param</p>

        
          <div class='highlight'><pre>  path: <span class="hljs-function"><span class="hljs-params">(opts)</span> -&gt;</span>
    opts = branches: opts <span class="hljs-keyword">if</span> _.isArray opts <span class="hljs-comment"># move branches array into property</span></pre></div>
        
      
        
        <p>generate unique id (using source string if key or prompt given)</p>

        
          <div class='highlight'><pre>    @pathId = Helpers.keygen <span class="hljs-string">'path'</span>, opts.key <span class="hljs-keyword">or</span> opts.prompt</pre></div>
        
      
        
        <p>setup new path object and dialogue state</p>

        
          <div class='highlight'><pre>    @clearBranches()
    @paths[@pathId] =
      prompt: opts.prompt
      status: _.map opts.branches, <span class="hljs-function"><span class="hljs-params">(args)</span> =&gt;</span> @branch args...
      transcript: []</pre></div>
        
      
        
        <p>kick-off dialogue exchange</p>

        
          <div class='highlight'><pre>    @send opts.prompt <span class="hljs-keyword">if</span> opts.prompt?
    <span class="hljs-keyword">return</span> @pathId <span class="hljs-comment"># allow path to be queried by key</span></pre></div>
        
      
        
        <p>add a dialogue branch (usually through path) with response and/or callback
1: .branch( regex, response ) reply with response on regex match
2: .branch( regex, callback ) trigger callback on regex match
3: .branch( regex, response, callback ) reply and do callback
@param regex, expression to match
@param {string} response message text (optional)
@param {function} handler function when matched (optional)</p>

        
          <div class='highlight'><pre>  branch: <span class="hljs-function"><span class="hljs-params">(regex, args...)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> @ended
      @log.error <span class="hljs-string">'attempted to add branch after dialogue completed'</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></pre></div>
        
      
        
        <p>validate arguments</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> _.isRegExp regex
      @log.error <span class="hljs-string">'invalid regex given for branch'</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></pre></div>
        
      
        
        <p>take first arg as response (if string), use remaining as callback if given</p>

        
          <div class='highlight'><pre>    response = args.shift() <span class="hljs-keyword">if</span> _.isString args[<span class="hljs-number">0</span>]
    callback = args[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> _.isFunction args[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (response? <span class="hljs-keyword">or</span> callback?)
      @log.error <span class="hljs-string">"Wrong args given for branch with regex <span class="hljs-subst">#{ inspect regex }</span>"</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></pre></div>
        
      
        
        <p>call callback after sending response (if specified) or just call callback</p>

        
          <div class='highlight'><pre>    <span class="hljs-keyword">if</span> response?
<span class="hljs-function">      <span class="hljs-title">handler</span> = <span class="hljs-params">(res)</span> =&gt;</span>
        @send response
        callback res <span class="hljs-keyword">if</span> callback?
    <span class="hljs-keyword">else</span>
      handler = callback</pre></div>
        
      
        
        <p>new branch restarts the countdown</p>

        
          <div class='highlight'><pre>    @clearTimeout() <span class="hljs-keyword">if</span> @countdown?
    @startTimeout()
    @branches.push
      regex: regex,
      handler: handler
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># for .path to record success</span>

  clearBranches: <span class="hljs-function">-&gt;</span>
    @branches = []
    <span class="hljs-keyword">return</span></pre></div>
        
      
        
        <p>accept an incoming message, match against the registered branches
if matched, deliver response, restart timeout and end dialogue
@param res, the message object to match against</p>

        
          <div class='highlight'><pre>  receive: <span class="hljs-function"><span class="hljs-params">(res)</span> -&gt;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">if</span> @ended <span class="hljs-comment"># dialogue is over, don't process</span>

    line = res.message.text
    @log.debug <span class="hljs-string">"Dialogue received <span class="hljs-subst">#{ line }</span>"</span>
    match = <span class="hljs-literal">false</span></pre></div>
        
      
        
        <p>stop at the first match in the order in which they were added</p>

        
          <div class='highlight'><pre>    @branches.some (branch) =&gt;
      <span class="hljs-keyword">if</span> match = line.match branch.regex</pre></div>
        
      
        
        <p>match found, clear this step</p>

        
          <div class='highlight'><pre>        @record <span class="hljs-string">'match'</span>, res.message.user, line, match, branch.regex
        @clearBranches()
        @clearTimeout()
        res.match = match <span class="hljs-comment"># override the original match from hubot listener</span>
        branch.handler res <span class="hljs-comment"># may add additional branches / restarting timeout</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># don't process further matches</span></pre></div>
        
      
        
        <p>record and report if nothing matched</p>

        
          <div class='highlight'><pre>    @record <span class="hljs-string">'mismatch'</span>, res.message.user, line <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> match
    @end() <span class="hljs-keyword">if</span> @branches.length <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> <span class="hljs-comment"># end if nothing left to do</span>
    <span class="hljs-keyword">return</span></pre></div>
        
      
        
        <p>Send response using original response object
Address the participants appropriately (i.e. @user reply or send to channel)</p>

        
          <div class='highlight'><pre>  send: <span class="hljs-function"><span class="hljs-params">(line)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> @config.sendReplies <span class="hljs-keyword">then</span> @res.reply line <span class="hljs-keyword">else</span> @res.send line
    @record <span class="hljs-string">'send'</span>, <span class="hljs-string">'bot'</span>, line
    <span class="hljs-keyword">return</span></pre></div>
        
      
        
        <p>record and report sends, matches or mismatches
adds interactions to transcript if currently executing a named path</p>

        
          <div class='highlight'><pre>  record: <span class="hljs-function"><span class="hljs-params">(type, user, content, match, regex)</span> -&gt;</span>
    @paths[@pathId].transcript.push [ type, user, content ] <span class="hljs-keyword">if</span> @pathId?
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> type
      <span class="hljs-keyword">when</span> <span class="hljs-string">'match'</span>
        @log.debug <span class="hljs-string">"Received \"<span class="hljs-subst">#{ content }</span>\" matched <span class="hljs-subst">#{ inspect regex }</span>"</span>
        @emit <span class="hljs-string">'match'</span>, user, content, match, regex
      <span class="hljs-keyword">when</span> <span class="hljs-string">'mismatch'</span>
        @log.debug <span class="hljs-string">"Received \"<span class="hljs-subst">#{ content }</span>\" matched nothing"</span>
        @emit <span class="hljs-string">'mismatch'</span>, user, content
      <span class="hljs-keyword">when</span> <span class="hljs-string">'send'</span>
        @log.debug <span class="hljs-string">"Sent \"<span class="hljs-subst">#{ content }</span>\""</span></pre></div>
        
      
        
        <p>shut it down - emit status for scene to disengage participants</p>

        
          <div class='highlight'><pre>  end: <span class="hljs-function">-&gt;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-keyword">if</span> @ended
    complete = @branches.length <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>
    @log.debug <span class="hljs-string">"Dialog ended <span class="hljs-subst">#{ <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> complete <span class="hljs-keyword">then</span> <span class="hljs-string">'in'</span> }</span>complete"</span>
    @clearTimeout() <span class="hljs-keyword">if</span> @countdown?
    @emit <span class="hljs-string">'end'</span>, complete
    @ended = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span> @ended

<span class="hljs-built_in">module</span>.exports = Dialogue</pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
