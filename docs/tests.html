<html>
<head>
    <title>Mocha</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
    @charset "utf-8";

body {
  margin:0;
}

#mocha {
  font: 20px/1.5 "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: 60px 50px;
}

#mocha ul,
#mocha li {
  margin: 0;
  padding: 0;
}

#mocha ul {
  list-style: none;
}

#mocha h1,
#mocha h2 {
  margin: 0;
}

#mocha h1 {
  margin-top: 15px;
  font-size: 1em;
  font-weight: 200;
}

#mocha h1 a {
  text-decoration: none;
  color: inherit;
}

#mocha h1 a:hover {
  text-decoration: underline;
}

#mocha .suite .suite h1 {
  margin-top: 0;
  font-size: .8em;
}

#mocha .hidden {
  display: none;
}

#mocha h2 {
  font-size: 12px;
  font-weight: normal;
  cursor: pointer;
}

#mocha .suite {
  margin-left: 15px;
}

#mocha .test {
  margin-left: 15px;
  overflow: hidden;
}

#mocha .test.pending:hover h2::after {
  content: '(pending)';
  font-family: arial, sans-serif;
}

#mocha .test.pass.medium .duration {
  background: #c09853;
}

#mocha .test.pass.slow .duration {
  background: #b94a48;
}

#mocha .test.pass::before {
  content: '✓';
  font-size: 12px;
  display: block;
  float: left;
  margin-right: 5px;
  color: #00d6b2;
}

#mocha .test.pass .duration {
  font-size: 9px;
  margin-left: 5px;
  padding: 2px 5px;
  color: #fff;
  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  -ms-border-radius: 5px;
  -o-border-radius: 5px;
  border-radius: 5px;
}

#mocha .test.pass.fast .duration {
  display: none;
}

#mocha .test.pending {
  color: #0b97c4;
}

#mocha .test.pending::before {
  content: '◦';
  color: #0b97c4;
}

#mocha .test.fail {
  color: #c00;
}

#mocha .test.fail pre {
  color: black;
}

#mocha .test.fail::before {
  content: '✖';
  font-size: 12px;
  display: block;
  float: left;
  margin-right: 5px;
  color: #c00;
}

#mocha .test pre.error {
  color: #c00;
  max-height: 300px;
  overflow: auto;
}

#mocha .test .html-error {
  overflow: auto;
  color: black;
  line-height: 1.5;
  display: block;
  float: left;
  clear: left;
  font: 12px/1.5 monaco, monospace;
  margin: 5px;
  padding: 15px;
  border: 1px solid #eee;
  max-width: 85%; /*(1)*/
  max-width: -webkit-calc(100% - 42px);
  max-width: -moz-calc(100% - 42px);
  max-width: calc(100% - 42px); /*(2)*/
  max-height: 300px;
  word-wrap: break-word;
  border-bottom-color: #ddd;
  -webkit-box-shadow: 0 1px 3px #eee;
  -moz-box-shadow: 0 1px 3px #eee;
  box-shadow: 0 1px 3px #eee;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}

#mocha .test .html-error pre.error {
  border: none;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-box-shadow: 0;
  -moz-box-shadow: 0;
  box-shadow: 0;
  padding: 0;
  margin: 0;
  margin-top: 18px;
  max-height: none;
}

/**
 * (1): approximate for browsers not supporting calc
 * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)
 *      ^^ seriously
 */
#mocha .test pre {
  display: block;
  float: left;
  clear: left;
  font: 12px/1.5 monaco, monospace;
  margin: 5px;
  padding: 15px;
  border: 1px solid #eee;
  max-width: 85%; /*(1)*/
  max-width: -webkit-calc(100% - 42px);
  max-width: -moz-calc(100% - 42px);
  max-width: calc(100% - 42px); /*(2)*/
  word-wrap: break-word;
  border-bottom-color: #ddd;
  -webkit-box-shadow: 0 1px 3px #eee;
  -moz-box-shadow: 0 1px 3px #eee;
  box-shadow: 0 1px 3px #eee;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}

#mocha .test h2 {
  position: relative;
}

#mocha .test a.replay {
  position: absolute;
  top: 3px;
  right: 0;
  text-decoration: none;
  vertical-align: middle;
  display: block;
  width: 15px;
  height: 15px;
  line-height: 15px;
  text-align: center;
  background: #eee;
  font-size: 15px;
  -webkit-border-radius: 15px;
  -moz-border-radius: 15px;
  border-radius: 15px;
  -webkit-transition:opacity 200ms;
  -moz-transition:opacity 200ms;
  -o-transition:opacity 200ms;
  transition: opacity 200ms;
  opacity: 0.3;
  color: #888;
}

#mocha .test:hover a.replay {
  opacity: 1;
}

#mocha-report.pass .test.fail {
  display: none;
}

#mocha-report.fail .test.pass {
  display: none;
}

#mocha-report.pending .test.pass,
#mocha-report.pending .test.fail {
  display: none;
}
#mocha-report.pending .test.pass.pending {
  display: block;
}

#mocha-error {
  color: #c00;
  font-size: 1.5em;
  font-weight: 100;
  letter-spacing: 1px;
}

#mocha-stats {
  position: fixed;
  top: 15px;
  right: 10px;
  font-size: 12px;
  margin: 0;
  color: #888;
  z-index: 1;
}

#mocha-stats .progress {
  float: right;
  padding-top: 0;

  /**
   * Set safe initial values, so mochas .progress does not inherit these
   * properties from Bootstrap .progress (which causes .progress height to
   * equal line height set in Bootstrap).
   */
  height: auto;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  background-color: initial;
}

#mocha-stats em {
  color: black;
}

#mocha-stats a {
  text-decoration: none;
  color: inherit;
}

#mocha-stats a:hover {
  border-bottom: 1px solid #eee;
}

#mocha-stats li {
  display: inline-block;
  margin: 0 5px;
  list-style: none;
  padding-top: 11px;
}

#mocha-stats canvas {
  width: 40px;
  height: 40px;
}

#mocha code .comment { color: #ddd; }
#mocha code .init { color: #2f6fad; }
#mocha code .string { color: #5890ad; }
#mocha code .keyword { color: #8a6343; }
#mocha code .number { color: #2f6fad; }

@media screen and (max-device-width: 480px) {
  #mocha {
    margin: 60px 0px;
  }

  #mocha #stats {
    position: absolute;
  }
}

    #mocha .test.pass pre {
        display: none;
    }
    #mocha .test:hover h2:after {
        color: #888888;
        content: "(view source)";
        font-family: arial;
        font-size: 12px;
        position: relative;
        right: -10px;
        top: 0;
    }
    </style>
</head>

<body>
    <div id="mocha">
        <ul id="stats">
            <li class="passes">passes: <em>341</em></li>
            <li class="failures">failures: <em>0</em></li>
            <li class="duration">duration: <em>6.3s</em></li>
        </ul>
        <ul id="report"><li class="suite"><h1>Diagnostics</h1><ul><li class="suite"><h1>script sets up a &quot;respond&quot; and a &quot;hear&quot; listener</h1><ul><li class="test pass fast"><h2>robot.respond called once to set up listener<span class="duration">1ms</span></h2><pre><code>return pretend.robot.respond.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>registers a respond listener with RegExp and function<span class="duration">1ms</span></h2><pre><code>return pretend.robot.respond.getCall(0).should.have.calledWithMatch(sinon.match.regexp, sinon.match.func);</code></pre></li><li class="test pass fast"><h2>robot.hear called twice (by respond then directly)<span class="duration">0ms</span></h2><pre><code>return pretend.robot.hear.should.have.calledTwice;</code></pre></li><li class="test pass fast"><h2>registers a hear listener with RegExp and callback (no options)<span class="duration">0ms</span></h2><pre><code>return pretend.robot.hear.getCall(1).should.have.calledWithMatch(sinon.match.regexp, sinon.match.func);</code></pre></li><li class="test pass fast"><h2>robbot has two listeners<span class="duration">0ms</span></h2><pre><code>return pretend.robot.listeners.length.should.equal(2);</code></pre></li></ul></li><li class="suite"><h1>bot responds to a matching message</h1><ul><li class="test pass fast"><h2>bot creates response<span class="duration">0ms</span></h2><pre><code>return pretend.responses.listen.length.should.equal(1);</code></pre></li><li class="test pass fast"><h2>bot calls listener callback with response<span class="duration">1ms</span></h2><pre><code>return this.cb.should.have.calledWithMatch(sinon.match(matchRes));</code></pre></li></ul></li><li class="suite"><h1>bot hears a matching message</h1><ul><li class="test pass fast"><h2>bot creates response<span class="duration">0ms</span></h2><pre><code>return pretend.responses.listen.length.should.equal(1);</code></pre></li><li class="test pass fast"><h2>bot calls listener callback with response<span class="duration">1ms</span></h2><pre><code>return this.cb.should.have.calledWithMatch(sinon.match(matchRes));</code></pre></li></ul></li><li class="suite"><h1>bot responds to its alias</h1><ul><li class="test pass fast"><h2>calls callback with response<span class="duration">24ms</span></h2><pre><code>return co(function*() {
  var cb;
  pretend.start({
    alias: 'buddy'
  });
  cb = sinon.spy(pretend.robot.listeners[0], 'callback');
  yield pretend.user('jimbo').send('buddy which version');
  return cb.should.have.calledWithMatch(sinon.match(matchRes));
});</code></pre></li></ul></li><li class="suite"><h1>user asks for version number</h1><ul><li class="test pass fast"><h2>replies to tester with a version number<span class="duration">6ms</span></h2><pre><code>return co(function*() {
  yield pretend.user('jimbo').send('hubot which version are you on?');
  return pretend.messages[1][1].should.match(/jimbo .*\d+.\d+.\d+/);
});</code></pre></li></ul></li><li class="suite"><h1>user asks different ways if Hubot is listening</h1><ul><li class="test pass fast"><h2>replies to each confirming Hubot listening<span class="duration">9ms</span></h2><pre><code>return co(function*() {
  yield pretend.user('jimbo').send('Are any Hubots listening?');
  yield pretend.user('jimbo').send('Is there a bot listening?');
  return pretend.messages[1].should.eql(pretend.messages[3]);
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>Base</h1><ul><li class="suite"><h1>.constructor</h1><ul><li class="suite"><h1>with name, robot and options and key</h1><ul><li class="test pass fast"><h2>stores the robot<span class="duration">0ms</span></h2><pre><code>return this.base.robot.should.eql(pretend.robot);</code></pre></li><li class="test pass fast"><h2>calls configure with options<span class="duration">0ms</span></h2><pre><code>return this.base.configure.should.have.calledWith({
  test: 'testing'
});</code></pre></li><li class="test pass fast"><h2>sets key attribute<span class="duration">0ms</span></h2><pre><code>return this.base.key.should.equal('basey-mcbase');</code></pre></li></ul></li><li class="suite"><h1>without robot</h1><ul><li class="test pass fast"><h2>runs error handler<span class="duration">1ms</span></h2><pre><code>return Base.prototype.error.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>without name</h1><ul><li class="test pass fast"><h2>runs error handler<span class="duration">0ms</span></h2><pre><code>return Base.prototype.error.should.have.calledOnce;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.log</h1><ul><li class="test pass fast"><h2>writes log on the given level<span class="duration">1ms</span></h2><pre><code>var base;
base = new Base('test', pretend.robot);
base.id = 'test111';
base.log.debug('This is some debug');
base.log.info('This is info');
base.log.warning('This is a warning');
base.log.error('This is an error');
return pretend.logs.slice(-4).should.eql([['debug', 'This is some debug (id: test111)'], ['info', 'This is info (id: test111)'], ['warning', 'This is a warning (id: test111)'], ['error', 'This is an error (id: test111)']]);</code></pre></li><li class="test pass fast"><h2>appends the key if instance has one<span class="duration">0ms</span></h2><pre><code>var base;
base = new Base('test', pretend.robot, 'super-test');
base.id = 'test111';
base.log.debug('This is some debug');
return pretend.logs.slice(-1).should.eql([['debug', 'This is some debug (id: test111, key: super-test)']]);</code></pre></li></ul></li><li class="suite"><h1>.error</h1><ul><li class="suite"><h1>with an error</h1><ul><li class="test pass fast"><h2>logs an error<span class="duration">0ms</span></h2><pre><code>return this.errLog[0].should.equal('error');</code></pre></li><li class="test pass fast"><h2>emits the error through robot<span class="duration">0ms</span></h2><pre><code>return pretend.robot.emit.should.have.calledWith('error', this.err);</code></pre></li><li class="test pass fast"><h2>threw error<span class="duration">0ms</span></h2><pre><code>return this.base.error.should[&quot;throw&quot;];</code></pre></li></ul></li><li class="suite"><h1>with error context string</h1><ul><li class="test pass fast"><h2>logs an error with the module instance ID and context string<span class="duration">0ms</span></h2><pre><code>return this.errLog[1].should.match(new RegExp(this.base.id + &quot;.*something broke&quot;));</code></pre></li><li class="test pass fast"><h2>emits an error through robot<span class="duration">0ms</span></h2><pre><code>return pretend.robot.emit.should.have.calledWith('error');</code></pre></li><li class="test pass fast"><h2>threw error<span class="duration">0ms</span></h2><pre><code>return this.base.error.should[&quot;throw&quot;];</code></pre></li></ul></li><li class="suite"><h1>using inherited method for error</h1><ul><li class="test pass fast"><h2>calls inherited method<span class="duration">0ms</span></h2><pre><code>return Base.prototype.error.should.have.calledWith('Throw me an error');</code></pre></li><li class="test pass fast"><h2>threw<span class="duration">0ms</span></h2><pre><code>return this.module.error.should[&quot;throw&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.configure</h1><ul><li class="test pass fast"><h2>saves new options<span class="duration">0ms</span></h2><pre><code>var base;
base = new Base('module', pretend.robot);
base.configure({
  foo: true
});
return base.config.foo.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>overrides existing config<span class="duration">0ms</span></h2><pre><code>var base;
base = new Base('module', pretend.robot, {
  setting: true
});
base.configure({
  setting: false
});
return base.config.setting.should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>throws when not given options<span class="duration">0ms</span></h2><pre><code>var base;
base = new Base('module', pretend.robot);
try {
  base.configure('not an object');
} catch (error) {}
return base.configure.should[&quot;throw&quot;];</code></pre></li></ul></li><li class="suite"><h1>.defaults</h1><ul><li class="test pass fast"><h2>sets config if not set<span class="duration">1ms</span></h2><pre><code>this.base = new Base('module', pretend.robot);
this.base.defaults({
  setting: true
});
return this.base.config.should.eql({
  setting: true
});</code></pre></li><li class="test pass fast"><h2>does not change config if already set<span class="duration">0ms</span></h2><pre><code>this.base = new Base('module', pretend.robot, {
  setting: true
});
this.base.defaults({
  setting: false
});
return this.base.config.should.eql({
  setting: true
});</code></pre></li></ul></li><li class="suite"><h1>.emit</h1><ul><li class="test pass fast"><h2>emits event via the robot with instance as first arg<span class="duration">0ms</span></h2><pre><code>this.base = new Base('module', pretend.robot);
this.eventSpy = sinon.spy();
pretend.robot.on('mockEvent', this.eventSpy);
this.base.emit('mockEvent', {
  foo: 'bar'
});
return this.eventSpy.should.have.calledWith(this.base, {
  foo: 'bar'
});</code></pre></li></ul></li><li class="suite"><h1>.on</h1><ul><li class="test pass fast"><h2>relays events from robot to instance<span class="duration">1ms</span></h2><pre><code>this.base = new Base('module', pretend.robot);
this.mockEvent = sinon.spy();
this.base.on('mockEvent', this.mockEvent);
pretend.robot.emit('mockEvent', this.base, {
  foo: 'bar'
});
return this.mockEvent.should.have.calledWith({
  foo: 'bar'
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>Path</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>with branches</h1><ul><li class="test pass fast"><h2>calls .addBranch<span class="duration">2ms</span></h2><pre><code>var path;
sinon.spy(Path.prototype, 'addBranch');
path = new Path(pretend.robot, [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']]);
path.addBranch.args.should.eql([[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']]);
return Path.prototype.addBranch.restore();</code></pre></li><li class="test pass fast"><h2>is not closed<span class="duration">0ms</span></h2><pre><code>var path;
path = new Path(pretend.robot, [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']]);
return path.closed.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>with a single branch</h1><ul><li class="test pass fast"><h2>calls .addBranch<span class="duration">0ms</span></h2><pre><code>var path;
sinon.spy(Path.prototype, 'addBranch');
path = new Path(pretend.robot, [/ok/, 'OK, ok!']);
path.addBranch.args.should.eql([[/ok/, 'OK, ok!']]);
return Path.prototype.addBranch.restore();</code></pre></li><li class="test pass fast"><h2>is not closed<span class="duration">1ms</span></h2><pre><code>var path;
path = new Path(pretend.robot, [/ok/, 'OK, ok!']);
return path.closed.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>with undefined branches and options</h1><ul><li class="test pass fast"><h2>does not call .addBranch<span class="duration">1ms</span></h2><pre><code>var path;
sinon.spy(Path.prototype, 'addBranch');
path = new Path(pretend.robot);
return Path.prototype.addBranch.restore();</code></pre></li><li class="test pass fast"><h2>stays closed<span class="duration">1ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
return path.closed.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>with bad arguments for branch</h1><ul><li class="test pass fast"><h2>throws<span class="duration">1ms</span></h2><pre><code>try {
  this.path = new Path(pretend.robot, 'breakme.jpg');
} catch (error) {}
return Path.constructor.should[&quot;throw&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.addBranch</h1><ul><li class="test pass fast"><h2>creates branch object<span class="duration">0ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
path.addBranch(/.*/, 'foo', function() {});
return path.branches[0].should.be.an('object');</code></pre></li><li class="test pass fast"><h2>branch has valid regex<span class="duration">0ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
path.addBranch(/.*/, 'foo', function() {});
return path.branches[0].regex.should.be[&quot;instanceof&quot;](RegExp);</code></pre></li><li class="test pass fast"><h2>accepts a string that can be cast as RegExp<span class="duration">1ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
path.addBranch('/.*/ig', 'foo', function() {});
return path.branches[0].regex.should.be[&quot;instanceof&quot;](RegExp);</code></pre></li><li class="test pass fast"><h2>calls getHandler with strings and callback<span class="duration">2ms</span></h2><pre><code>var callback, path;
path = new Path(pretend.robot);
callback = function() {};
sinon.stub(path, 'getHandler');
path.addBranch(/.*/, 'foo', callback);
return path.getHandler.should.have.calledWithExactly('foo', callback);</code></pre></li><li class="test pass fast"><h2>calls getHandler with just stirngs<span class="duration">1ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
sinon.stub(path, 'getHandler');
path.addBranch(/.*/, ['foo', 'bar']);
return path.getHandler.should.have.calledWithExactly(['foo', 'bar'], void 0);</code></pre></li><li class="test pass fast"><h2>calls getHandler with just callback<span class="duration">0ms</span></h2><pre><code>var callback, path;
path = new Path(pretend.robot);
callback = function() {};
sinon.stub(path, 'getHandler');
path.addBranch(/.*/, callback);
return path.getHandler.should.have.calledWithExactly(void 0, callback);</code></pre></li><li class="test pass fast"><h2>branch stores handler<span class="duration">1ms</span></h2><pre><code>var lasthandler, path;
path = new Path(pretend.robot);
sinon.spy(path, 'getHandler');
path.addBranch(/.*/, 'foo', function() {});
lasthandler = path.getHandler.returnValues[0];
return path.branches[0].handler.should.eql(lasthandler);</code></pre></li><li class="test pass fast"><h2>opens path<span class="duration">0ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
path.addBranch(/.*/, 'foo', function() {});
return path.closed.should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>throws with invalid regex<span class="duration">3ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
try {
  path.addBranch('derp');
} catch (error) {}
return path.addBranch.should[&quot;throw&quot;];</code></pre></li><li class="test pass fast"><h2>throws with insufficient args<span class="duration">1ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
try {
  path.addBranch(/.*/);
} catch (error) {}
return path.addBranch.should[&quot;throw&quot;];</code></pre></li><li class="test pass fast"><h2>throws with invalid message<span class="duration">0ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
try {
  path.addBranch(/.*/, function() {});
} catch (error) {}
return path.addBranch.should[&quot;throw&quot;];</code></pre></li><li class="test pass fast"><h2>throws with invalid callback<span class="duration">0ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
try {
  path.addBranch(/.*/, 'foo', 'bar');
} catch (error) {}
return path.addBranch.should[&quot;throw&quot;];</code></pre></li></ul></li><li class="suite"><h1>.getHandler</h1><ul><li class="test pass fast"><h2>returns a function<span class="duration">0ms</span></h2><pre><code>var callback, handler, path;
path = new Path(pretend.robot);
callback = sinon.spy();
handler = path.getHandler(['foo', 'bar'], callback);
return handler.should.be.a('function');</code></pre></li><li class="suite"><h1>when handler called with response</h1><ul><li class="test pass fast"><h2>calls the callback with the response<span class="duration">1ms</span></h2><pre><code>var callback, handler, mockRes, path;
path = new Path(pretend.robot);
callback = sinon.spy();
handler = path.getHandler(['foo', 'bar'], callback);
mockRes = {
  reply: sinon.spy()
};
handler(mockRes);
return callback.should.have.calledWithExactly(mockRes);</code></pre></li><li class="test pass fast"><h2>sends strings with dialogue if it has one<span class="duration">0ms</span></h2><pre><code>var handler, mockRes, path;
path = new Path(pretend.robot);
handler = path.getHandler(['foo', 'bar']);
mockRes = {
  reply: sinon.spy(),
  dialogue: {
    send: sinon.spy()
  }
};
handler(mockRes);
return mockRes.dialogue.send.should.have.calledWith('foo', 'bar');</code></pre></li><li class="test pass fast"><h2>uses response reply if there is no dialogue<span class="duration">0ms</span></h2><pre><code>var handler, mockRes, path;
path = new Path(pretend.robot);
handler = path.getHandler(['foo', 'bar']);
mockRes = {
  reply: sinon.spy()
};
handler(mockRes);
return mockRes.reply.should.have.calledWith('foo', 'bar');</code></pre></li><li class="test pass fast"><h2>returns promise resolving with send results<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var handler, handlerSpy, mockRes, path;
  path = new Path(pretend.robot);
  handler = path.getHandler(['foo'], function() {
    return {
      bar: 'baz'
    };
  });
  mockRes = {
    reply: sinon.spy()
  };
  handlerSpy = sinon.spy(handler);
  yield handler(mockRes);
  return handlerSpy.returned(sinon.match(resMatch));
});</code></pre></li><li class="test pass fast"><h2>returns promise also merged with callback results<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  var handler, handlerSpy, mockRes, path;
  path = new Path(pretend.robot);
  handler = path.getHandler(['foo'], function() {
    return {
      bar: 'baz'
    };
  });
  mockRes = {
    reply: sinon.spy()
  };
  handlerSpy = sinon.spy(handler);
  yield handler(mockRes);
  return handlerSpy.returned(sinon.match({
    bar: 'baz'
  }));
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.match</h1><ul><li class="suite"><h1>with string matching branch regex</h1><ul><li class="test pass fast"><h2>updates match in response object<span class="duration">6ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var expectedMatch;
    yield pretend.user('sam').send('door 1');
    yield _this.path.match(pretend.lastListen());
    expectedMatch = 'door 1'.match(_this.path.branches[0].regex);
    return pretend.lastListen().match.should.eql(expectedMatch);
  };
})(this));</code></pre></li><li class="test pass fast"><h2>closes the path<span class="duration">6ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door 2');
    yield _this.path.match(pretend.lastListen());
    return _this.path.closed.should.be[&quot;true&quot;];
  };
})(this));</code></pre></li><li class="test pass fast"><h2>calls the handler for matching branch with res<span class="duration">7ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var res;
    _this.path.branches[1].handler = sinon.stub();
    yield pretend.user('sam').send('door 2');
    res = pretend.lastListen();
    yield _this.path.match(res);
    return _this.path.branches[1].handler.should.have.calledWithExactly(res);
  };
})(this));</code></pre></li><li class="test pass fast"><h2>emits match with res<span class="duration">6ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door 2');
    yield _this.path.match(pretend.lastListen());
    return _this.match.should.have.calledWith(sinon.match(resMatch));
  };
})(this));</code></pre></li></ul></li><li class="suite"><h1>with string matching multiple branches</h1><ul><li class="test pass fast"><h2>updates match in response object<span class="duration">6ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var expectedMatch;
    yield pretend.user('sam').send('door 1 and door 2');
    yield _this.path.match(pretend.lastListen());
    expectedMatch = 'door 1 and door 2'.match(_this.path.branches[0].regex);
    return pretend.lastListen().match.should.eql(expectedMatch);
  };
})(this));</code></pre></li><li class="test pass fast"><h2>calls the first matching branch handler<span class="duration">5ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var result;
    yield pretend.user('sam').send('door 1 and door 2');
    result = (yield _this.path.match(pretend.lastListen()));
    return result.should.have.property('winner', false);
  };
})(this));</code></pre></li><li class="test pass fast"><h2>closes the path<span class="duration">9ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door 1 and door 2');
    yield _this.path.match(pretend.lastListen());
    return _this.path.closed.should.be[&quot;true&quot;];
  };
})(this));</code></pre></li></ul></li><li class="suite"><h1>with mismatching string and no catch</h1><ul><li class="test pass fast"><h2>returns undefined<span class="duration">5ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var result;
    yield pretend.user('sam').send('door X');
    result = (yield _this.path.match(pretend.lastListen()));
    return chai.expect(result).to.be.undefined;
  };
})(this));</code></pre></li><li class="test pass fast"><h2>updates match to null in response object<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door X');
    yield _this.path.match(pretend.lastListen());
    return chai.expect(pretend.lastListen().match).to.be[&quot;null&quot;];
  };
})(this));</code></pre></li><li class="test pass fast"><h2>path stays open<span class="duration">5ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door X');
    yield _this.path.match(pretend.lastListen());
    return _this.path.closed.should.be[&quot;false&quot;];
  };
})(this));</code></pre></li><li class="test pass fast"><h2>emits mismatch with res<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door X');
    yield _this.path.match(pretend.lastListen());
    return _this.mismatch.should.have.calledWith(sinon.match(resMatch));
  };
})(this));</code></pre></li></ul></li><li class="suite"><h1>with mismatching string and catch message</h1><ul><li class="test pass fast"><h2>returns the response from send<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var result;
    _this.path.configure({
      catchMessage: 'no, wrong door'
    });
    yield pretend.user('sam').send('door X');
    result = (yield _this.path.match(pretend.lastListen()));
    return result.strings.should.eql(['no, wrong door']);
  };
})(this));</code></pre></li><li class="test pass fast"><h2>emits catch with res<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    _this.path.configure({
      catchMessage: 'no, wrong door'
    });
    yield pretend.user('sam').send('door X');
    yield _this.path.match(pretend.lastListen());
    return _this[&quot;catch&quot;].should.have.calledWith(sinon.match(resMatch));
  };
})(this));</code></pre></li></ul></li><li class="suite"><h1>with mismatching string and catch callback</h1><ul><li class="test pass fast"><h2>returns the result of the callback<span class="duration">3ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var result;
    _this.path.configure({
      catchCallback: function() {
        return {
          other: 'door fail'
        };
      }
    });
    yield pretend.user('sam').send('door X');
    result = (yield _this.path.match(pretend.lastListen()));
    return result.should.have.property('other', 'door fail');
  };
})(this));</code></pre></li><li class="test pass fast"><h2>emits catch with res<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    _this.path.configure({
      catchMessage: 'no, wrong door'
    });
    yield pretend.user('sam').send('door X');
    yield _this.path.match(pretend.lastListen());
    return _this[&quot;catch&quot;].should.have.calledWith(sinon.match(resMatch));
  };
})(this));</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Dialogue</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="test pass fast"><h2>has null path<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
return should.equal(dialogue.path, null);</code></pre></li><li class="test pass fast"><h2>is not ended<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
return dialogue.ended.should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>uses timeout from env<span class="duration">0ms</span></h2><pre><code>var dialogue;
process.env.DIALOGUE_TIMEOUT = 500;
dialogue = new Dialogue(testRes);
dialogue.config.timeout.should.equal(500);
return delete process.env.DIALOGUE_TIMEOUT;</code></pre></li></ul></li><li class="suite"><h1>.end</h1><ul><li class="suite"><h1>before messages received</h1><ul><li class="test pass fast"><h2>emits end with initial response<span class="duration">0ms</span></h2><pre><code>var dialogue, end;
dialogue = new Dialogue(testRes);
end = sinon.spy();
dialogue.on('end', end);
dialogue.end();
return end.should.have.calledWith(testRes);</code></pre></li><li class="test pass fast"><h2>sets ended to true<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.end();
return dialogue.ended.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
return dialogue.end().should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>after messages received</h1><ul><li class="test pass fast"><h2>emits end with latest response (containing dialogue)<span class="duration">0ms</span></h2><pre><code>var dialogue, end;
dialogue = new Dialogue(testRes);
end = sinon.spy();
dialogue.on('end', end);
dialogue.receive(testRes);
dialogue.end();
return end.should.have.calledWith(sinon.match(matchRes));</code></pre></li></ul></li><li class="suite"><h1>when timeout is running</h1><ul><li class="test pass fast"><h2>clears the timeout<span class="duration">1ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.startTimeout();
dialogue.end();
return dialogue.clearTimeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>when already ended</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.end();
return dialogue.end().should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>should only emit end event once<span class="duration">0ms</span></h2><pre><code>var dialogue, end;
dialogue = new Dialogue(testRes);
end = sinon.spy();
dialogue.on('end', end);
dialogue.end();
dialogue.end();
return end.should.have.calledOnce;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.send</h1><ul><li class="suite"><h1>with config.sendReplies set to false</h1><ul><li class="test pass fast"><h2>sends to the room from original res<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  var dialogue;
  dialogue = new Dialogue(testRes);
  yield dialogue.send('test');
  return pretend.messages.pop().should.eql(['testing', 'hubot', 'test']);
});</code></pre></li><li class="test pass fast"><h2>emits send event with new response (containing dialogue)<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, sendSpy;
  dialogue = new Dialogue(testRes);
  sendSpy = sinon.spy();
  dialogue.on('send', sendSpy);
  yield dialogue.send('test');
  return sendSpy.should.have.calledWith(sinon.match(matchRes));
});</code></pre></li><li class="test pass fast"><h2>also emits with strings, methdod and original res<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  var dialogue, sendSpy;
  dialogue = new Dialogue(testRes);
  sendSpy = sinon.spy();
  dialogue.on('send', sendSpy);
  yield dialogue.send('test');
  return sendSpy.lastCall.args[1].should.eql({
    strings: ['test'],
    method: 'send',
    received: testRes
  });
});</code></pre></li></ul></li><li class="suite"><h1>with config.sendReplies set to true</h1><ul><li class="test pass fast"><h2>sends to room from original res, responding to the @user<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  var dialogue;
  dialogue = new Dialogue(testRes);
  dialogue.config.sendReplies = true;
  yield dialogue.send('test');
  return pretend.messages.pop().should.eql(['testing', 'hubot', '@tester test']);
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.onTimeout</h1><ul><li class="suite"><h1>default method</h1><ul><li class="test pass fast"><h2>sends timeout message to room<span class="duration">0ms</span></h2><pre><code>function* () {
          var dialogue, wait;
          wait = pretend.observer.next();
          dialogue = new Dialogue(testRes, {
            timeout: 1000
          });
          dialogue.startTimeout();
          clock.tick(1001);
          yield wait;
          return pretend.messages.pop().should.eql(['testing', 'hubot', dialogue.config.timeoutText]);
        }</code></pre></li></ul></li><li class="suite"><h1>method override (as argument)</h1><ul><li class="test pass fast"><h2>calls the override method<span class="duration">1ms</span></h2><pre><code>var dialogue, timeout;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
timeout = sinon.spy();
dialogue.onTimeout(timeout);
dialogue.startTimeout();
clock.tick(1001);
return timeout.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>does not send the default timeout message<span class="duration">1ms</span></h2><pre><code>var dialogue, timeout;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
timeout = sinon.spy();
dialogue.onTimeout(timeout);
dialogue.startTimeout();
clock.tick(1001);
return dialogue.send.should.not.have.been.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>method override (by assignment)</h1><ul><li class="test pass fast"><h2>calls the override method<span class="duration">1ms</span></h2><pre><code>var dialogue, timeout;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
timeout = sinon.spy();
dialogue.onTimeout = timeout;
dialogue.startTimeout();
clock.tick(1001);
return timeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>method override with invalid function</h1><ul><li class="test pass fast"><h2>throws exception<span class="duration">2ms</span></h2><pre><code>var dialogue, override;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
dialogue.onTimeout(function() {
  throw new Error(&quot;Test exception&quot;);
});
override = sinon.spy(dialogue, 'onTimeout');
dialogue.startTimeout();
try {
  clock.tick(1001);
} catch (error) {}
return override.should[&quot;throw&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.startTimeout</h1><ul><li class="test pass fast"><h2>emits timeout event<span class="duration">0ms</span></h2><pre><code>var dialogue, timeoutEvent, timeoutMethod;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
timeoutMethod = sinon.spy();
dialogue.onTimeout(timeoutMethod);
timeoutEvent = sinon.spy();
dialogue.on('timeout', timeoutEvent);
dialogue.startTimeout();
clock.tick(1001);
return timeoutEvent.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>emits end event<span class="duration">0ms</span></h2><pre><code>var dialogue, end, timeoutMethod;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
end = sinon.spy();
dialogue.on('end', end);
timeoutMethod = sinon.spy();
dialogue.onTimeout(timeoutMethod);
dialogue.startTimeout();
clock.tick(1001);
return end.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls onTimeout method<span class="duration">1ms</span></h2><pre><code>var dialogue, timeoutMethod;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
timeoutMethod = sinon.spy();
dialogue.onTimeout(timeoutMethod);
dialogue.startTimeout();
clock.tick(1001);
return timeoutMethod.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls .end<span class="duration">1ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000,
  timeoutText: null
});
dialogue.startTimeout();
clock.tick(1001);
return dialogue.end.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>.addPath</h1><ul><li class="suite"><h1>with a prompt, branches and key</h1><ul><li class="test pass fast"><h2>returns new Path instance<span class="duration">2ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath('Turn left or right?', [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']], 'which-way'));
  return path.should.be[&quot;instanceof&quot;](dialogue.Path);
});</code></pre></li><li class="test pass fast"><h2>passes options to path<span class="duration">3ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath('Turn left or right?', [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']], 'which-way'));
  return path.key.should.eql('which-way');
});</code></pre></li><li class="test pass fast"><h2>sends the prompt<span class="duration">2ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath('Turn left or right?', [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']], 'which-way'));
  return dialogue.send.should.have.calledWith('Turn left or right?');
});</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">2ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath('Turn left or right?', [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']], 'which-way'));
  return dialogue.startTimeout.should.have.calledOnce;
});</code></pre></li></ul></li><li class="suite"><h1>with branches only</h1><ul><li class="test pass fast"><h2>returns new Path instance<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath([[/1/, 'You get cake!'], [/2/, 'You get cake!']]));
  return path.should.be[&quot;instanceof&quot;](dialogue.Path);
});</code></pre></li><li class="test pass fast"><h2>sends nothing<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath([[/1/, 'You get cake!'], [/2/, 'You get cake!']]));
  return dialogue.send.should.not.have.called;
});</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath([[/1/, 'You get cake!'], [/2/, 'You get cake!']]));
  return dialogue.startTimeout.should.have.calledOnce;
});</code></pre></li></ul></li><li class="suite"><h1>without branches</h1><ul><li class="test pass fast"><h2>returns new Path instance<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath(&quot;Don't say nothing.&quot;));
  return path.should.be[&quot;instanceof&quot;](dialogue.Path);
});</code></pre></li><li class="test pass fast"><h2>does not start timeout<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath(&quot;Don't say nothing.&quot;));
  return dialogue.startTimeout.should.not.have.called;
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.addBranch</h1><ul><li class="suite"><h1>with existing path</h1><ul><li class="test pass fast"><h2>passes branch args on to path.addBranch<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.path = {
  addBranch: sinon.spy()
};
dialogue.addBranch(/foo/, 'foo');
return dialogue.path.addBranch.should.have.calledWith(/foo/, 'foo');</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">1ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.path = {
  addBranch: sinon.spy()
};
dialogue.addBranch(/foo/, 'foo');
return dialogue.startTimeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>when no path exists</h1><ul><li class="test pass fast"><h2>creates a new path<span class="duration">1ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, 'foo');
return dialogue.path.should.be[&quot;instanceof&quot;](dialogue.Path);</code></pre></li><li class="test pass fast"><h2>passes branch args on to path.addBranch<span class="duration">1ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
sinon.spy(dialogue.Path.prototype, 'addBranch');
dialogue.addBranch(/foo/, 'foo');
return dialogue.path.addBranch.should.have.calledWith(/foo/, 'foo');</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, 'foo');
return dialogue.startTimeout.should.have.calledOnce;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.receive</h1><ul><li class="test pass fast"><h2>stores the latest response object<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/.*/, function() {});
dialogue.receive(pretend.response('tester', 'new test'));
return dialogue.res.message.text.should.equal('new test');</code></pre></li><li class="test pass fast"><h2>attaches itself to the response<span class="duration">4ms</span></h2><pre><code>var dialogue, newTestRes;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/.*/, function() {});
newTestRes = pretend.response('tester', 'new test');
dialogue.receive(newTestRes);
return newTestRes.dialogue.should.eql(dialogue);</code></pre></li><li class="suite"><h1>when already ended</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.end();
return dialogue.receive(testRes).should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>does not call the handler<span class="duration">0ms</span></h2><pre><code>var callback, dialogue;
dialogue = new Dialogue(testRes);
callback = sinon.spy();
dialogue.addBranch(/.*/, callback);
dialogue.end();
dialogue.receive(testRes);
return callback.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on matching branch</h1><ul><li class="test pass fast"><h2>clears timeout<span class="duration">4ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {
  return null;
});
dialogue.receive(pretend.response('tester', 'foo'));
return dialogue.clearTimeout.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>ends dialogue<span class="duration">6ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {
  return null;
});
dialogue.receive(pretend.response('tester', 'foo'));
return dialogue.end.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls the branch handler<span class="duration">5ms</span></h2><pre><code>var callback, dialogue;
dialogue = new Dialogue(testRes);
callback = sinon.spy();
dialogue.addBranch(/foo/, 'bar', callback);
dialogue.receive(pretend.response('tester', 'foo'));
return callback.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>sends the branch message<span class="duration">4ms</span></h2><pre><code>var callback, dialogue;
dialogue = new Dialogue(testRes);
callback = sinon.spy();
dialogue.addBranch(/foo/, 'bar', callback);
dialogue.receive(pretend.response('tester', 'foo'));
return dialogue.send.should.have.calledWith('bar');</code></pre></li></ul></li><li class="suite"><h1>on matching branches consecutively</h1><ul><li class="test pass fast"><h2>only processes first match<span class="duration">8ms</span></h2><pre><code>var callback, dialogue;
dialogue = new Dialogue(testRes);
callback = sinon.spy();
dialogue.addBranch(/foo/, callback);
dialogue.addBranch(/bar/, callback);
dialogue.receive(pretend.response('tester', 'foo'));
dialogue.receive(pretend.response('tester', 'bar'));
return callback.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>on mismatch with catch</h1><ul><li class="test pass fast"><h2>sends the catch message<span class="duration">4ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {});
dialogue.path.config.catchMessage = 'huh?';
dialogue.receive(pretend.response('tester', '?'));
return dialogue.send.should.have.calledWith('huh?');</code></pre></li><li class="test pass fast"><h2>does not clear timeout<span class="duration">8ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {});
dialogue.path.config.catchMessage = 'huh?';
dialogue.receive(pretend.response('tester', '?'));
return dialogue.clearTimeout.should.not.have.called;</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {});
dialogue.path.config.catchMessage = 'huh?';
dialogue.receive(pretend.response('tester', '?'));
return dialogue.end.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on mismatch without catch</h1><ul><li class="test pass fast"><h2>does not clear timeout<span class="duration">4ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {});
dialogue.receive(pretend.response('tester', '?'));
return dialogue.clearTimeout.should.not.have.called;</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">4ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {});
dialogue.receive(pretend.response('tester', '?'));
return dialogue.end.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on matching branch that adds a new branch</h1><ul><li class="test pass fast"><h2>added branches to current path<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/more/, function() {
  dialogue.addBranch(/1/, 'got 1');
  return dialogue.addBranch(/2/, 'got 2');
});
dialogue.receive(pretend.response('tester', 'more'));
return _.map(dialogue.path.branches, function(branch) {
  return branch.regex;
}).should.eql([/more/, /1/, /2/]);</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">6ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/more/, function() {
  dialogue.addBranch(/1/, 'got 1');
  return dialogue.addBranch(/2/, 'got 2');
});
dialogue.receive(pretend.response('tester', 'more'));
return dialogue.end.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on matching branch that adds a new path</h1><ul><li class="test pass fast"><h2>added new branches to new path, overwrites prev path<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/new/, function() {
  return dialogue.addPath([[/1/, 'got 1'], [/2/, 'got 2']]);
});
dialogue.receive(pretend.response('tester', 'new'));
return _.map(dialogue.path.branches, function(branch) {
  return branch.regex;
}).should.eql([/1/, /2/]);</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/new/, function() {
  return dialogue.addPath([[/1/, 'got 1'], [/2/, 'got 2']]);
});
dialogue.receive(pretend.response('tester', 'new'));
return dialogue.end.should.not.have.called;</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Scene</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>without options</h1><ul><li class="test pass fast"><h2>defaults to `user` scope<span class="duration">0ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
return scene.config.scope.should.equal('user');</code></pre></li><li class="test pass fast"><h2>attaches receive middleware to robot<span class="duration">0ms</span></h2><pre><code>new Scene(pretend.robot);
return pretend.robot.receiveMiddleware.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>with options</h1><ul><li class="test pass fast"><h2>stored options in config object<span class="duration">0ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot, {
  sendReplies: true
});
return scene.config.sendReplies.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>with room scope option</h1><ul><li class="test pass fast"><h2>accepts given room scope<span class="duration">0ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot, {
  scope: 'room'
});
return scene.config.scope.should.equal('room');</code></pre></li><li class="test pass fast"><h2>stores config with default options for scope<span class="duration">0ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot, {
  scope: 'room'
});
return scene.config.sendReplies.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>with invalid scope</h1><ul><li class="test pass fast"><h2>throws error when given invalid scope<span class="duration">2ms</span></h2><pre><code>try {
  new Scene(pretend.robot, {
    scope: 'monkey'
  });
} catch (error) {}
return Scene.prototype.constructor.should[&quot;throw&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.listen</h1><ul><li class="test pass fast"><h2>accepts a string that can be cast as RegExp<span class="duration">1ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
scene.listen('hear', '/test/i', function() {
  return null;
});
return pretend.robot.listeners.pop().regex.should.eql(/test/i);</code></pre></li><li class="suite"><h1>with hear type and message matching regex</h1><ul><li class="test pass fast"><h2>registers a robot hear listener with scene as attribute<span class="duration">1ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
scene.listen('hear', /test/, function() {
  return null;
});
return pretend.robot.hear.should.have.calledWithMatch(sinon.match.regexp, sinon.match.has('scene', scene, sinon.match.func));</code></pre></li><li class="test pass fast"><h2>calls callback from listener when matched<span class="duration">7ms</span></h2><pre><code>return co(function*() {
  var callback, scene;
  scene = new Scene(pretend.robot);
  callback = sinon.spy();
  scene.listen('hear', /test/, callback);
  yield pretend.user('tester').send('test');
  return callback.should.have.calledOnce;
});</code></pre></li><li class="test pass fast"><h2>callback should receive res and dialogue<span class="duration">5ms</span></h2><pre><code>var callback, scene;
scene = new Scene(pretend.robot);
callback = sinon.spy();
scene.listen('hear', /test/, callback);
return pretend.user('tester').send('test').then(function() {
  return callback.should.have.calledWith(matchRes);
});</code></pre></li></ul></li><li class="suite"><h1>with respond type and message matching regex</h1><ul><li class="test pass fast"><h2>registers a robot respond listener with scene as attribute<span class="duration">5ms</span></h2><pre><code>var callback, id, scene;
scene = new Scene(pretend.robot);
callback = sinon.spy();
id = scene.listen('respond', /test/, callback);
return pretend.user('tester').send('hubot test').then(function() {
  return pretend.robot.respond.should.have.calledWithMatch(sinon.match.regexp, sinon.match.has('scene', scene, sinon.match.func));
});</code></pre></li><li class="test pass fast"><h2>calls callback from listener when matched<span class="duration">5ms</span></h2><pre><code>return co(function*() {
  var callback, id, scene;
  scene = new Scene(pretend.robot);
  callback = sinon.spy();
  id = scene.listen('respond', /test/, callback);
  yield pretend.user('tester').send('hubot test');
  return callback.should.have.calledOnce;
});</code></pre></li><li class="test pass fast"><h2>callback should receive res and dialogue<span class="duration">5ms</span></h2><pre><code>return co(function*() {
  var callback, id, scene;
  scene = new Scene(pretend.robot);
  callback = sinon.spy();
  id = scene.listen('respond', /test/, callback);
  yield pretend.user('tester').send('hubot test');
  return callback.should.have.calledWith(matchRes);
});</code></pre></li></ul></li><li class="suite"><h1>with an invalid listener type</h1><ul><li class="test pass fast"><h2>throws<span class="duration">0ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
try {
  scene.listen('smell', /test/, function() {
    return null;
  });
} catch (error) {}
return scene.listen.should[&quot;throw&quot;];</code></pre></li></ul></li><li class="suite"><h1>with an invalid regex</h1><ul><li class="test pass fast"><h2>throws<span class="duration">0ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
try {
  scene.listen('hear', 'test', function() {
    return null;
  });
} catch (error) {}
return scene.listen.should[&quot;throw&quot;];</code></pre></li></ul></li><li class="suite"><h1>with an invalid callback</h1><ul><li class="test pass fast"><h2>throws<span class="duration">1ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
try {
  scene.listen('hear', /test/, {
    not: 'a function '
  });
} catch (error) {}
return scene.listen.should[&quot;throw&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.hear</h1><ul><li class="test pass fast"><h2>calls .listen with hear listen type and arguments<span class="duration">0ms</span></h2><pre><code>var expectedArgs, ref, scene;
scene = new Scene(pretend.robot);
scene.hear(/test/, function() {
  return null;
});
expectedArgs = ['hear', /test/, sinon.match.func];
return (ref = scene.listen.getCall(0).should.have).calledWith.apply(ref, expectedArgs);</code></pre></li></ul></li><li class="suite"><h1>.respond</h1><ul><li class="test pass fast"><h2>calls .listen with respond listen type and arguments<span class="duration">0ms</span></h2><pre><code>var expectedArgs, ref, scene;
scene = new Scene(pretend.robot);
scene.respond(/test/, function() {
  return null;
});
expectedArgs = ['respond', /test/, sinon.match.func];
return (ref = scene.listen.getCall(0).should.have).calledWith.apply(ref, expectedArgs);</code></pre></li></ul></li><li class="suite"><h1>.whoSpeaks</h1><ul><li class="suite"><h1>user scene</h1><ul><li class="test pass fast"><h2>returns the ID of engaged user<span class="duration">0ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot, {
  scope: 'user'
});
return scene.whoSpeaks(pretend.lastReceive()).should.equal('user_111');</code></pre></li></ul></li><li class="suite"><h1>room sceene</h1><ul><li class="test pass fast"><h2>returns the room ID<span class="duration">0ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot, {
  scope: 'room'
});
return scene.whoSpeaks(pretend.lastReceive()).should.equal('testing');</code></pre></li></ul></li><li class="suite"><h1>direct scene</h1><ul><li class="test pass fast"><h2>returns the concatenated user ID and room ID<span class="duration">1ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot, {
  scope: 'direct'
});
return scene.whoSpeaks(pretend.lastReceive()).should.equal('user_111_testing');</code></pre></li></ul></li></ul></li><li class="suite"><h1>.registerMiddleware</h1><ul><li class="test pass fast"><h2>accepts function for enter middleware stack<span class="duration">1ms</span></h2><pre><code>var piece, scene;
piece = function(context, next, done) {
  return null;
};
scene = new Scene(pretend.robot);
scene.registerMiddleware(piece);
return scene.enterMiddleware.stack[0].should.eql(piece);</code></pre></li><li class="test pass fast"><h2>throws when given function with incorrect arguments<span class="duration">0ms</span></h2><pre><code>var piece, scene;
piece = function(notEnoughArgs) {
  return null;
};
scene = new Scene(pretend.robot);
try {
  scene.registerMiddleware(piece);
} catch (error) {}
scene.registerMiddleware.should[&quot;throw&quot;];
return scene.enterMiddleware.stack.length.should.equal(0);</code></pre></li></ul></li><li class="suite"><h1>.enter</h1><ul><li class="test pass fast"><h2>returns a promise (then-able)<span class="duration">1ms</span></h2><pre><code>var promise, scene;
scene = new Scene(pretend.robot);
promise = scene.enter(pretend.lastReceive());
return promise.then.should.be.a('function');</code></pre></li><li class="test pass fast"><h2>calls .processEnter with context<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot);
  yield scene.enter(pretend.lastReceive());
  return scene.processEnter.should.have.calledOnce;
});</code></pre></li><li class="test pass fast"><h2>resolves with created dialogue<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  var result, scene;
  scene = new Scene(pretend.robot);
  result = (yield scene.enter(pretend.lastReceive()));
  return result.should.be[&quot;instanceof&quot;](Dialogue);
});</code></pre></li><li class="suite"><h1>with callback</h1><ul><li class="test pass fast"><h2>calls callback with final enter process context<span class="duration">1ms</span></h2><pre><code>var callback, keys, scene;
scene = new Scene(pretend.robot);
keys = ['response', 'participants', 'options', 'arguments', 'dialogue'];
callback = function(result) {
  var ref;
  (ref = result.should.have.all).keys.apply(ref, keys);
  return done();
};
scene.enter(pretend.lastReceive(), callback);</code></pre></li></ul></li><li class="suite"><h1>with passing middleware</h1><ul><li class="test pass fast"><h2>completes processing to resolve with dialogue<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var result, scene;
  scene = new Scene(pretend.robot);
  scene.registerMiddleware(function(context, next, done) {
    return next();
  });
  result = (yield scene.enter(pretend.lastReceive()));
  return result.should.be[&quot;instanceof&quot;](Dialogue);
});</code></pre></li><li class="test pass fast"><h2>calls callback with final enter process context<span class="duration">3ms</span></h2><pre><code>var callback, keys, scene;
scene = new Scene(pretend.robot);
keys = ['response', 'participants', 'options', 'arguments', 'dialogue'];
callback = function(result) {
  var ref;
  (ref = result.should.have.all).keys.apply(ref, keys);
  return done();
};
scene.registerMiddleware(function(context, next, done) {
  return next();
});
scene.enter(pretend.lastReceive(), callback);</code></pre></li></ul></li><li class="suite"><h1>with blocking middleware</h1><ul><li class="test pass fast"><h2>does not complete or call .processEnter<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot);
  scene.registerMiddleware(function(context, next, done) {
    return done();
  });
  yield scene.enter(pretend.lastReceive());
  return scene.processEnter.should.not.have.called;
});</code></pre></li></ul></li><li class="suite"><h1>with custom done function override</h1><ul><li class="test pass fast"><h2>completes processing and calls custom done<span class="duration">2ms</span></h2><pre><code>return co(function*() {
  var custom, scene;
  scene = new Scene(pretend.robot);
  custom = sinon.spy();
  scene.registerMiddleware(function(context, next, done) {
    return next(function() {
      custom();
      return done();
    });
  });
  yield scene.enter(pretend.lastReceive());
  return custom.should.have.calledOnce;
});</code></pre></li></ul></li><li class="suite"><h1>with multiple middleware pieces</h1><ul><li class="test pass fast"><h2>calls each sequentially passing ammended context<span class="duration">14ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
scene.registerMiddleware(function(context, next, done) {
  context.trace = ['A'];
  return next();
});
scene.registerMiddleware(function(context, next, done) {
  context.trace.push('B');
  return next();
});
scene.registerMiddleware(function(context, next, done) {
  context.trace.push('C');
  return next();
});
scene.enter(pretend.lastReceive(), function(result) {
  result.trace.should.eql(['A', 'B', 'C']);
  return done();
});</code></pre></li><li class="test pass fast"><h2>does not process enter if any middleware blocks<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot);
  scene.registerMiddleware(function(context, next, done) {
    return next();
  });
  scene.registerMiddleware(function(context, next, done) {
    return done();
  });
  scene.registerMiddleware(function(context, next, done) {
    return next();
  });
  yield scene.enter(pretend.lastReceive());
  return scene.processEnter.should.not.have.called;
});</code></pre></li></ul></li><li class="suite"><h1>user scene</h1><ul><li class="test pass fast"><h2>saves engaged Dialogue instance with user ID<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot, {
    scope: 'user'
  });
  yield scene.enter(pretend.lastReceive());
  return scene.engaged['user_111'].should.be[&quot;instanceof&quot;](Dialogue);
});</code></pre></li></ul></li><li class="suite"><h1>room scene</h1><ul><li class="test pass fast"><h2>saves engaged Dialogue instance with room key<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot, {
    scope: 'room'
  });
  yield scene.enter(pretend.lastReceive());
  return scene.engaged['testing'].should.be[&quot;instanceof&quot;](Dialogue);
});</code></pre></li></ul></li><li class="suite"><h1>direct scene</h1><ul><li class="test pass fast"><h2>saves engaged Dialogue instance with composite key<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot, {
    scope: 'direct'
  });
  yield scene.enter(pretend.lastReceive());
  return scene.engaged['user_111_testing'].should.be[&quot;instanceof&quot;](Dialogue);
});</code></pre></li></ul></li><li class="suite"><h1>with timeout options</h1><ul><li class="test pass fast"><h2>passes the options to dialogue config<span class="duration">0ms</span></h2><pre><code>function* () {
          var dialogue, scene;
          scene = new Scene(pretend.robot);
          dialogue = (yield scene.enter(pretend.lastReceive(), {
            timeout: 100,
            timeoutText: 'foo'
          }));
          dialogue.config.timeout.should.equal(100);
          return dialogue.config.timeoutText.should.equal('foo');
        }</code></pre></li></ul></li><li class="suite"><h1>dialogue allowed to timeout after branch added</h1><ul><li class="test pass fast"><h2>calls .exit first on &quot;timeout&quot;<span class="duration">2ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
scene.enter(pretend.lastReceive(), {
  timeout: 10,
  timeoutText: null
}).then(function(dialogue) {
  dialogue.on('end', function() {
    scene.exit.getCall(0).should.have.calledWith(pretend.lastReceive(), 'timeout');
    return done();
  });
  dialogue.startTimeout();
  return clock.tick(11);
});</code></pre></li><li class="test pass fast"><h2>calls .exit again on &quot;incomplete&quot;<span class="duration">1ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
scene.enter(pretend.lastReceive(), {
  timeout: 10,
  timeoutText: null
}).then(function(dialogue) {
  dialogue.on('end', function() {
    scene.exit.getCall(1).should.have.calledWith(pretend.lastReceive(), 'incomplete');
    return done();
  });
  dialogue.startTimeout();
  return clock.tick(11);
});</code></pre></li></ul></li><li class="suite"><h1>dialogue completed (by message matching branch)</h1><ul><li class="test pass fast"><h2>calls .exit once only<span class="duration">2ms</span></h2><pre><code>return co(function*() {
  var dialogue, scene;
  scene = new Scene(pretend.robot);
  dialogue = (yield scene.enter(pretend.lastReceive()));
  dialogue.addBranch(matchAny, '');
  yield pretend.user('tester').send('test');
  yield pretend.user('tester').send('testing again');
  return scene.exit.should.have.calledOnce;
});</code></pre></li><li class="test pass fast"><h2>calls .exit once with last (matched) res and &quot;complete&quot;<span class="duration">4ms</span></h2><pre><code>return co(function*() {
  var dialogue, scene;
  scene = new Scene(pretend.robot);
  dialogue = (yield scene.enter(pretend.lastReceive()));
  dialogue.addBranch(matchAny, '');
  yield pretend.user('tester').send('test');
  yield pretend.user('tester').send('testing again');
  return scene.exit.should.have.calledWith(dialogue.res, 'complete');
});</code></pre></li></ul></li><li class="suite"><h1>re-enter currently engaged participants</h1><ul><li class="test pass fast"><h2>returns error the second time<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var resultA, resultB, scene;
  scene = new Scene(pretend.robot);
  resultA = (yield scene.enter(pretend.lastReceive()));
  try {
    resultB = (yield scene.enter(pretend.lastReceive()));
  } catch (error) {}
  return scene.enter.should[&quot;throw&quot;];
});</code></pre></li><li class="test pass fast"><h2>rejected enter can be caught<span class="duration">1ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
scene.enter(pretend.lastReceive()).then(function() {
  return scene.enter(pretend.lastReceive())[&quot;catch&quot;](function(err) {
    err.should.be[&quot;instanceof&quot;](Error);
    return done();
  });
});</code></pre></li></ul></li><li class="suite"><h1>re-enter previously engaged participants</h1><ul><li class="test pass fast"><h2>returns Dialogue instance (as per normal)<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogueA, dialogueB, scene;
  scene = new Scene(pretend.robot);
  dialogueA = (yield scene.enter(pretend.lastReceive()));
  scene.exit(pretend.lastReceive());
  dialogueB = (yield scene.enter(pretend.lastReceive()));
  return dialogueB.should.be[&quot;instanceof&quot;](Dialogue);
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.exit</h1><ul><li class="suite"><h1>with user in scene, called manually</h1><ul><li class="test pass fast"><h2>does not call onTimeout on dialogue<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, scene, timeout;
  scene = new Scene(pretend.robot);
  dialogue = (yield scene.enter(pretend.lastReceive(), {
    timeout: 10
  }));
  dialogue.addBranch(matchAny, '');
  timeout = sinon.spy();
  dialogue.onTimeout(timeout);
  scene.exit(pretend.lastReceive(), 'testing exits');
  clock.tick(11);
  return timeout.should.not.have.called;
});</code></pre></li><li class="test pass fast"><h2>removes the dialogue instance from engaged array<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot);
  yield scene.enter(pretend.lastReceive(), {
    timeout: 10
  });
  scene.exit(pretend.lastReceive(), 'testing exits');
  return should.not.exist(scene.engaged['user_111']);
});</code></pre></li><li class="test pass fast"><h2>returns true<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot);
  yield scene.enter(pretend.lastReceive(), {
    timeout: 10
  });
  scene.exit(pretend.lastReceive(), 'testing exits');
  clock.tick(11);
  return scene.exit.returnValues.pop().should.be[&quot;true&quot;];
});</code></pre></li><li class="test pass fast"><h2>logged the reason<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot);
  scene.id = 'scene_111';
  yield scene.enter(pretend.lastReceive(), {
    timeout: 10
  });
  scene.exit(pretend.lastReceive(), 'testing exits');
  clock.tick(11);
  return pretend.logs.pop().should.eql(['info', 'Disengaged user user_111 (testing exits) (id: scene_111)']);
});</code></pre></li><li class="test pass fast"><h2>dialogue does not continue receiving after scene exit<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, scene;
  scene = new Scene(pretend.robot);
  dialogue = (yield scene.enter(pretend.lastReceive(), {
    timeout: 10
  }));
  dialogue.addBranch(matchAny, '');
  dialogue.receive = sinon.spy();
  scene.exit(pretend.lastReceive(), 'tester');
  pretend.user('tester').send('test');
  clock.tick(11);
  return dialogue.receive.should.not.have.called;
});</code></pre></li></ul></li><li class="suite"><h1>with user in scene, called from events</h1><ul><li class="test pass fast"><h2>gets called twice (on timeout and end)<span class="duration">2ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
scene.enter(pretend.lastReceive(), {
  timeout: 10
}).then(function(dialogue) {
  dialogue.on('end', function() {
    scene.exit.should.have.calledTwice;
    return done();
  });
  dialogue.addBranch(matchAny, '');
  return clock.tick(11);
});</code></pre></li><li class="test pass fast"><h2>returns true the first time<span class="duration">1ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
scene.enter(pretend.lastReceive(), {
  timeout: 10
}).then(function(dialogue) {
  dialogue.on('end', function() {
    scene.exit.getCall(0).should.have.returned(true);
    return done();
  });
  dialogue.addBranch(matchAny, '');
  return clock.tick(11);
});</code></pre></li><li class="test pass fast"><h2>returns false the second time (because already disengaged)<span class="duration">1ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
scene.enter(pretend.lastReceive(), {
  timeout: 10
}).then(function(dialogue) {
  dialogue.on('end', function() {
    scene.exit.getCall(1).should.have.returned(false);
    return done();
  });
  dialogue.addBranch(matchAny, '');
  return clock.tick(11);
});</code></pre></li></ul></li><li class="suite"><h1>user not in scene, called manually</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>var scene;
scene = new Scene(pretend.robot);
scene.exit(pretend.lastReceive(), 'testing exits');
return scene.exit.returnValues.pop().should.be[&quot;false&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.exitAll</h1><ul><li class="suite"><h1>with two users in scene</h1><ul><li class="test pass fast"><h2>created two dialogues<span class="duration">9ms</span></h2><pre><code>return co(function*() {
  var dialogueA, dialogueB, scene;
  scene = new Scene(pretend.robot);
  dialogueB = (yield scene.enter(pretend.response('A', 'test')));
  dialogueA = (yield scene.enter(pretend.response('B', 'test')));
  scene.exitAll();
  dialogueA.should.be[&quot;instanceof&quot;](Dialogue);
  return dialogueB.should.be[&quot;instanceof&quot;](Dialogue);
});</code></pre></li><li class="test pass fast"><h2>calls clearTimeout on both dialogues<span class="duration">8ms</span></h2><pre><code>return co(function*() {
  var dialogueA, dialogueB, scene;
  scene = new Scene(pretend.robot);
  dialogueB = (yield scene.enter(pretend.response('A', 'test')));
  dialogueA = (yield scene.enter(pretend.response('B', 'test')));
  dialogueA.clearTimeout = sinon.spy();
  dialogueB.clearTimeout = sinon.spy();
  scene.exitAll();
  dialogueA.clearTimeout.should.have.calledOnce;
  return dialogueB.clearTimeout.should.have.calledOnce;
});</code></pre></li><li class="test pass fast"><h2>has no remaining engaged dialogues<span class="duration">8ms</span></h2><pre><code>return co(function*() {
  var dialogueA, dialogueB, scene;
  scene = new Scene(pretend.robot);
  dialogueB = (yield scene.enter(pretend.response('A', 'test')));
  dialogueA = (yield scene.enter(pretend.response('B', 'test')));
  scene.exitAll();
  return scene.engaged.length.should.equal(0);
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.getDialogue</h1><ul><li class="suite"><h1>with user in scene</h1><ul><li class="test pass fast"><h2>returns the matching dialogue<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogueA, dialogueB, scene;
  scene = new Scene(pretend.robot);
  dialogueA = (yield scene.enter(pretend.lastReceive()));
  dialogueB = scene.getDialogue('user_111');
  return dialogueB.should.eql(dialogueA);
});</code></pre></li></ul></li><li class="suite"><h1>no user in scene</h1><ul><li class="test pass fast"><h2>returns undefined<span class="duration">0ms</span></h2><pre><code>var dialogue, scene;
scene = new Scene(pretend.robot);
dialogue = scene.getDialogue('user_111');
return should.not.exist(dialogue);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.inDialogue</h1><ul><li class="suite"><h1>in engaged user scene</h1><ul><li class="test pass fast"><h2>returns true with user ID<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot);
  yield scene.enter(pretend.lastReceive());
  return scene.inDialogue('user_111').should.be[&quot;true&quot;];
});</code></pre></li><li class="test pass fast"><h2>returns false with room name<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot);
  yield scene.enter(pretend.lastReceive());
  return scene.inDialogue('testing').should.be[&quot;false&quot;];
});</code></pre></li></ul></li><li class="suite"><h1>participant not in scene</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot);
  yield scene.enter(pretend.lastReceive());
  return scene.inDialogue('user_222').should.be[&quot;false&quot;];
});</code></pre></li></ul></li><li class="suite"><h1>room scene, in scene</h1><ul><li class="test pass fast"><h2>returns true with roomname<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot, {
    scope: 'room'
  });
  yield scene.enter(pretend.lastReceive());
  return scene.inDialogue('testing').should.be[&quot;true&quot;];
});</code></pre></li><li class="test pass fast"><h2>returns false with user ID<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot, {
    scope: 'room'
  });
  yield scene.enter(pretend.lastReceive());
  return scene.inDialogue('user_111').should.be[&quot;false&quot;];
});</code></pre></li></ul></li><li class="suite"><h1>direct scene, in scene</h1><ul><li class="test pass fast"><h2>returns true with userID_roomID<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot, {
    scope: 'direct'
  });
  yield scene.enter(pretend.lastReceive());
  return scene.inDialogue('user_111_testing').should.be[&quot;true&quot;];
});</code></pre></li><li class="test pass fast"><h2>returns false with roomname<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot, {
    scope: 'direct'
  });
  yield scene.enter(pretend.lastReceive());
  return scene.inDialogue('testing').should.be[&quot;false&quot;];
});</code></pre></li><li class="test pass fast"><h2>returns false with user ID<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var scene;
  scene = new Scene(pretend.robot, {
    scope: 'direct'
  });
  yield scene.enter(pretend.lastReceive());
  return scene.inDialogue('user_111').should.be[&quot;false&quot;];
});</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Director</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>without optional args</h1><ul><li class="test pass fast"><h2>has empty array names<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql([]);</code></pre></li></ul></li><li class="suite"><h1>with authorise function</h1><ul><li class="test pass fast"><h2>stores the given function as its authorise method<span class="duration">0ms</span></h2><pre><code>return this.director.authorise = this.authorise;</code></pre></li></ul></li><li class="suite"><h1>with options (denied reply and key string)</h1><ul><li class="test pass fast"><h2>stores passed options in config<span class="duration">0ms</span></h2><pre><code>return this.director.config.deniedReply.should.equal(&quot;DENIED!&quot;);</code></pre></li></ul></li><li class="suite"><h1>with env var for config</h1><ul><li class="test pass fast"><h2>has default config with env inherited<span class="duration">0ms</span></h2><pre><code>return this.director.config.should.eql({
  type: 'whitelist',
  scope: 'username',
  deniedReply: &quot;403 Sorry.&quot;
});</code></pre></li></ul></li><li class="suite"><h1>with env var for names</h1><ul><li class="suite"><h1>whitelist type, username scope</h1><ul><li class="test pass fast"><h2>stores the whitelisted usernames from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Emmanuel']);</code></pre></li></ul></li><li class="suite"><h1>whitelist type, room scope</h1><ul><li class="test pass fast"><h2>stores the whitelisted rooms from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Capital']);</code></pre></li></ul></li><li class="suite"><h1>blacklist type, username scope</h1><ul><li class="test pass fast"><h2>stores the blacklisted usernames from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Winston', 'Julia', 'Syme']);</code></pre></li></ul></li><li class="suite"><h1>blacklist type, room scope</h1><ul><li class="test pass fast"><h2>stores the blacklisted rooms from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Labour']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>with invalid option for type</h1><ul><li class="test pass fast"><h2>should throw error<span class="duration">0ms</span></h2><pre><code>return Director.prototype.constructor.should[&quot;throw&quot;];</code></pre></li></ul></li><li class="suite"><h1>with invalid option for scope</h1><ul><li class="test pass fast"><h2>should throw error<span class="duration">0ms</span></h2><pre><code>return Director.prototype.constructor.should[&quot;throw&quot;];</code></pre></li></ul></li><li class="suite"><h1>without key, with authorise function and options</h1><ul><li class="test pass fast"><h2>uses options<span class="duration">0ms</span></h2><pre><code>return this.director.config.scope.should.equal('room');</code></pre></li><li class="test pass fast"><h2>uses authorise function<span class="duration">0ms</span></h2><pre><code>return this.director.authorise.should.eql(this.authorise);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.add</h1><ul><li class="suite"><h1>given array of names</h1><ul><li class="test pass fast"><h2>stores them in the names array<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['pema', 'nima']);</code></pre></li></ul></li><li class="suite"><h1>given single name</h1><ul><li class="test pass fast"><h2>stores it in the names array<span class="duration">1ms</span></h2><pre><code>return this.director.names.should.eql(['pema']);</code></pre></li></ul></li><li class="suite"><h1>given array of names, some existing</h1><ul><li class="test pass fast"><h2>adds any missing, not duplicating existing<span class="duration">1ms</span></h2><pre><code>return this.director.names.should.eql(['yeon', 'juan', 'pema']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.remove</h1><ul><li class="suite"><h1>given array of names</h1><ul><li class="test pass fast"><h2>removes them from the names array<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['yeon', 'juan']);</code></pre></li></ul></li><li class="suite"><h1>with single name</h1><ul><li class="test pass fast"><h2>removes it from the names array<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['yeon', 'juan', 'nima']);</code></pre></li></ul></li><li class="suite"><h1>with array names, some not existing</h1><ul><li class="test pass fast"><h2>removes any missing, ignoring others<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['yeon']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.isAllowed</h1><ul><li class="suite"><h1>whitelist without authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">3ms</span></h2><pre><code>var director;
director = new Director(pretend.robot);
return director.isAllowed(pretend.response('tester', 'test')).should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">5ms</span></h2><pre><code>var director;
director = new Director(pretend.robot);
director.names = ['tester'];
return director.isAllowed(pretend.response('tester', 'test')).should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">5ms</span></h2><pre><code>var director;
director = new Director(pretend.robot);
director.names = ['nobody'];
return director.isAllowed(pretend.response('tester', 'test')).should.be[&quot;false&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>blacklist without authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">4ms</span></h2><pre><code>var director;
director = new Director(pretend.robot, {
  type: 'blacklist'
});
return director.isAllowed(pretend.response('tester', 'test')).should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">4ms</span></h2><pre><code>var director;
director = new Director(pretend.robot, {
  type: 'blacklist'
});
director.names = ['tester'];
return director.isAllowed(pretend.response('tester', 'test')).should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">5ms</span></h2><pre><code>var director;
director = new Director(pretend.robot, {
  type: 'blacklist'
});
director.names = ['nobody'];
return director.isAllowed(pretend.response('tester', 'test')).should.be[&quot;true&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>whitelist with authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>calls authorise function with username and res<span class="duration">4ms</span></h2><pre><code>var authorise, director, res;
authorise = sinon.spy(function() {
  return 'AUTHORISE';
});
director = new Director(pretend.robot, authorise);
res = pretend.response('tester', 'test');
director.isAllowed(res);
return authorise.should.have.calledWith('tester', res);</code></pre></li><li class="test pass fast"><h2>returns value of authorise function<span class="duration">9ms</span></h2><pre><code>var authorise, director;
authorise = sinon.spy(function() {
  return 'AUTHORISE';
});
director = new Director(pretend.robot, authorise);
return director.isAllowed(pretend.response('tester', 'test')).should.equal('AUTHORISE');</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">5ms</span></h2><pre><code>var authorise, director;
authorise = sinon.spy(function() {
  return 'AUTHORISE';
});
director = new Director(pretend.robot, authorise);
director.names = ['tester'];
return director.isAllowed(pretend.response('tester', 'test')).should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>does not call authorise function<span class="duration">4ms</span></h2><pre><code>var authorise, director;
authorise = sinon.spy(function() {
  return 'AUTHORISE';
});
director = new Director(pretend.robot, authorise);
director.names = ['tester'];
director.isAllowed(pretend.response('tester', 'test'));
return authorise.should.not.have.been.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns value of authorise function<span class="duration">4ms</span></h2><pre><code>var authorise, director;
authorise = sinon.spy(function() {
  return 'AUTHORISE';
});
director = new Director(pretend.robot, authorise);
director.names = ['nobody'];
return director.isAllowed(pretend.response('tester', 'test')).should.equal('AUTHORISE');</code></pre></li></ul></li></ul></li><li class="suite"><h1>blacklist with authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>calls authorise function with username and res<span class="duration">4ms</span></h2><pre><code>var authorise, director, res;
authorise = sinon.spy(function() {
  return 'AUTHORISE';
});
director = new Director(pretend.robot, authorise, {
  type: 'blacklist'
});
res = pretend.response('tester', 'test');
director.isAllowed(res);
return authorise.should.have.calledWith('tester', res);</code></pre></li><li class="test pass fast"><h2>returns value of authorise function<span class="duration">4ms</span></h2><pre><code>var authorise, director;
authorise = sinon.spy(function() {
  return 'AUTHORISE';
});
director = new Director(pretend.robot, authorise, {
  type: 'blacklist'
});
return director.isAllowed(pretend.response('tester', 'test')).should.equal('AUTHORISE');</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">4ms</span></h2><pre><code>var authorise, director;
authorise = sinon.spy(function() {
  return 'AUTHORISE';
});
director = new Director(pretend.robot, authorise, {
  type: 'blacklist'
});
director.names = ['tester'];
return director.isAllowed(pretend.response('tester', 'test')).should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>does not call authorise function<span class="duration">4ms</span></h2><pre><code>var authorise, director;
authorise = sinon.spy(function() {
  return 'AUTHORISE';
});
director = new Director(pretend.robot, authorise, {
  type: 'blacklist'
});
director.names = ['tester'];
director.isAllowed(pretend.response('tester', 'test'));
return authorise.should.not.have.been.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns value of authorise function<span class="duration">4ms</span></h2><pre><code>var authorise, director;
authorise = sinon.spy(function() {
  return 'AUTHORISE';
});
director = new Director(pretend.robot, authorise, {
  type: 'blacklist'
});
director.names = ['nobody'];
return director.isAllowed(pretend.response('tester', 'test')).should.equal('AUTHORISE');</code></pre></li></ul></li></ul></li><li class="suite"><h1>room scope, blacklist room</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">4ms</span></h2><pre><code>var director;
director = new Director(pretend.robot, {
  type: 'blacklist',
  scope: 'room'
});
director.names = ['testing'];
return director.isAllowed(pretend.response('tester', 'test', 'testing')).should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>room scope, whitelist room</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">5ms</span></h2><pre><code>var director;
director = new Director(pretend.robot, {
  type: 'whitelist',
  scope: 'room'
});
director.names = ['testing'];
return director.isAllowed(pretend.response('tester', 'test', 'testing')).should.be[&quot;true&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.process</h1><ul><li class="test pass fast"><h2>calls .isAllowed to determine if user is allowed or denied<span class="duration">7ms</span></h2><pre><code>var director, res, scene;
director = new Director(pretend.robot);
scene = new Scene(pretend.robot);
res = pretend.response('tester', 'testing');
director.process(res);
return director.isAllowed.should.have.calledWith(res);</code></pre></li><li class="test pass fast"><h2>returns a promise<span class="duration">4ms</span></h2><pre><code>var director, scene;
director = new Director(pretend.robot);
scene = new Scene(pretend.robot);
return director.process(pretend.response('tester', 'testing')).then.should.be.a('function');</code></pre></li><li class="test pass fast"><h2>resolves to .isAllowed result<span class="duration">5ms</span></h2><pre><code>return co(function*() {
  var director, result, scene;
  director = new Director(pretend.robot);
  scene = new Scene(pretend.robot);
  result = (yield director.process(pretend.response('tester', 'testing')));
  return result.should.equal(director.isAllowed.returnValues.pop());
});</code></pre></li><li class="suite"><h1>with async auth function</h1><ul><li class="test pass medium"><h2>resolves with auth function result after finished<span class="duration">40ms</span></h2><pre><code>return co(function*() {
  var authorise, director, result;
  authorise = function() {
    return new Promise(function(resolve, reject) {
      var done;
      done = function() {
        return resolve('AUTHORISE');
      };
      return setTimeout(done, 30);
    });
  };
  director = new Director(pretend.robot, authorise);
  result = (yield director.process(pretend.response('tester', 'test')));
  return result.should.equal('AUTHORISE');
});</code></pre></li></ul></li><li class="suite"><h1>denied with denied reply value</h1><ul><li class="test pass fast"><h2>calls response method reply with reply value<span class="duration">8ms</span></h2><pre><code>return co(function*() {
  var director, res;
  director = new Director(pretend.robot, {
    deniedReply: 'DENIED'
  });
  res = pretend.response('tester', 'test');
  yield director.process(res);
  return res.reply.should.have.calledWith('DENIED');
});</code></pre></li></ul></li><li class="suite"><h1>denied without denied reply value</h1><ul><li class="test pass fast"><h2>does not call response reply method<span class="duration">10ms</span></h2><pre><code>return co(function*() {
  var director, res;
  director = new Director(pretend.robot);
  res = pretend.response('tester', 'test');
  yield director.process(res);
  return res.reply.should.not.have.called;
});</code></pre></li></ul></li><li class="suite"><h1>allowed user with denied reply value</h1><ul><li class="test pass fast"><h2>calls .isAllowed to determine if user is allowed or denied<span class="duration">7ms</span></h2><pre><code>return co(function*() {
  var director, res;
  director = new Director(pretend.robot);
  director.names = ['tester'];
  res = pretend.response('tester', 'test');
  yield director.process(res);
  return director.isAllowed.should.have.calledWith(res);
});</code></pre></li><li class="test pass fast"><h2>resolves to same value as .isAllowed<span class="duration">7ms</span></h2><pre><code>return co(function*() {
  var director, result;
  director = new Director(pretend.robot);
  director.names = ['tester'];
  result = (yield director.process(pretend.response('tester', 'test')));
  return result.should.equal(director.isAllowed.returnValues.pop());
});</code></pre></li><li class="test pass fast"><h2>does not send denied reply<span class="duration">6ms</span></h2><pre><code>return co(function*() {
  var director, res;
  director = new Director(pretend.robot);
  director.names = ['tester'];
  res = pretend.response('tester', 'test');
  yield director.process(res);
  return res.reply.should.not.have.called;
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.directMatch</h1><ul><li class="suite"><h1>allowed user sending message matching directed match</h1><ul><li class="test pass fast"><h2>calls .process to perform access checks and reply<span class="duration">5ms</span></h2><pre><code>return co(function*() {
  var director;
  director = new Director(pretend.robot);
  pretend.robot.hear(/let me in/, function() {});
  director.directMatch(/let me in/);
  director.names = ['tester'];
  yield pretend.user('tester').send('let me in');
  return director.process.should.have.calledOnce;
});</code></pre></li><li class="test pass fast"><h2>triggers match callback normally<span class="duration">5ms</span></h2><pre><code>return co(function*() {
  var callback, director;
  director = new Director(pretend.robot);
  callback = sinon.spy();
  pretend.robot.hear(/let me in/, callback);
  director.directMatch(/let me in/);
  director.names = ['tester'];
  yield pretend.user('tester').send('let me in');
  return callback.should.have.calledOnce;
});</code></pre></li></ul></li><li class="suite"><h1>denied user sending message matching directed match</h1><ul><li class="test pass fast"><h2>calls .process to perform access checks and reply<span class="duration">4ms</span></h2><pre><code>return co(function*() {
  var director;
  director = new Director(pretend.robot);
  pretend.robot.hear(/let me in/, function() {});
  director.directMatch(/let me in/);
  yield pretend.user('tester').send('let me in');
  return director.process.should.have.calledOnce;
});</code></pre></li><li class="test pass fast"><h2>prevents match callback from triggering<span class="duration">3ms</span></h2><pre><code>return co(function*() {
  var callback, director;
  director = new Director(pretend.robot);
  callback = sinon.spy();
  pretend.robot.hear(/let me in/, callback);
  director.directMatch(/let me in/);
  yield pretend.user('tester').send('let me in');
  return callback.should.not.have.called;
});</code></pre></li></ul></li><li class="suite"><h1>denied user sending unmatched message</h1><ul><li class="test pass fast"><h2>does not call .process because middleware did not match<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var director;
  director = new Director(pretend.robot);
  pretend.robot.hear(/let me in/, function() {});
  director.directMatch(/let me in/);
  yield pretend.user('tester').send('foo');
  return director.process.should.not.have.called;
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.directListener</h1><ul><li class="suite"><h1>with message matching directed listener id</h1><ul><li class="test pass fast"><h2>calls .process to perform access checks and reply<span class="duration">4ms</span></h2><pre><code>return co(function*() {
  var director;
  director = new Director(pretend.robot);
  pretend.robot.hear(/let me in/, {
    id: 'entry-test'
  }, function() {});
  director.directListener('entry-test');
  yield pretend.user('tester').send('let me in');
  return director.process.should.have.calledOnce;
});</code></pre></li><li class="test pass fast"><h2>triggers match callback when allowed<span class="duration">3ms</span></h2><pre><code>return co(function*() {
  var callback, director;
  director = new Director(pretend.robot);
  callback = sinon.spy();
  pretend.robot.hear(/let me in/, {
    id: 'entry-test'
  }, callback);
  director.directListener('entry-test');
  director.names = ['tester'];
  yield pretend.user('tester').send('let me in');
  return callback.should.have.calledOnce;
});</code></pre></li><li class="test pass fast"><h2>prevents match callback when denied<span class="duration">4ms</span></h2><pre><code>return co(function*() {
  var callback, director;
  director = new Director(pretend.robot);
  callback = sinon.spy();
  pretend.robot.hear(/let me in/, {
    id: 'entry-test'
  }, callback);
  director.directListener('entry-test');
  yield pretend.user('tester').send('let me in');
  return callback.should.not.have.called;
});</code></pre></li></ul></li><li class="suite"><h1>with unmatched message</h1><ul><li class="test pass fast"><h2>does not call .process because middleware did not match<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var director;
  director = new Director(pretend.robot);
  pretend.robot.hear(/let me in/, {
    id: 'entry-test'
  }, function() {});
  director.directListener('entry-test');
  yield pretend.user('tester').send('foo');
  return director.process.should.not.have.called;
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.directScene</h1><ul><li class="test pass fast"><h2>scene enter middleware calls director .process<span class="duration">5ms</span></h2><pre><code>var director, res, scene;
director = new Director(pretend.robot);
scene = new Scene(pretend.robot);
director.directScene(scene);
res = pretend.response('tester', 'test');
return scene.enter(res).then(function() {
  return director.process.should.have.calledWith(res);
});</code></pre></li><li class="suite"><h1>user allowed</h1><ul><li class="test pass fast"><h2>allowed scene enter, resolves with Dialogue<span class="duration">6ms</span></h2><pre><code>var director, scene;
director = new Director(pretend.robot);
scene = new Scene(pretend.robot);
director.directScene(scene);
director.names = ['tester'];
return scene.enter(pretend.response('tester', 'test')).then(function(result) {
  scene.processEnter.should.have.calledOnce;
  return result.should.be[&quot;instanceof&quot;](Dialogue);
});</code></pre></li></ul></li><li class="suite"><h1>user denied</h1><ul><li class="test pass fast"><h2>preempts scene enter, resolves undefined instead<span class="duration">4ms</span></h2><pre><code>var director, scene;
director = new Director(pretend.robot);
scene = new Scene(pretend.robot);
director.directScene(scene);
return scene.enter(pretend.response('tester', 'test')).then(function(result) {
  scene.processEnter.should.not.have.called;
  return should.not.exist(result);
});</code></pre></li></ul></li><li class="suite"><h1>with multiple scenes, only one directed</h1><ul><li class="test pass fast"><h2>calls process only once for the directed scene<span class="duration">13ms</span></h2><pre><code>return co(function*() {
  var director, resA, resB, sceneA, sceneB;
  director = new Director(pretend.robot);
  sceneA = new Scene(pretend.robot);
  sceneB = new Scene(pretend.robot);
  director.directScene(sceneA);
  resA = pretend.response('tester', 'let me in A');
  resB = pretend.response('tester', 'let me in A');
  yield sceneA.enter(resA);
  yield sceneB.enter(resB);
  director.process.should.have.calledOnce;
  return director.process.should.have.calledWithExactly(resA);
});</code></pre></li></ul></li><li class="suite"><h1>allowed user sends message matching scene listener</h1><ul><li class="test pass medium"><h2>allows scene to process entry<span class="duration">39ms</span></h2><pre><code>var callback, director, scene;
director = new Director(pretend.robot);
scene = new Scene(pretend.robot);
director.directScene(scene);
director.names = ['tester'];
callback = sinon.spy();
scene.hear(/let me in/, callback);
pretend.user('tester').send('let me in');
return setTimeout(function() {
  scene.processEnter.should.have.calledOnce;
  callback.should.have.calledOnce;
  return done();
}, 35);</code></pre></li></ul></li><li class="suite"><h1>denied user sends message matching scene listener</h1><ul><li class="test pass medium"><h2>prevents the scene from processing entry<span class="duration">40ms</span></h2><pre><code>var callback, director, scene;
director = new Director(pretend.robot);
scene = new Scene(pretend.robot);
director.directScene(scene);
callback = sinon.spy();
scene.hear(/let me in/, callback);
pretend.user('tester').send('let me in');
return setTimeout(function() {
  scene.processEnter.should.not.have.called;
  callback.should.not.have.called;
  return done();
}, 35);</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Transcript</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>with saving enabled (default)</h1><ul><li class="test pass fast"><h2>uses brain for record keeping<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: 0,
    event: 'test'
  }
]);</code></pre></li></ul></li><li class="suite"><h1>with saving disabled</h1><ul><li class="test pass fast"><h2>keeps records in a new empty array<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([]);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.recordEvent</h1><ul><li class="suite"><h1>emitted from Hubot/brain</h1><ul><li class="test pass fast"><h2>records event &quot;other&quot; data<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: 0,
    event: 'mockEvent',
    other: [
      {
        test: 'data'
      }
    ]
  }
]);</code></pre></li></ul></li><li class="suite"><h1>emitted from Playbook module</h1><ul><li class="suite"><h1>with default config</h1><ul><li class="test pass fast"><h2>records default instance attributes<span class="duration">7ms</span></h2><pre><code>this.transcript.on('record', (function(_this) {
  return function() {
    _this.transcript.records[0].should.containSubset({
      instance: {
        name: _this.module.name,
        key: _this.module.key,
        id: _this.module.id
      }
    });
    return done();
  };
})(this));
return this.module.emit('mockEvent', pretend.response('tester', 'test'));</code></pre></li><li class="test pass fast"><h2>records default response attributes<span class="duration">8ms</span></h2><pre><code>var res;
res = pretend.response('tester', 'test');
this.transcript.on('record', (function(_this) {
  return function() {
    _this.transcript.records[0].should.containSubset({
      response: {
        match: res.match
      }
    });
    return done();
  };
})(this));
return this.module.emit('mockEvent', res);</code></pre></li><li class="test pass fast"><h2>records default message attributes<span class="duration">9ms</span></h2><pre><code>var res;
res = pretend.response('tester', 'test', 'testing');
this.transcript.on('record', (function(_this) {
  return function() {
    _this.transcript.records[0].should.containSubset({
      message: {
        user: {
          id: res.message.user.id,
          name: res.message.user.name
        },
        room: res.message.room,
        text: res.message.text
      }
    });
    return done();
  };
})(this));
return this.module.emit('mockEvent', pretend.response('tester', 'test'));</code></pre></li></ul></li><li class="suite"><h1>with transcript key</h1><ul><li class="test pass fast"><h2>records event with key property<span class="duration">0ms</span></h2><pre><code>return this.transcript.records[0].should.have.property('key', 'test-key');</code></pre></li></ul></li><li class="suite"><h1>with custom instance atts</h1><ul><li class="test pass fast"><h2>records custom instance attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  instance: {
    name: this.module.name,
    config: {
      scope: this.module.config.scope
    }
  }
});</code></pre></li></ul></li><li class="suite"><h1>with custom response atts</h1><ul><li class="test pass fast"><h2>records custom response attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  response: {
    message: {
      room: 'testing'
    }
  }
});</code></pre></li></ul></li><li class="suite"><h1>with custom message atts</h1><ul><li class="test pass fast"><h2>records custom message attributes<span class="duration">1ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  message: {
    room: 'testing'
  }
});</code></pre></li></ul></li><li class="suite"><h1>on event without res argument</h1><ul><li class="test pass fast"><h2>records event without response or other attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: 0,
    event: 'mockEvent',
    instance: {
      name: this.module.name,
      key: this.module.key,
      id: this.module.id
    }
  }
]);</code></pre></li></ul></li><li class="suite"><h1>with invalid custom response atts</h1><ul><li class="test pass fast"><h2>records event without response attributes<span class="duration">1ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: 0,
    event: 'mockEvent',
    instance: {
      name: this.module.name,
      key: this.module.key,
      id: this.module.id
    }
  }
]);</code></pre></li><li class="test pass fast"><h2>does not throw<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.not[&quot;throw&quot;];</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>.recordAll</h1><ul><li class="suite"><h1>with default event set</h1><ul><li class="test pass fast"><h2>records default events only<span class="duration">1ms</span></h2><pre><code>return this.transcript.recordEvent.args.should.eql([['match'], ['mismatch'], ['catch'], ['send']]);</code></pre></li></ul></li><li class="suite"><h1>with custom event set</h1><ul><li class="test pass fast"><h2>records custom events only<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.args.should.eql([['foo'], ['bar']]);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.recordDialogue</h1><ul><li class="suite"><h1>with default event set</h1><ul><li class="test pass fast"><h2>attached listener for default events from dialogue and path<span class="duration">1ms</span></h2><pre><code>var expectedEvents;
expectedEvents = this.transcript.config.events;
expectedEvents.push('path');
return _.keys(pretend.robot._events).should.have.members(expectedEvents);</code></pre></li><li class="test pass fast"><h2>calls the listener when event emited from dialogue path<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.have.calledWith('match', this.dialogue.path);</code></pre></li></ul></li><li class="suite"><h1>with custom event set</h1><ul><li class="test pass fast"><h2>attached listener for default events from dialogue and path<span class="duration">0ms</span></h2><pre><code>return _.keys(pretend.robot._events).should.have.members(['match', 'mismatch', 'end', 'path']);</code></pre></li><li class="test pass fast"><h2>calls the listener when event emited from dialogue<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.have.calledWith('end', this.dialogue);</code></pre></li><li class="test pass fast"><h2>calls the listener when event emited from path<span class="duration">1ms</span></h2><pre><code>return this.transcript.recordEvent.should.have.calledWith('match', this.dialogue.path);</code></pre></li><li class="test pass fast"><h2>does not call with any unconfigured events<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.not.have.calledWith('send', this.dialogue);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.recordScene</h1><ul><li class="test pass fast"><h2>records events emitted by scene, its dialogues and paths<span class="duration">7ms</span></h2><pre><code>return co(function*() {
  var dialogue, records, res, scene, transcript;
  res = pretend.response('tester', 'test');
  removeListeners(pretend.robot);
  transcript = new Transcript(pretend.robot, {
    save: false,
    events: ['enter', 'match', 'send']
  });
  scene = new Scene(pretend.robot);
  transcript.recordScene(scene);
  dialogue = (yield scene.enter(res));
  dialogue.addBranch(/test/, 'response');
  yield dialogue.receive(res);
  records = transcript.recordEvent.args.map(function(record) {
    return _.take(record, 2);
  });
  return records.should.eql([['enter', scene], ['match', dialogue.path], ['send', dialogue]]);
});</code></pre></li></ul></li><li class="suite"><h1>.recordDirector</h1><ul><li class="test pass fast"><h2>attached listeners for director events<span class="duration">0ms</span></h2><pre><code>var director, transcript;
removeListeners(pretend.robot);
transcript = new Transcript(pretend.robot, {
  save: false
});
director = new Director(pretend.robot, {
  type: 'blacklist'
});
transcript.recordDirector(director);
return _.keys(pretend.robot._events).should.eql(['allow', 'deny']);</code></pre></li><li class="test pass fast"><h2>records events emitted by director<span class="duration">7ms</span></h2><pre><code>return co(function*() {
  var director, res, transcript;
  removeListeners(pretend.robot);
  transcript = new Transcript(pretend.robot, {
    save: false
  });
  director = new Director(pretend.robot, {
    type: 'blacklist'
  });
  res = pretend.response('tester', 'test');
  transcript.recordDirector(director);
  director.names = ['tester'];
  yield director.process(res);
  director.config.type = 'whitelist';
  yield director.process(res);
  return transcript.recordEvent.args.should.eql([['deny', director, res], ['allow', director, res]]);
});</code></pre></li></ul></li><li class="suite"><h1>.findRecords</h1><ul><li class="suite"><h1>with record subset matcher</h1><ul><li class="test pass fast"><h2>returns records matching given attributes<span class="duration">1ms</span></h2><pre><code>return this.transcript.findRecords({
  message: {
    user: {
      name: 'jon'
    }
  }
}).should.eql([
  {
    time: 0,
    event: 'match',
    instance: {
      key: 'time'
    },
    message: {
      user: {
        name: 'jon'
      },
      text: 'now'
    }
  }, {
    time: 0,
    event: 'match',
    instance: {
      key: 'direction'
    },
    message: {
      user: {
        name: 'jon'
      },
      text: 'left'
    }
  }
]);</code></pre></li></ul></li><li class="suite"><h1>with record subset matcher</h1><ul><li class="test pass fast"><h2>returns only the values at given path<span class="duration">1ms</span></h2><pre><code>return this.transcript.findRecords({
  message: {
    user: {
      name: 'jon'
    }
  }
}, 'message.text').should.eql(['now', 'left']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.findKeyMatches</h1><ul><li class="suite"><h1>with an instance key and capture group</h1><ul><li class="test pass fast"><h2>returns the answers matching the key<span class="duration">0ms</span></h2><pre><code>return this.transcript.findKeyMatches('pick-a-color', 0).should.eql(['blue', 'orange', 'red']);</code></pre></li></ul></li><li class="suite"><h1>with an instance key, user ID and capture group</h1><ul><li class="test pass fast"><h2>returns the answers matching the key for the user<span class="duration">1ms</span></h2><pre><code>return this.transcript.findKeyMatches('pick-a-color', '111', 0).should.eql(['blue', 'orange']);</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Improv</h1><ul><li class="suite"><h1>singleton</h1><ul><li class="test pass fast"><h2>sequential use returns existing instance<span class="duration">1ms</span></h2><pre><code>var improvA, improvB;
improvA = improv.use(pretend.robot);
improvB = improv.use(pretend.robot);
return improvA.should.eql(improvB);</code></pre></li><li class="test pass fast"><h2>instance persists after test robot shutdown<span class="duration">0ms</span></h2><pre><code>return improv.instance.should.exist;</code></pre></li><li class="test pass fast"><h2>use after clear returns new instance<span class="duration">0ms</span></h2><pre><code>var improvA, improvB;
improvA = improv.use(pretend.robot);
improv.reset();
improvB = improv.use(pretend.robot);
return improvA.should.not.eql(improvB);</code></pre></li><li class="test pass fast"><h2>overwrite robot when reused<span class="duration">0ms</span></h2><pre><code>return improv.use(pretend.robot).robot.should.eql(pretend.robot);</code></pre></li><li class="test pass fast"><h2>configuration merges existing config<span class="duration">1ms</span></h2><pre><code>improv.configure({
  foo: 'bar'
});
improv.configure({
  baz: 'qux'
});
return improv.config.should.include({
  foo: 'bar',
  baz: 'qux'
});</code></pre></li></ul></li><li class="suite"><h1>instance</h1><ul><li class="suite"><h1>.use</h1><ul><li class="test pass fast"><h2>attaches response middleware to robot<span class="duration">0ms</span></h2><pre><code>return pretend.robot.responseMiddleware.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>.extend</h1><ul><li class="test pass fast"><h2>stores a function in extensions array<span class="duration">0ms</span></h2><pre><code>var func;
func = sinon.spy();
improv.extend(func);
return improv.extensions.should.eql([func]);</code></pre></li></ul></li><li class="suite"><h1>.remember</h1><ul><li class="test pass fast"><h2>stores data at key in context<span class="duration">1ms</span></h2><pre><code>improv.context.site = {
  name: 'Hub'
};
improv.remember('site', {
  lang: 'en'
});
return improv.context.should.eql({
  site: {
    lang: 'en'
  }
});</code></pre></li><li class="test pass fast"><h2>stores data at path in context<span class="duration">0ms</span></h2><pre><code>improv.context.site = {
  name: 'Hub'
};
improv.remember('site.lang', 'en');
return improv.context.should.eql({
  site: {
    name: 'Hub',
    lang: 'en'
  }
});</code></pre></li></ul></li><li class="suite"><h1>.forget</h1><ul><li class="test pass fast"><h2>removes data at path in context<span class="duration">0ms</span></h2><pre><code>improv.context.site = {
  name: 'Hub',
  lang: 'en'
};
improv.remember('site.lang', 'en');
return improv.context.should.eql({
  site: {
    name: 'Hub',
    lang: 'en'
  }
});</code></pre></li></ul></li><li class="suite"><h1>.mergeData</h1><ul><li class="suite"><h1>with data passed as option</h1><ul><li class="test pass fast"><h2>merges data with user data<span class="duration">0ms</span></h2><pre><code>improv.remember('site', {
  name: 'Hub'
});
return improv.mergeData(pretend.lastListen().message.user).should.eql({
  user: pretend.lastListen().message.user,
  site: {
    name: 'Hub'
  }
});</code></pre></li></ul></li><li class="suite"><h1>with data loaded from brain</h1><ul><li class="test pass fast"><h2>merges data with user data<span class="duration">0ms</span></h2><pre><code>improv.configure({
  save: true
});
pretend.robot.brain.set('improv', {
  site: {
    owner: 'Hubot'
  }
});
return improv.remember('site.name', 'Hub').mergeData(pretend.lastListen().message.user).should.eql({
  user: pretend.lastListen().message.user,
  site: {
    owner: 'Hubot',
    name: 'Hub'
  }
});</code></pre></li></ul></li><li class="suite"><h1>with extension functions added</h1><ul><li class="test pass fast"><h2>merges data with results of functions<span class="duration">1ms</span></h2><pre><code>return improv.extend(function() {
  return {
    custom1: 'foo'
  };
}).extend(function() {
  return {
    custom2: 'bar'
  };
}).mergeData(pretend.lastListen().message.user).should.eql({
  user: pretend.lastListen().message.user,
  custom1: 'foo',
  custom2: 'bar'
});</code></pre></li><li class="test pass fast"><h2>deep merges existing data with extensions<span class="duration">1ms</span></h2><pre><code>return improv.extend(function() {
  return {
    user: {
      type: 'human'
    }
  };
}).mergeData(pretend.lastListen().message.user).should.eql({
  user: _.assignIn(pretend.lastListen().message.user, {
    type: 'human'
  })
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.parse</h1><ul><li class="suite"><h1>with context object</h1><ul><li class="test pass fast"><h2>populates message template with data at path<span class="duration">0ms</span></h2><pre><code>return improv.parse(['welcome to ${ this.site }'], {
  site: 'The Hub'
}).should.eql(['welcome to The Hub']);</code></pre></li></ul></li><li class="suite"><h1>without context</h1><ul><li class="test pass fast"><h2>uses fallback value<span class="duration">1ms</span></h2><pre><code>var context, string;
context = {};
string = 'hey ${ this.user.name }, pay ${ this.product.price }';
return improv.parse([string], context).should.eql(['hey unknown, pay unknown']);</code></pre></li></ul></li><li class="suite"><h1>with partial context</h1><ul><li class="test pass fast"><h2>uses fallback for unknowns<span class="duration">1ms</span></h2><pre><code>var context, string;
context = {
  product: {
    price: '$55'
  }
};
string = 'hey ${ this.user.name }, pay ${ this.product.price }';
return improv.parse([string], context).should.eql(['hey unknown, pay $55']);</code></pre></li><li class="test pass fast"><h2>replaces entire string as configured<span class="duration">0ms</span></h2><pre><code>var context, string;
improv.configure({
  replacement: '¯\\_(ツ)_/¯'
});
context = {
  product: {
    price: '$55'
  }
};
string = 'hey ${ this.user.name }, pay ${ this.product.price }';
return improv.parse([string], context).should.eql(['¯\\_(ツ)_/¯']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.middleware</h1><ul><li class="suite"><h1>with series of hubot sends</h1><ul><li class="test pass fast"><h2>rendered messages with context<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  yield pretend.lastListen().send('hello you');
  yield pretend.lastListen().send('hi ${ this.user.name }');
  return pretend.messages.should.eql([['testing', 'tester', 'test'], ['testing', 'hubot', 'hello you'], ['testing', 'hubot', 'hi tester']]);
});</code></pre></li></ul></li><li class="suite"><h1>with multiple strings</h1><ul><li class="test pass fast"><h2>renders each message with context<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  yield pretend.lastListen().send('testing', 'hi ${ this.user.name }', 'welcome to ${ this.site.name }');
  return pretend.messages.should.eql([['testing', 'tester', 'test'], ['testing', 'hubot', 'testing'], ['testing', 'hubot', 'hi tester'], ['testing', 'hubot', 'welcome to The Hub']]);
});</code></pre></li></ul></li></ul></li></ul></li></ul></li><li class="suite"><h1>Playbook - singleton</h1><ul><li class="test pass fast"><h2>require returns instance<span class="duration">1ms</span></h2><pre><code>return playbook.constructor.name.should.equal('Playbook');</code></pre></li><li class="test pass fast"><h2>instance contains modules<span class="duration">0ms</span></h2><pre><code>return playbook.should.containSubset({
  Dialogue: require('../../lib/modules/dialogue'),
  Scene: require('../../lib/modules/scene'),
  Director: require('../../lib/modules/director'),
  Transcript: require('../../lib/modules/transcript'),
  Outline: require('../../lib/modules/outline'),
  improv: require('../../lib/modules/improv')
});</code></pre></li><li class="test pass fast"><h2>re-require returns the same instance<span class="duration">0ms</span></h2><pre><code>playbook.foo = 'bar';
playbook = require('../../lib');
return playbook.foo.should.equal('bar');</code></pre></li><li class="suite"><h1>.reset</h1><ul><li class="test pass fast"><h2>returns new instance<span class="duration">1ms</span></h2><pre><code>playbook.foo = 'bar';
playbook = playbook.reset();
return should.not.exist(playbook.foo);</code></pre></li></ul></li><li class="suite"><h1>.use</h1><ul><li class="test pass fast"><h2>attaches robot<span class="duration">15ms</span></h2><pre><code>pretend.start();
return playbook.use(pretend.robot).should.have.property('robot', pretend.robot);</code></pre></li><li class="test pass fast"><h2>inherits robot log<span class="duration">12ms</span></h2><pre><code>pretend.start();
return playbook.use(pretend.robot).should.have.property('log', pretend.log);</code></pre></li></ul></li></ul></li><li class="suite"><h1>Playbook</h1><ul><li class="suite"><h1>dialogue</h1><ul><li class="test pass fast"><h2>creates Dialogue instance<span class="duration">5ms</span></h2><pre><code>return playbook.dialogue(pretend.response('tester', 'test')).should.be[&quot;instanceof&quot;](playbook.Dialogue);</code></pre></li><li class="test pass fast"><h2>stores it in the dialogues array<span class="duration">4ms</span></h2><pre><code>var dialogue;
dialogue = playbook.dialogue(pretend.response('tester', 'test'));
return playbook.dialogues[0].should.eql(dialogue);</code></pre></li></ul></li><li class="suite"><h1>scene</h1><ul><li class="test pass fast"><h2>makes a Scene :P<span class="duration">1ms</span></h2><pre><code>return playbook.scene().should.be[&quot;instanceof&quot;](playbook.Scene);</code></pre></li><li class="test pass fast"><h2>stores it in the scenes array<span class="duration">0ms</span></h2><pre><code>var scene;
scene = playbook.scene();
return playbook.scenes[0].should.eql(scene);</code></pre></li></ul></li><li class="suite"><h1>.sceneEnter</h1><ul><li class="suite"><h1>without type or args (other than response)</h1><ul><li class="test pass fast"><h2>makes scene with default user type<span class="duration">9ms</span></h2><pre><code>return playbook.sceneEnter(pretend.response('tester', 'test', 'testing')).then(function() {
  return playbook.scenes[0].should.be[&quot;instanceof&quot;](playbook.Scene);
});</code></pre></li><li class="test pass fast"><h2>resolves with a dialogue<span class="duration">5ms</span></h2><pre><code>return playbook.sceneEnter(pretend.response('tester', 'test')).then(function(dialogue) {
  return dialogue.should.be[&quot;instanceof&quot;](playbook.Dialogue);
});</code></pre></li><li class="test pass fast"><h2>enters scene, engaging user (stores against id)<span class="duration">4ms</span></h2><pre><code>return playbook.sceneEnter(pretend.response('tester', 'test')).then(function(dialogue) {
  return playbook.scenes[0].engaged[pretend.users.tester.id].should.eql(dialogue);
});</code></pre></li></ul></li><li class="suite"><h1>with type and options args</h1><ul><li class="test pass fast"><h2>used the given room type<span class="duration">5ms</span></h2><pre><code>var res;
res = pretend.response('tester', 'test', 'testing');
return playbook.sceneEnter(res, {
  scope: 'room',
  sendReplies: false
}).then(function() {
  return playbook.scenes[0].config.scope.should.equal('room');
});</code></pre></li><li class="test pass fast"><h2>passed the scene options to dialogue<span class="duration">5ms</span></h2><pre><code>var res;
res = pretend.response('tester', 'test', 'testing');
return playbook.sceneEnter(res, {
  scope: 'room',
  sendReplies: false
}).then(function(dialogue) {
  return dialogue.config.sendReplies.should.be[&quot;false&quot;];
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.sceneListen</h1><ul><li class="suite"><h1>with scene args</h1><ul><li class="test pass fast"><h2>creates Scene instance<span class="duration">0ms</span></h2><pre><code>return this.scene.should.be[&quot;instanceof&quot;](playbook.Scene);</code></pre></li><li class="test pass fast"><h2>passed args to the scene<span class="duration">0ms</span></h2><pre><code>return playbook.scene.should.have.calledWith({
  sendReplies: false,
  scope: 'room'
});</code></pre></li><li class="test pass fast"><h2>calls .listen on the scene with type, regex and callback<span class="duration">0ms</span></h2><pre><code>return this.listen.should.have.calledWith('hear', /test/, sinon.match.func);</code></pre></li></ul></li><li class="suite"><h1>without scene args</h1><ul><li class="test pass fast"><h2>creates Scene instance<span class="duration">0ms</span></h2><pre><code>return this.scene.should.be[&quot;instanceof&quot;](playbook.Scene);</code></pre></li><li class="test pass fast"><h2>passed no args to the scene<span class="duration">0ms</span></h2><pre><code>return playbook.scene.getCall(0).should.have.calledWith();</code></pre></li><li class="test pass fast"><h2>calls .listen on the scene with type, regex and callback<span class="duration">0ms</span></h2><pre><code>return this.listen.should.have.calledWith('hear', /test/, sinon.match.func);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.sceneHear</h1><ul><li class="test pass fast"><h2>calls .sceneListen with hear type and any other args<span class="duration">0ms</span></h2><pre><code>var args, ref;
args = [
  'hear', /test/, {
    scope: 'room'
  }, sinon.match.func
];
return (ref = playbook.sceneListen.lastCall.should.have).calledWith.apply(ref, args);</code></pre></li></ul></li><li class="suite"><h1>.sceneRespond</h1><ul><li class="test pass fast"><h2>calls .sceneListen with respond type and any other args<span class="duration">0ms</span></h2><pre><code>var args, ref;
args = [
  'respond', /test/, {
    scope: 'room'
  }, sinon.match.func
];
return (ref = playbook.sceneListen.getCall(0).should.have).calledWith.apply(ref, args);</code></pre></li></ul></li><li class="suite"><h1>.director</h1><ul><li class="test pass fast"><h2>creates and returns director<span class="duration">0ms</span></h2><pre><code>return this.director.should.be[&quot;instanceof&quot;](playbook.Director);</code></pre></li><li class="test pass fast"><h2>stores it in the directors array<span class="duration">0ms</span></h2><pre><code>return playbook.directors[0].should.eql(this.director);</code></pre></li></ul></li><li class="suite"><h1>.transcript</h1><ul><li class="test pass fast"><h2>creates and returns transcript<span class="duration">0ms</span></h2><pre><code>return this.transcript.should.be[&quot;instanceof&quot;](playbook.Transcript);</code></pre></li><li class="test pass fast"><h2>stores it in the transcripts array<span class="duration">0ms</span></h2><pre><code>return playbook.transcripts[0].should.eql(this.transcript);</code></pre></li></ul></li><li class="suite"><h1>.transcribe</h1><ul><li class="test pass fast"><h2>creates transcripts for each module<span class="duration">0ms</span></h2><pre><code>return playbook.transcript.should.have.calledThrice;</code></pre></li><li class="test pass fast"><h2>records events from given instances in brain<span class="duration">0ms</span></h2><pre><code>return pretend.robot.brain.get('transcripts').should.eql([
  {
    time: 0,
    event: 'deny',
    instance: {
      name: 'director'
    }
  }, {
    time: 0,
    event: 'enter',
    instance: {
      name: 'scene'
    }
  }, {
    time: 0,
    event: 'send',
    instance: {
      name: 'dialogue'
    },
    strings: ['test']
  }
]);</code></pre></li></ul></li><li class="suite"><h1>.improvise</h1><ul><li class="test pass fast"><h2>returns the improv singleton<span class="duration">0ms</span></h2><pre><code>return playbook.improvise().should.eql(playbook.improv);</code></pre></li><li class="suite"><h1>with non-improv playbook</h1><ul><li class="test pass fast"><h2>does not parse messages<span class="duration">5ms</span></h2><pre><code>return co(function*() {
  var res;
  res = pretend.response('tester', 'test');
  yield res.send('hello ${this.user.name}');
  return pretend.messages.pop().should.eql(['hubot', 'hello ${this.user.name}']);
});</code></pre></li><li class="test pass fast"><h2>parses after called<span class="duration">8ms</span></h2><pre><code>return co(function*() {
  var res;
  res = pretend.response('tester', 'test');
  playbook.improvise();
  yield res.send('hello ${ this.user.name }');
  return pretend.messages.pop().should.eql(['hubot', 'hello tester']);
});</code></pre></li></ul></li><li class="suite"><h1>using custom data transforms</h1><ul><li class="test pass fast"><h2>parses messages with extended context<span class="duration">6ms</span></h2><pre><code>return co(function*() {
  var res;
  res = pretend.response('tester', 'test');
  playbook.improv.extend(function(data) {
    data.user.name = data.user.name.toUpperCase();
    return data;
  });
  yield res.send('hello ${ this.user.name }');
  return pretend.messages.pop().should.eql(['hubot', 'hello TESTER']);
});</code></pre></li></ul></li><li class="suite"><h1>extended using transcript reocrds</h1><ul><li class="test pass fast"><h2>merge the recorded answers with attribute tags<span class="duration">12ms</span></h2><pre><code>return co(function*() {
  var dialogue, transcript;
  dialogue = (yield playbook.sceneEnter(pretend.response('tester', 'test')));
  transcript = playbook.transcribe(dialogue, {
    events: ['match']
  });
  playbook.improv.extend(function(data) {
    var userColors, userId;
    userId = data.user.id;
    userColors = transcript.findKeyMatches('fav-color', data.user.id, 0);
    if (userColors.length) {
      return {
        user: {
          favColor: userColors.pop()
        }
      };
    }
  });
  yield dialogue.addPath('what is your favourite colour?', [[/.*/, 'nice! mine is ${ this.user.favColor } too!']], 'fav-color');
  yield pretend.user('tester').send('orange');
  return pretend.messages.should.eql([['hubot', 'what is your favourite colour?'], ['tester', 'orange'], ['hubot', 'nice! mine is orange too!']]);
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.shutdown</h1><ul><li class="test pass fast"><h2>calls .exitAll on scenes<span class="duration">1ms</span></h2><pre><code>var exit, scene;
scene = playbook.scene();
exit = sinon.spy(scene, 'exitAll');
playbook.shutdown();
return exit.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls .end on dialogues<span class="duration">4ms</span></h2><pre><code>var dialogue, end;
dialogue = playbook.dialogue(pretend.response('tester', 'test'));
end = sinon.spy(dialogue, 'end');
playbook.shutdown();
return end.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>.reset</h1><ul><li class="test pass fast"><h2>shuts down<span class="duration">1ms</span></h2><pre><code>sinon.spy(playbook, 'shutdown');
playbook.reset();
return playbook.shutdown.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>returns re-initialised instance<span class="duration">0ms</span></h2><pre><code>playbook = playbook.reset();
return should.not.exist(playbook.robot);</code></pre></li></ul></li></ul></li><ul>
    </div>
    <script>
        var tests = document.getElementsByClassName('test');

        for (var i = 0; i < tests.length; i++) {
            var elem = tests[i];

            if (elem.className.includes('pass')) {
                var head = elem.children[0];

                head.onclick = function () {
                    var code = this.parentElement.children[1];
                    var display = code.style.display;

                    if (display && display === 'block') {
                        code.style.display = 'none';
                    } else {
                        code.style.display = 'block';
                    }
                };
            }
        }
    </script>
</body>
</html>