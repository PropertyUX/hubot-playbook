<html>
<head>
    <title>Mocha</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
    @charset "utf-8";

body {
  margin:0;
}

#mocha {
  font: 20px/1.5 "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: 60px 50px;
}

#mocha ul,
#mocha li {
  margin: 0;
  padding: 0;
}

#mocha ul {
  list-style: none;
}

#mocha h1,
#mocha h2 {
  margin: 0;
}

#mocha h1 {
  margin-top: 15px;
  font-size: 1em;
  font-weight: 200;
}

#mocha h1 a {
  text-decoration: none;
  color: inherit;
}

#mocha h1 a:hover {
  text-decoration: underline;
}

#mocha .suite .suite h1 {
  margin-top: 0;
  font-size: .8em;
}

#mocha .hidden {
  display: none;
}

#mocha h2 {
  font-size: 12px;
  font-weight: normal;
  cursor: pointer;
}

#mocha .suite {
  margin-left: 15px;
}

#mocha .test {
  margin-left: 15px;
  overflow: hidden;
}

#mocha .test.pending:hover h2::after {
  content: '(pending)';
  font-family: arial, sans-serif;
}

#mocha .test.pass.medium .duration {
  background: #c09853;
}

#mocha .test.pass.slow .duration {
  background: #b94a48;
}

#mocha .test.pass::before {
  content: '✓';
  font-size: 12px;
  display: block;
  float: left;
  margin-right: 5px;
  color: #00d6b2;
}

#mocha .test.pass .duration {
  font-size: 9px;
  margin-left: 5px;
  padding: 2px 5px;
  color: #fff;
  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  -ms-border-radius: 5px;
  -o-border-radius: 5px;
  border-radius: 5px;
}

#mocha .test.pass.fast .duration {
  display: none;
}

#mocha .test.pending {
  color: #0b97c4;
}

#mocha .test.pending::before {
  content: '◦';
  color: #0b97c4;
}

#mocha .test.fail {
  color: #c00;
}

#mocha .test.fail pre {
  color: black;
}

#mocha .test.fail::before {
  content: '✖';
  font-size: 12px;
  display: block;
  float: left;
  margin-right: 5px;
  color: #c00;
}

#mocha .test pre.error {
  color: #c00;
  max-height: 300px;
  overflow: auto;
}

#mocha .test .html-error {
  overflow: auto;
  color: black;
  line-height: 1.5;
  display: block;
  float: left;
  clear: left;
  font: 12px/1.5 monaco, monospace;
  margin: 5px;
  padding: 15px;
  border: 1px solid #eee;
  max-width: 85%; /*(1)*/
  max-width: -webkit-calc(100% - 42px);
  max-width: -moz-calc(100% - 42px);
  max-width: calc(100% - 42px); /*(2)*/
  max-height: 300px;
  word-wrap: break-word;
  border-bottom-color: #ddd;
  -webkit-box-shadow: 0 1px 3px #eee;
  -moz-box-shadow: 0 1px 3px #eee;
  box-shadow: 0 1px 3px #eee;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}

#mocha .test .html-error pre.error {
  border: none;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-box-shadow: 0;
  -moz-box-shadow: 0;
  box-shadow: 0;
  padding: 0;
  margin: 0;
  margin-top: 18px;
  max-height: none;
}

/**
 * (1): approximate for browsers not supporting calc
 * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)
 *      ^^ seriously
 */
#mocha .test pre {
  display: block;
  float: left;
  clear: left;
  font: 12px/1.5 monaco, monospace;
  margin: 5px;
  padding: 15px;
  border: 1px solid #eee;
  max-width: 85%; /*(1)*/
  max-width: -webkit-calc(100% - 42px);
  max-width: -moz-calc(100% - 42px);
  max-width: calc(100% - 42px); /*(2)*/
  word-wrap: break-word;
  border-bottom-color: #ddd;
  -webkit-box-shadow: 0 1px 3px #eee;
  -moz-box-shadow: 0 1px 3px #eee;
  box-shadow: 0 1px 3px #eee;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}

#mocha .test h2 {
  position: relative;
}

#mocha .test a.replay {
  position: absolute;
  top: 3px;
  right: 0;
  text-decoration: none;
  vertical-align: middle;
  display: block;
  width: 15px;
  height: 15px;
  line-height: 15px;
  text-align: center;
  background: #eee;
  font-size: 15px;
  -webkit-border-radius: 15px;
  -moz-border-radius: 15px;
  border-radius: 15px;
  -webkit-transition:opacity 200ms;
  -moz-transition:opacity 200ms;
  -o-transition:opacity 200ms;
  transition: opacity 200ms;
  opacity: 0.3;
  color: #888;
}

#mocha .test:hover a.replay {
  opacity: 1;
}

#mocha-report.pass .test.fail {
  display: none;
}

#mocha-report.fail .test.pass {
  display: none;
}

#mocha-report.pending .test.pass,
#mocha-report.pending .test.fail {
  display: none;
}
#mocha-report.pending .test.pass.pending {
  display: block;
}

#mocha-error {
  color: #c00;
  font-size: 1.5em;
  font-weight: 100;
  letter-spacing: 1px;
}

#mocha-stats {
  position: fixed;
  top: 15px;
  right: 10px;
  font-size: 12px;
  margin: 0;
  color: #888;
  z-index: 1;
}

#mocha-stats .progress {
  float: right;
  padding-top: 0;

  /**
   * Set safe initial values, so mochas .progress does not inherit these
   * properties from Bootstrap .progress (which causes .progress height to
   * equal line height set in Bootstrap).
   */
  height: auto;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  background-color: initial;
}

#mocha-stats em {
  color: black;
}

#mocha-stats a {
  text-decoration: none;
  color: inherit;
}

#mocha-stats a:hover {
  border-bottom: 1px solid #eee;
}

#mocha-stats li {
  display: inline-block;
  margin: 0 5px;
  list-style: none;
  padding-top: 11px;
}

#mocha-stats canvas {
  width: 40px;
  height: 40px;
}

#mocha code .comment { color: #ddd; }
#mocha code .init { color: #2f6fad; }
#mocha code .string { color: #5890ad; }
#mocha code .keyword { color: #8a6343; }
#mocha code .number { color: #2f6fad; }

@media screen and (max-device-width: 480px) {
  #mocha {
    margin: 60px 0px;
  }

  #mocha #stats {
    position: absolute;
  }
}

    #mocha .test.pass pre {
        display: none;
    }
    #mocha .test:hover h2:after {
        color: #888888;
        content: "(view source)";
        font-family: arial;
        font-size: 12px;
        position: relative;
        right: -10px;
        top: 0;
    }
    </style>
</head>

<body>
    <div id="mocha">
        <ul id="stats">
            <li class="passes">passes: <em>324</em></li>
            <li class="failures">failures: <em>0</em></li>
            <li class="duration">duration: <em>7s</em></li>
        </ul>
        <ul id="report"><li class="suite"><h1>Diagnostics</h1><ul><li class="suite"><h1>script sets up a &quot;respond&quot; and a &quot;hear&quot; listener</h1><ul><li class="test pass fast"><h2>robot.respond called once to set up listener<span class="duration">0ms</span></h2><pre><code>return pretend.robot.respond.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>registers a respond listener with RegExp and function<span class="duration">1ms</span></h2><pre><code>return pretend.robot.respond.getCall(0).should.have.calledWithMatch(sinon.match.regexp, sinon.match.func);</code></pre></li><li class="test pass fast"><h2>robot.hear called twice (by respond then directly)<span class="duration">0ms</span></h2><pre><code>return pretend.robot.hear.should.have.calledTwice;</code></pre></li><li class="test pass fast"><h2>registers a hear listener with RegExp and callback (no options)<span class="duration">1ms</span></h2><pre><code>return pretend.robot.hear.getCall(1).should.have.calledWithMatch(sinon.match.regexp, sinon.match.func);</code></pre></li><li class="test pass fast"><h2>robbot has two listeners<span class="duration">0ms</span></h2><pre><code>return pretend.robot.listeners.length.should.equal(2);</code></pre></li></ul></li><li class="suite"><h1>bot responds to a matching message</h1><ul><li class="test pass fast"><h2>bot creates response<span class="duration">1ms</span></h2><pre><code>return pretend.responses.listen.length.should.equal(1);</code></pre></li><li class="test pass fast"><h2>bot calls listener callback with response<span class="duration">0ms</span></h2><pre><code>return this.cb.should.have.calledWithMatch(sinon.match(matchRes));</code></pre></li></ul></li><li class="suite"><h1>bot hears a matching message</h1><ul><li class="test pass fast"><h2>bot creates response<span class="duration">0ms</span></h2><pre><code>return pretend.responses.listen.length.should.equal(1);</code></pre></li><li class="test pass fast"><h2>bot calls listener callback with response<span class="duration">0ms</span></h2><pre><code>return this.cb.should.have.calledWithMatch(sinon.match(matchRes));</code></pre></li></ul></li><li class="suite"><h1>bot responds to its alias</h1><ul><li class="test pass fast"><h2>calls callback with response<span class="duration">34ms</span></h2><pre><code>return co(function*() {
  var cb;
  pretend.start({
    alias: 'buddy'
  });
  cb = sinon.spy(pretend.robot.listeners[0], 'callback');
  yield pretend.user('jimbo').send('buddy which version');
  return cb.should.have.calledWithMatch(sinon.match(matchRes));
});</code></pre></li></ul></li><li class="suite"><h1>user asks for version number</h1><ul><li class="test pass fast"><h2>replies to tester with a version number<span class="duration">11ms</span></h2><pre><code>return co(function*() {
  yield pretend.user('jimbo').send('hubot which version are you on?');
  return pretend.messages[1][1].should.match(/jimbo .*\d+.\d+.\d+/);
});</code></pre></li></ul></li><li class="suite"><h1>user asks different ways if Hubot is listening</h1><ul><li class="test pass fast"><h2>replies to each confirming Hubot listening<span class="duration">9ms</span></h2><pre><code>return co(function*() {
  yield pretend.user('jimbo').send('Are any Hubots listening?');
  yield pretend.user('jimbo').send('Is there a bot listening?');
  return pretend.messages[1].should.eql(pretend.messages[3]);
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>Base</h1><ul><li class="suite"><h1>.constructor</h1><ul><li class="suite"><h1>with name, robot and options and key</h1><ul><li class="test pass fast"><h2>stores the robot<span class="duration">0ms</span></h2><pre><code>return this.base.robot.should.eql(pretend.robot);</code></pre></li><li class="test pass fast"><h2>inherits the robot logger<span class="duration">0ms</span></h2><pre><code>return this.base.log.should.eql(pretend.robot.logger);</code></pre></li><li class="test pass fast"><h2>calls configure with options<span class="duration">1ms</span></h2><pre><code>return this.base.configure.should.have.calledWith({
  test: 'testing'
});</code></pre></li><li class="test pass fast"><h2>sets key attribute<span class="duration">0ms</span></h2><pre><code>return this.base.key.should.equal('basey-mcbase');</code></pre></li></ul></li><li class="suite"><h1>without robot</h1><ul><li class="test pass fast"><h2>runs error handler<span class="duration">0ms</span></h2><pre><code>return Base.prototype.error.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>without name</h1><ul><li class="test pass fast"><h2>runs error handler<span class="duration">0ms</span></h2><pre><code>return Base.prototype.error.should.have.calledOnce;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.error</h1><ul><li class="suite"><h1>with an error</h1><ul><li class="test pass fast"><h2>logs an error<span class="duration">1ms</span></h2><pre><code>return this.errLog[0].should.equal('error');</code></pre></li><li class="test pass fast"><h2>emits the error through robot<span class="duration">0ms</span></h2><pre><code>return pretend.robot.emit.should.have.calledWith('error', this.err);</code></pre></li><li class="test pass fast"><h2>threw error<span class="duration">0ms</span></h2><pre><code>return this.base.error.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>with error context string</h1><ul><li class="test pass fast"><h2>logs an error with the module instance ID and context string<span class="duration">0ms</span></h2><pre><code>return this.errLog[1].should.match(new RegExp(this.base.id + &quot;.*something broke&quot;));</code></pre></li><li class="test pass fast"><h2>emits an error through robot<span class="duration">0ms</span></h2><pre><code>return pretend.robot.emit.should.have.calledWith('error');</code></pre></li><li class="test pass fast"><h2>threw error<span class="duration">0ms</span></h2><pre><code>return this.base.error.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>using inherited method for error</h1><ul><li class="test pass fast"><h2>calls inherited method<span class="duration">0ms</span></h2><pre><code>return Base.prototype.error.should.have.calledWith('Throw me an error');</code></pre></li><li class="test pass fast"><h2>threw<span class="duration">0ms</span></h2><pre><code>return this.module.error.should.have.threw;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.configure</h1><ul><li class="test pass fast"><h2>saves new options<span class="duration">1ms</span></h2><pre><code>var base;
base = new Base('module', pretend.robot);
base.configure({
  foo: true
});
return base.config.foo.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>overrides existing config<span class="duration">0ms</span></h2><pre><code>var base;
base = new Base('module', pretend.robot, {
  setting: true
});
base.configure({
  setting: false
});
return base.config.setting.should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>throws when not given options<span class="duration">1ms</span></h2><pre><code>var base;
base = new Base('module', pretend.robot);
try {
  base.configure('not an object');
} catch (error) {}
return base.configure.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>.defaults</h1><ul><li class="test pass fast"><h2>sets config if not set<span class="duration">0ms</span></h2><pre><code>this.base = new Base('module', pretend.robot);
this.base.defaults({
  setting: true
});
return this.base.config.should.eql({
  setting: true
});</code></pre></li><li class="test pass fast"><h2>does not change config if already set<span class="duration">2ms</span></h2><pre><code>this.base = new Base('module', pretend.robot, {
  setting: true
});
this.base.defaults({
  setting: false
});
return this.base.config.should.eql({
  setting: true
});</code></pre></li></ul></li><li class="suite"><h1>.emit</h1><ul><li class="test pass fast"><h2>emits event via the robot with instance as first arg<span class="duration">1ms</span></h2><pre><code>this.base = new Base('module', pretend.robot);
this.eventSpy = sinon.spy();
pretend.robot.on('mockEvent', this.eventSpy);
this.base.emit('mockEvent', {
  foo: 'bar'
});
return this.eventSpy.should.have.calledWith(this.base, {
  foo: 'bar'
});</code></pre></li></ul></li><li class="suite"><h1>.on</h1><ul><li class="test pass fast"><h2>relays events from robot to instance<span class="duration">1ms</span></h2><pre><code>this.base = new Base('module', pretend.robot);
this.mockEvent = sinon.spy();
this.base.on('mockEvent', this.mockEvent);
pretend.robot.emit('mockEvent', this.base, {
  foo: 'bar'
});
return this.mockEvent.should.have.calledWith({
  foo: 'bar'
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>Path</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>with branches</h1><ul><li class="test pass fast"><h2>calls .addBranch<span class="duration">2ms</span></h2><pre><code>var path;
sinon.spy(Path.prototype, 'addBranch');
path = new Path(pretend.robot, [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']]);
path.addBranch.args.should.eql([[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']]);
return Path.prototype.addBranch.restore();</code></pre></li><li class="test pass fast"><h2>is not closed<span class="duration">1ms</span></h2><pre><code>var path;
path = new Path(pretend.robot, [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']]);
return path.closed.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>with a single branch</h1><ul><li class="test pass fast"><h2>calls .addBranch<span class="duration">0ms</span></h2><pre><code>var path;
sinon.spy(Path.prototype, 'addBranch');
path = new Path(pretend.robot, [/ok/, 'OK, ok!']);
path.addBranch.args.should.eql([[/ok/, 'OK, ok!']]);
return Path.prototype.addBranch.restore();</code></pre></li><li class="test pass fast"><h2>is not closed<span class="duration">1ms</span></h2><pre><code>var path;
path = new Path(pretend.robot, [/ok/, 'OK, ok!']);
return path.closed.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>with undefined branches and options</h1><ul><li class="test pass fast"><h2>does not call .addBranch<span class="duration">0ms</span></h2><pre><code>var path;
sinon.spy(Path.prototype, 'addBranch');
path = new Path(pretend.robot);
return Path.prototype.addBranch.restore();</code></pre></li><li class="test pass fast"><h2>stays closed<span class="duration">0ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
return path.closed.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>with bad arguments for branch</h1><ul><li class="test pass fast"><h2>throws<span class="duration">0ms</span></h2><pre><code>return Path.constructor.should.have.threw;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.addBranch</h1><ul><li class="test pass fast"><h2>creates branch object<span class="duration">1ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
path.addBranch(/.*/, 'foo', function() {});
return path.branches[0].should.be.an('object');</code></pre></li><li class="test pass fast"><h2>branch has valid regex<span class="duration">0ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
path.addBranch(/.*/, 'foo', function() {});
return path.branches[0].regex.should.be[&quot;instanceof&quot;](RegExp);</code></pre></li><li class="test pass fast"><h2>calls getHandler with strings and callback<span class="duration">3ms</span></h2><pre><code>var callback, path;
path = new Path(pretend.robot);
callback = function() {};
sinon.stub(path, 'getHandler');
path.addBranch(/.*/, 'foo', callback);
return path.getHandler.should.have.calledWithExactly('foo', callback);</code></pre></li><li class="test pass fast"><h2>calls getHandler with just stirngs<span class="duration">1ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
sinon.stub(path, 'getHandler');
path.addBranch(/.*/, ['foo', 'bar']);
return path.getHandler.should.have.calledWithExactly(['foo', 'bar'], void 0);</code></pre></li><li class="test pass fast"><h2>calls getHandler with just callback<span class="duration">1ms</span></h2><pre><code>var callback, path;
path = new Path(pretend.robot);
callback = function() {};
sinon.stub(path, 'getHandler');
path.addBranch(/.*/, callback);
return path.getHandler.should.have.calledWithExactly(void 0, callback);</code></pre></li><li class="test pass fast"><h2>branch stores handler<span class="duration">0ms</span></h2><pre><code>var lasthandler, path;
path = new Path(pretend.robot);
sinon.spy(path, 'getHandler');
path.addBranch(/.*/, 'foo', function() {});
lasthandler = path.getHandler.returnValues[0];
return path.branches[0].handler.should.eql(lasthandler);</code></pre></li><li class="test pass fast"><h2>opens path<span class="duration">0ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
path.addBranch(/.*/, 'foo', function() {});
return path.closed.should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>throws with invalid regex<span class="duration">6ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
try {
  path.addBranch('derp');
} catch (error) {}
return path.addBranch.should.have.threw;</code></pre></li><li class="test pass fast"><h2>throws with invalid message and/or callback<span class="duration">1ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
try {
  path.addBranch(/.*/);
} catch (error) {}
try {
  path.addBranch(/.*/, function() {});
} catch (error) {}
try {
  path.addBranch(/.*/, 'foo', 'bar');
} catch (error) {}
return path.addBranch.should.have.alwaysThrew;</code></pre></li></ul></li><li class="suite"><h1>.getHandler</h1><ul><li class="test pass fast"><h2>returns a function<span class="duration">0ms</span></h2><pre><code>var callback, handler, path;
path = new Path(pretend.robot);
callback = sinon.spy();
handler = path.getHandler(['foo', 'bar'], callback);
return handler.should.be.a('function');</code></pre></li><li class="suite"><h1>when handler called with response</h1><ul><li class="test pass fast"><h2>calls the callback with the response<span class="duration">1ms</span></h2><pre><code>var callback, handler, mockRes, path;
path = new Path(pretend.robot);
callback = sinon.spy();
handler = path.getHandler(['foo', 'bar'], callback);
mockRes = {
  reply: sinon.spy()
};
handler(mockRes);
return callback.should.have.calledWithExactly(mockRes);</code></pre></li><li class="test pass fast"><h2>sends strings with dialogue if it has one<span class="duration">0ms</span></h2><pre><code>var handler, mockRes, path;
path = new Path(pretend.robot);
handler = path.getHandler(['foo', 'bar']);
mockRes = {
  reply: sinon.spy(),
  dialogue: {
    send: sinon.spy()
  }
};
handler(mockRes);
return mockRes.dialogue.send.should.have.calledWith('foo', 'bar');</code></pre></li><li class="test pass fast"><h2>uses response reply if there is no dialogue<span class="duration">0ms</span></h2><pre><code>var handler, mockRes, path;
path = new Path(pretend.robot);
handler = path.getHandler(['foo', 'bar']);
mockRes = {
  reply: sinon.spy()
};
handler(mockRes);
return mockRes.reply.should.have.calledWith('foo', 'bar');</code></pre></li><li class="test pass fast"><h2>returns promise resolving with send results<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var handler, handlerSpy, mockRes, path;
  path = new Path(pretend.robot);
  handler = path.getHandler(['foo'], function() {
    return {
      bar: 'baz'
    };
  });
  mockRes = {
    reply: sinon.spy()
  };
  handlerSpy = sinon.spy(handler);
  yield handler(mockRes);
  return handlerSpy.returned(sinon.match(resMatch));
});</code></pre></li><li class="test pass fast"><h2>returns promise also merged with callback results<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var handler, handlerSpy, mockRes, path;
  path = new Path(pretend.robot);
  handler = path.getHandler(['foo'], function() {
    return {
      bar: 'baz'
    };
  });
  mockRes = {
    reply: sinon.spy()
  };
  handlerSpy = sinon.spy(handler);
  yield handler(mockRes);
  return handlerSpy.returned(sinon.match({
    bar: 'baz'
  }));
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.match</h1><ul><li class="suite"><h1>with string matching branch regex</h1><ul><li class="test pass fast"><h2>updates match in response object<span class="duration">6ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var expectedMatch;
    yield pretend.user('sam').send('door 1');
    yield _this.path.match(pretend.lastListen());
    expectedMatch = 'door 1'.match(_this.path.branches[0].regex);
    return pretend.lastListen().match.should.eql(expectedMatch);
  };
})(this));</code></pre></li><li class="test pass fast"><h2>closes the path<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door 2');
    yield _this.path.match(pretend.lastListen());
    return _this.path.closed.should.be[&quot;true&quot;];
  };
})(this));</code></pre></li><li class="test pass fast"><h2>calls the handler for matching branch with res<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var res;
    _this.path.branches[1].handler = sinon.stub();
    yield pretend.user('sam').send('door 2');
    res = pretend.lastListen();
    yield _this.path.match(res);
    return _this.path.branches[1].handler.should.have.calledWithExactly(res);
  };
})(this));</code></pre></li><li class="test pass fast"><h2>emits match with res<span class="duration">8ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door 2');
    yield _this.path.match(pretend.lastListen());
    return _this.match.should.have.calledWith(sinon.match(resMatch));
  };
})(this));</code></pre></li></ul></li><li class="suite"><h1>with string matching multiple branches</h1><ul><li class="test pass fast"><h2>updates match in response object<span class="duration">8ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var expectedMatch;
    yield pretend.user('sam').send('door 1 and door 2');
    yield _this.path.match(pretend.lastListen());
    expectedMatch = 'door 1 and door 2'.match(_this.path.branches[0].regex);
    return pretend.lastListen().match.should.eql(expectedMatch);
  };
})(this));</code></pre></li><li class="test pass fast"><h2>calls the first matching branch handler<span class="duration">5ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var result;
    yield pretend.user('sam').send('door 1 and door 2');
    result = (yield _this.path.match(pretend.lastListen()));
    return result.should.have.property('winner', false);
  };
})(this));</code></pre></li><li class="test pass fast"><h2>closes the path<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door 1 and door 2');
    yield _this.path.match(pretend.lastListen());
    return _this.path.closed.should.be[&quot;true&quot;];
  };
})(this));</code></pre></li></ul></li><li class="suite"><h1>with mismatching string and no catch</h1><ul><li class="test pass fast"><h2>returns undefined<span class="duration">9ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var result;
    yield pretend.user('sam').send('door X');
    result = (yield _this.path.match(pretend.lastListen()));
    return chai.expect(result).to.be.undefined;
  };
})(this));</code></pre></li><li class="test pass fast"><h2>updates match to null in response object<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door X');
    yield _this.path.match(pretend.lastListen());
    return chai.expect(pretend.lastListen().match).to.be[&quot;null&quot;];
  };
})(this));</code></pre></li><li class="test pass fast"><h2>path stays open<span class="duration">7ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door X');
    yield _this.path.match(pretend.lastListen());
    return _this.path.closed.should.be[&quot;false&quot;];
  };
})(this));</code></pre></li><li class="test pass fast"><h2>emits mismatch with res<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    yield pretend.user('sam').send('door X');
    yield _this.path.match(pretend.lastListen());
    return _this.mismatch.should.have.calledWith(sinon.match(resMatch));
  };
})(this));</code></pre></li></ul></li><li class="suite"><h1>with mismatching string and catch message</h1><ul><li class="test pass fast"><h2>returns the response from send<span class="duration">8ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var result;
    _this.path.configure({
      catchMessage: 'no, wrong door'
    });
    yield pretend.user('sam').send('door X');
    result = (yield _this.path.match(pretend.lastListen()));
    return result.strings.should.eql(['no, wrong door']);
  };
})(this));</code></pre></li><li class="test pass fast"><h2>emits catch with res<span class="duration">6ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    _this.path.configure({
      catchMessage: 'no, wrong door'
    });
    yield pretend.user('sam').send('door X');
    yield _this.path.match(pretend.lastListen());
    return _this[&quot;catch&quot;].should.have.calledWith(sinon.match(resMatch));
  };
})(this));</code></pre></li></ul></li><li class="suite"><h1>with mismatching string and catch callback</h1><ul><li class="test pass fast"><h2>returns the result of the callback<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    var result;
    _this.path.configure({
      catchCallback: function() {
        return {
          other: 'door fail'
        };
      }
    });
    yield pretend.user('sam').send('door X');
    result = (yield _this.path.match(pretend.lastListen()));
    return result.should.have.property('other', 'door fail');
  };
})(this));</code></pre></li><li class="test pass fast"><h2>emits catch with res<span class="duration">4ms</span></h2><pre><code>return co((function(_this) {
  return function*() {
    _this.path.configure({
      catchMessage: 'no, wrong door'
    });
    yield pretend.user('sam').send('door X');
    yield _this.path.match(pretend.lastListen());
    return _this[&quot;catch&quot;].should.have.calledWith(sinon.match(resMatch));
  };
})(this));</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Dialogue</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="test pass fast"><h2>has null path<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
return should.equal(dialogue.path, null);</code></pre></li><li class="test pass fast"><h2>is not ended<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
return dialogue.ended.should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>uses timeout from env<span class="duration">0ms</span></h2><pre><code>var dialogue;
process.env.DIALOGUE_TIMEOUT = 500;
dialogue = new Dialogue(testRes);
dialogue.config.timeout.should.equal(500);
return delete process.env.DIALOGUE_TIMEOUT;</code></pre></li></ul></li><li class="suite"><h1>.end</h1><ul><li class="suite"><h1>before messages received</h1><ul><li class="test pass fast"><h2>emits end with initial response<span class="duration">0ms</span></h2><pre><code>var dialogue, end;
dialogue = new Dialogue(testRes);
end = sinon.spy();
dialogue.on('end', end);
dialogue.end();
return end.should.have.calledWith(testRes);</code></pre></li><li class="test pass fast"><h2>sets ended to true<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.end();
return dialogue.ended.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
return dialogue.end().should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>after messages received</h1><ul><li class="test pass fast"><h2>emits end with latest response (containing dialogue)<span class="duration">1ms</span></h2><pre><code>var dialogue, end;
dialogue = new Dialogue(testRes);
end = sinon.spy();
dialogue.on('end', end);
dialogue.receive(testRes);
dialogue.end();
return end.should.have.calledWith(sinon.match(matchRes));</code></pre></li></ul></li><li class="suite"><h1>when timeout is running</h1><ul><li class="test pass fast"><h2>clears the timeout<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.startTimeout();
dialogue.end();
return dialogue.clearTimeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>when already ended</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">1ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.end();
return dialogue.end().should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>should only emit end event once<span class="duration">0ms</span></h2><pre><code>var dialogue, end;
dialogue = new Dialogue(testRes);
end = sinon.spy();
dialogue.on('end', end);
dialogue.end();
dialogue.end();
return end.should.have.calledOnce;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.send</h1><ul><li class="suite"><h1>with config.sendReplies set to false</h1><ul><li class="test pass fast"><h2>sends to the room from original res<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue;
  dialogue = new Dialogue(testRes);
  yield dialogue.send('test');
  return pretend.messages.pop().should.eql(['testing', 'hubot', 'test']);
});</code></pre></li><li class="test pass fast"><h2>emits send event with new response (containing dialogue)<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, sendSpy;
  dialogue = new Dialogue(testRes);
  sendSpy = sinon.spy();
  dialogue.on('send', sendSpy);
  yield dialogue.send('test');
  return sendSpy.should.have.calledWith(sinon.match(matchRes));
});</code></pre></li><li class="test pass fast"><h2>also emits with strings, methdod and original res<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  var dialogue, sendSpy;
  dialogue = new Dialogue(testRes);
  sendSpy = sinon.spy();
  dialogue.on('send', sendSpy);
  yield dialogue.send('test');
  return sendSpy.lastCall.args[1].should.eql({
    strings: ['test'],
    method: 'send',
    received: testRes
  });
});</code></pre></li></ul></li><li class="suite"><h1>with config.sendReplies set to true</h1><ul><li class="test pass fast"><h2>sends to room from original res, responding to the @user<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue;
  dialogue = new Dialogue(testRes);
  dialogue.config.sendReplies = true;
  yield dialogue.send('test');
  return pretend.messages.pop().should.eql(['testing', 'hubot', '@tester test']);
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.onTimeout</h1><ul><li class="suite"><h1>default method</h1><ul><li class="test pass fast"><h2>sends timeout message to room<span class="duration">0ms</span></h2><pre><code>function* () {
          var dialogue, wait;
          wait = pretend.observer.next();
          dialogue = new Dialogue(testRes, {
            timeout: 1000
          });
          dialogue.startTimeout();
          clock.tick(1001);
          yield wait;
          return pretend.messages.pop().should.eql(['testing', 'hubot', dialogue.config.timeoutText]);
        }</code></pre></li></ul></li><li class="suite"><h1>method override (as argument)</h1><ul><li class="test pass fast"><h2>calls the override method<span class="duration">1ms</span></h2><pre><code>var dialogue, timeout;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
timeout = sinon.spy();
dialogue.onTimeout(timeout);
dialogue.startTimeout();
clock.tick(1001);
return timeout.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>does not send the default timeout message<span class="duration">1ms</span></h2><pre><code>var dialogue, timeout;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
timeout = sinon.spy();
dialogue.onTimeout(timeout);
dialogue.startTimeout();
clock.tick(1001);
return dialogue.send.should.not.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>method override (by assignment)</h1><ul><li class="test pass fast"><h2>calls the override method<span class="duration">1ms</span></h2><pre><code>var dialogue, timeout;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
timeout = sinon.spy();
dialogue.onTimeout = timeout;
dialogue.startTimeout();
clock.tick(1001);
return timeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>method override with invalid function</h1><ul><li class="test pass fast"><h2>throws exception<span class="duration">6ms</span></h2><pre><code>var dialogue, override;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
dialogue.onTimeout(function() {
  throw new Error(&quot;Test exception&quot;);
});
override = sinon.spy(dialogue, 'onTimeout');
dialogue.startTimeout();
try {
  clock.tick(1001);
} catch (error) {}
return override.should.have.threw;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.startTimeout</h1><ul><li class="test pass fast"><h2>emits timeout event<span class="duration">1ms</span></h2><pre><code>var dialogue, timeoutEvent, timeoutMethod;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
timeoutMethod = sinon.spy();
dialogue.onTimeout(timeoutMethod);
timeoutEvent = sinon.spy();
dialogue.on('timeout', timeoutEvent);
dialogue.startTimeout();
clock.tick(1001);
return timeoutEvent.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>emits end event<span class="duration">1ms</span></h2><pre><code>var dialogue, end, timeoutMethod;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
end = sinon.spy();
dialogue.on('end', end);
timeoutMethod = sinon.spy();
dialogue.onTimeout(timeoutMethod);
dialogue.startTimeout();
clock.tick(1001);
return end.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls onTimeout method<span class="duration">0ms</span></h2><pre><code>var dialogue, timeoutMethod;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000
});
timeoutMethod = sinon.spy();
dialogue.onTimeout(timeoutMethod);
dialogue.startTimeout();
clock.tick(1001);
return timeoutMethod.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls .end<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.configure({
  timeout: 1000,
  timeoutText: null
});
dialogue.startTimeout();
clock.tick(1001);
return dialogue.end.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>.addPath</h1><ul><li class="suite"><h1>with a prompt, branches and key</h1><ul><li class="test pass fast"><h2>returns new Path instance<span class="duration">2ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath('Turn left or right?', [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']], 'which-way'));
  return path.should.be[&quot;instanceof&quot;](dialogue.Path);
});</code></pre></li><li class="test pass fast"><h2>passes options to path<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath('Turn left or right?', [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']], 'which-way'));
  return path.key.should.eql('which-way');
});</code></pre></li><li class="test pass fast"><h2>sends the prompt<span class="duration">2ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath('Turn left or right?', [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']], 'which-way'));
  return dialogue.send.should.have.calledWith('Turn left or right?');
});</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath('Turn left or right?', [[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']], 'which-way'));
  return dialogue.startTimeout.should.have.calledOnce;
});</code></pre></li></ul></li><li class="suite"><h1>with branches only</h1><ul><li class="test pass fast"><h2>returns new Path instance<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath([[/1/, 'You get cake!'], [/2/, 'You get cake!']]));
  return path.should.be[&quot;instanceof&quot;](dialogue.Path);
});</code></pre></li><li class="test pass fast"><h2>sends nothing<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath([[/1/, 'You get cake!'], [/2/, 'You get cake!']]));
  return dialogue.send.should.not.have.called;
});</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath([[/1/, 'You get cake!'], [/2/, 'You get cake!']]));
  return dialogue.startTimeout.should.have.calledOnce;
});</code></pre></li></ul></li><li class="suite"><h1>without branches</h1><ul><li class="test pass fast"><h2>returns new Path instance<span class="duration">0ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath(&quot;Don't say nothing.&quot;));
  return path.should.be[&quot;instanceof&quot;](dialogue.Path);
});</code></pre></li><li class="test pass fast"><h2>does not start timeout<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  var dialogue, path;
  dialogue = new Dialogue(testRes);
  path = (yield dialogue.addPath(&quot;Don't say nothing.&quot;));
  return dialogue.startTimeout.should.not.have.called;
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.addBranch</h1><ul><li class="suite"><h1>with existing path</h1><ul><li class="test pass fast"><h2>passes branch args on to path.addBranch<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.path = {
  addBranch: sinon.spy()
};
dialogue.addBranch(/foo/, 'foo');
return dialogue.path.addBranch.should.have.calledWith(/foo/, 'foo');</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.path = {
  addBranch: sinon.spy()
};
dialogue.addBranch(/foo/, 'foo');
return dialogue.startTimeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>when no path exists</h1><ul><li class="test pass fast"><h2>creates a new path<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, 'foo');
return dialogue.path.should.be[&quot;instanceof&quot;](dialogue.Path);</code></pre></li><li class="test pass fast"><h2>passes branch args on to path.addBranch<span class="duration">1ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
sinon.spy(dialogue.Path.prototype, 'addBranch');
dialogue.addBranch(/foo/, 'foo');
return dialogue.path.addBranch.should.have.calledWith(/foo/, 'foo');</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">1ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, 'foo');
return dialogue.startTimeout.should.have.calledOnce;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.receive</h1><ul><li class="test pass fast"><h2>stores the latest response object<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/.*/, function() {});
dialogue.receive(pretend.response('tester', 'new test'));
return dialogue.res.message.text.should.equal('new test');</code></pre></li><li class="test pass fast"><h2>attaches itself to the response<span class="duration">6ms</span></h2><pre><code>var dialogue, newTestRes;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/.*/, function() {});
newTestRes = pretend.response('tester', 'new test');
dialogue.receive(newTestRes);
return newTestRes.dialogue.should.eql(dialogue);</code></pre></li><li class="suite"><h1>when already ended</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.end();
return dialogue.receive(testRes).should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>does not call the handler<span class="duration">1ms</span></h2><pre><code>var callback, dialogue;
dialogue = new Dialogue(testRes);
callback = sinon.spy();
dialogue.addBranch(/.*/, callback);
dialogue.end();
dialogue.receive(testRes);
return callback.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on matching branch</h1><ul><li class="test pass fast"><h2>clears timeout<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {
  return null;
});
dialogue.receive(pretend.response('tester', 'foo'));
return dialogue.clearTimeout.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>ends dialogue<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {
  return null;
});
dialogue.receive(pretend.response('tester', 'foo'));
return dialogue.end.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls the branch handler<span class="duration">6ms</span></h2><pre><code>return co(function() {
  var callback, dialogue;
  dialogue = new Dialogue(testRes);
  callback = sinon.spy();
  dialogue.addBranch(/foo/, 'bar', callback);
  dialogue.receive(pretend.response('tester', 'foo'));
  return callback.should.have.calledOnce;
});</code></pre></li><li class="test pass fast"><h2>sends the branch message<span class="duration">5ms</span></h2><pre><code>return co(function() {
  var callback, dialogue;
  dialogue = new Dialogue(testRes);
  callback = sinon.spy();
  dialogue.addBranch(/foo/, 'bar', callback);
  dialogue.receive(pretend.response('tester', 'foo'));
  return dialogue.send.should.have.calledWith('bar');
});</code></pre></li></ul></li><li class="suite"><h1>on matching branches consecutively</h1><ul><li class="test pass fast"><h2>only processes first match<span class="duration">9ms</span></h2><pre><code>var callback, dialogue;
dialogue = new Dialogue(testRes);
callback = sinon.spy();
dialogue.addBranch(/foo/, callback);
dialogue.addBranch(/bar/, callback);
dialogue.receive(pretend.response('tester', 'foo'));
dialogue.receive(pretend.response('tester', 'bar'));
return callback.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>on mismatch with catch</h1><ul><li class="test pass fast"><h2>sends the catch message<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {});
dialogue.path.config.catchMessage = 'huh?';
dialogue.receive(pretend.response('tester', '?'));
return dialogue.send.should.have.calledWith('huh?');</code></pre></li><li class="test pass fast"><h2>does not clear timeout<span class="duration">9ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {});
dialogue.path.config.catchMessage = 'huh?';
dialogue.receive(pretend.response('tester', '?'));
return dialogue.clearTimeout.should.not.have.called;</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">4ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {});
dialogue.path.config.catchMessage = 'huh?';
dialogue.receive(pretend.response('tester', '?'));
return dialogue.end.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on mismatch without catch</h1><ul><li class="test pass fast"><h2>does not clear timeout<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {});
dialogue.receive(pretend.response('tester', '?'));
return dialogue.clearTimeout.should.not.have.called;</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/foo/, function() {});
dialogue.receive(pretend.response('tester', '?'));
return dialogue.end.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on matching branch that adds a new branch</h1><ul><li class="test pass fast"><h2>added branches to current path<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/more/, function() {
  dialogue.addBranch(/1/, 'got 1');
  return dialogue.addBranch(/2/, 'got 2');
});
dialogue.receive(pretend.response('tester', 'more'));
return _.map(dialogue.path.branches, function(branch) {
  return branch.regex;
}).should.eql([/more/, /1/, /2/]);</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/more/, function() {
  dialogue.addBranch(/1/, 'got 1');
  return dialogue.addBranch(/2/, 'got 2');
});
dialogue.receive(pretend.response('tester', 'more'));
return dialogue.end.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on matching branch that adds a new path</h1><ul><li class="test pass fast"><h2>added new branches to new path, overwrites prev path<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/new/, function() {
  return dialogue.addPath([[/1/, 'got 1'], [/2/, 'got 2']]);
});
dialogue.receive(pretend.response('tester', 'new'));
return _.map(dialogue.path.branches, function(branch) {
  return branch.regex;
}).should.eql([/1/, /2/]);</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = new Dialogue(testRes);
dialogue.addBranch(/new/, function() {
  return dialogue.addPath([[/1/, 'got 1'], [/2/, 'got 2']]);
});
dialogue.receive(pretend.response('tester', 'new'));
return dialogue.end.should.not.have.called;</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Scene</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>without options</h1><ul><li class="test pass fast"><h2>defaults to `user` scope<span class="duration">0ms</span></h2><pre><code>return this.scene.config.scope.should.equal('user');</code></pre></li><li class="test pass fast"><h2>attaches the receive middleware to robot<span class="duration">0ms</span></h2><pre><code>return pretend.robot.receiveMiddleware.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>with options</h1><ul><li class="test pass fast"><h2>stored options in config object<span class="duration">0ms</span></h2><pre><code>return this.scene.config.sendReplies.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>with room scope option</h1><ul><li class="test pass fast"><h2>accepts given room scope<span class="duration">0ms</span></h2><pre><code>return this.scene.config.scope.should.equal('room');</code></pre></li><li class="test pass fast"><h2>stores config with default options for scope<span class="duration">0ms</span></h2><pre><code>return this.scene.config.sendReplies.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>with invalid scope</h1><ul><li class="test pass fast"><h2>throws error when given invalid scope<span class="duration">0ms</span></h2><pre><code>return Scene.prototype.constructor.should.have.threw;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.listen</h1><ul><li class="suite"><h1>with hear type and message matching regex</h1><ul><li class="test pass fast"><h2>registers a robot hear listener with scene as attribute<span class="duration">1ms</span></h2><pre><code>return pretend.robot.hear.should.have.calledWithMatch(sinon.match.regexp, sinon.match.has('scene', this.scene, sinon.match.func));</code></pre></li><li class="test pass fast"><h2>calls the given callback from listener<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>callback should receive res and dialogue<span class="duration">1ms</span></h2><pre><code>var matchRes;
matchRes = sinon.match.instanceOf(pretend.robot.Response).and(sinon.match.has('dialogue'));
return this.callback.should.have.calledWith(matchRes);</code></pre></li></ul></li><li class="suite"><h1>with respond type and message matching regex</h1><ul><li class="test pass fast"><h2>registers a robot respond listener with scene as attribute<span class="duration">1ms</span></h2><pre><code>return pretend.robot.respond.should.have.calledWithMatch(sinon.match.regexp, sinon.match.has('scene', this.scene, sinon.match.func));</code></pre></li><li class="test pass fast"><h2>calls the given callback from listener<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>callback should receive res and dialogue<span class="duration">0ms</span></h2><pre><code>var matchRes;
matchRes = sinon.match.instanceOf(pretend.robot.Response).and(sinon.match.has('dialogue'));
return this.callback.should.have.calledWith(matchRes);</code></pre></li></ul></li><li class="suite"><h1>with an invalid type</h1><ul><li class="test pass fast"><h2>throws<span class="duration">0ms</span></h2><pre><code>return this.scene.listen.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>with an invalid regex</h1><ul><li class="test pass fast"><h2>throws<span class="duration">0ms</span></h2><pre><code>return this.scene.listen.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>with an invalid callback</h1><ul><li class="test pass fast"><h2>throws<span class="duration">0ms</span></h2><pre><code>return this.scene.listen.should.have.threw;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.hear</h1><ul><li class="test pass fast"><h2>calls .listen with hear listen type and arguments<span class="duration">0ms</span></h2><pre><code>var args, ref;
args = ['hear', /test/, sinon.match.func];
return (ref = this.scene.listen.getCall(0).should.have).calledWith.apply(ref, args);</code></pre></li></ul></li><li class="suite"><h1>.respond</h1><ul><li class="test pass fast"><h2>calls .listen with respond listen type and arguments<span class="duration">0ms</span></h2><pre><code>var args, ref;
args = ['respond', /test/, sinon.match.func];
return (ref = this.scene.listen.getCall(0).should.have).calledWith.apply(ref, args);</code></pre></li></ul></li><li class="suite"><h1>.whoSpeaks</h1><ul><li class="suite"><h1>user scene</h1><ul><li class="test pass fast"><h2>returns the ID of engaged user<span class="duration">0ms</span></h2><pre><code>return this.scene.whoSpeaks.returnValues.pop().should.equal('tester');</code></pre></li></ul></li><li class="suite"><h1>room sceene</h1><ul><li class="test pass fast"><h2>returns the room ID<span class="duration">0ms</span></h2><pre><code>return this.scene.whoSpeaks.returnValues.pop().should.equal('testing');</code></pre></li></ul></li><li class="suite"><h1>direct scene</h1><ul><li class="test pass fast"><h2>returns the concatenated user ID and room ID<span class="duration">0ms</span></h2><pre><code>return this.scene.whoSpeaks.returnValues.pop().should.equal('tester_testing');</code></pre></li></ul></li></ul></li><li class="suite"><h1>.enter</h1><ul><li class="suite"><h1>user scene</h1><ul><li class="test pass fast"><h2>saves engaged Dialogue instance with user ID<span class="duration">0ms</span></h2><pre><code>return this.scene.engaged['tester'].should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li></ul></li><li class="suite"><h1>room scene</h1><ul><li class="test pass fast"><h2>saves engaged Dialogue instance with room key<span class="duration">1ms</span></h2><pre><code>return this.scene.engaged['testing'].should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li></ul></li><li class="suite"><h1>direct scene</h1><ul><li class="test pass fast"><h2>saves engaged Dialogue instance with composite key<span class="duration">0ms</span></h2><pre><code>return this.scene.engaged['tester_testing'].should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li></ul></li><li class="suite"><h1>with timeout options</h1><ul><li class="test pass fast"><h2>passes the options to dialogue config<span class="duration">0ms</span></h2><pre><code>this.dialogue.config.timeout.should.equal(100);
return this.dialogue.config.timeoutText.should.equal('foo');</code></pre></li></ul></li><li class="suite"><h1>dialogue allowed to timeout after branch added</h1><ul><li class="test pass fast"><h2>calls .exit first on &quot;timeout&quot;<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.getCall(0).should.have.calledWith(this.res, 'timeout');</code></pre></li><li class="test pass fast"><h2>calls .exit again on &quot;incomplete&quot;<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.getCall(1).should.have.calledWith(this.res, 'incomplete');</code></pre></li></ul></li><li class="suite"><h1>dialogue completed (by message matching branch)</h1><ul><li class="test pass fast"><h2>calls .exit once only<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls .exit once with last (matched) res and &quot;complete&quot;<span class="duration">1ms</span></h2><pre><code>return this.scene.exit.should.have.calledWith(this.dialogue.res, 'complete');</code></pre></li></ul></li><li class="suite"><h1>re-enter currently engaged participants</h1><ul><li class="test pass fast"><h2>returns undefined the second time<span class="duration">0ms</span></h2><pre><code>return should.not.exist(this.scene.enter.returnValues[1]);</code></pre></li></ul></li><li class="suite"><h1>re-enter previously engaged participants</h1><ul><li class="test pass fast"><h2>returns Dialogue instance (as per normal)<span class="duration">0ms</span></h2><pre><code>return this.dialogueB.should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.exit</h1><ul><li class="suite"><h1>with user in scene, called manually</h1><ul><li class="test pass fast"><h2>does not call onTimeout on dialogue<span class="duration">0ms</span></h2><pre><code>return this.timeout.should.not.have.called;</code></pre></li><li class="test pass fast"><h2>removes the dialogue instance from engaged array<span class="duration">0ms</span></h2><pre><code>return should.not.exist(this.scene.engaged['tester']);</code></pre></li><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.returnValues.pop().should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>dialogue does not continue receiving after scene exit<span class="duration">0ms</span></h2><pre><code>return this.dialogue.receive.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>with user in scene, called from events</h1><ul><li class="test pass fast"><h2>gets called twice (on timeout and end)<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.should.have.calledTwice;</code></pre></li><li class="test pass fast"><h2>returns true the first time<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.getCall(0).should.have.returned(true);</code></pre></li><li class="test pass fast"><h2>returns false the second time (because already disengaged)<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.getCall(1).should.have.returned(false);</code></pre></li></ul></li><li class="suite"><h1>user not in scene, called manually</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.returnValues.pop().should.be[&quot;false&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.exitAll</h1><ul><li class="suite"><h1>with two users in scene</h1><ul><li class="test pass fast"><h2>created two dialogues<span class="duration">0ms</span></h2><pre><code>this.dialogueA.should.be[&quot;instanceof&quot;](Dialogue);
return this.dialogueB.should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li><li class="test pass fast"><h2>calls clearTimeout on both dialogues<span class="duration">1ms</span></h2><pre><code>this.dialogueA.clearTimeout.should.have.calledOnce;
return this.dialogueB.clearTimeout.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>has no remaining engaged dialogues<span class="duration">0ms</span></h2><pre><code>return this.scene.engaged.length.should.equal(0);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.getDialogue</h1><ul><li class="suite"><h1>with user in scene</h1><ul><li class="test pass fast"><h2>returns the matching dialogue<span class="duration">0ms</span></h2><pre><code>return this.dialogueB.should.eql(this.dialogueA);</code></pre></li></ul></li><li class="suite"><h1>no user in scene</h1><ul><li class="test pass fast"><h2>returns undefined<span class="duration">0ms</span></h2><pre><code>return should.not.exist(this.dialogue);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.inDialogue</h1><ul><li class="suite"><h1>in engaged user scene</h1><ul><li class="test pass fast"><h2>returns true with user ID<span class="duration">0ms</span></h2><pre><code>return this.userEngaged.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>returns false with room name<span class="duration">0ms</span></h2><pre><code>return this.roomEngaged.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>no participants in scene</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.userEngaged.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>room scene, in scene</h1><ul><li class="test pass fast"><h2>returns true with roomname<span class="duration">0ms</span></h2><pre><code>return this.roomEngaged.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>returns false with user ID<span class="duration">0ms</span></h2><pre><code>return this.userEngaged.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>direct scene, in scene</h1><ul><li class="test pass fast"><h2>returns true with userID_roomID<span class="duration">0ms</span></h2><pre><code>return this.directEngaged.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>returns false with roomname<span class="duration">0ms</span></h2><pre><code>return this.roomEngaged.should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>returns false with user ID<span class="duration">0ms</span></h2><pre><code>return this.userEngaged.should.be[&quot;false&quot;];</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Director</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>without optional args</h1><ul><li class="test pass fast"><h2>has empty array names<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql([]);</code></pre></li></ul></li><li class="suite"><h1>with authorise function</h1><ul><li class="test pass fast"><h2>stores the given function as its authorise method<span class="duration">0ms</span></h2><pre><code>return this.director.authorise = this.authorise;</code></pre></li></ul></li><li class="suite"><h1>with options (denied reply and key string)</h1><ul><li class="test pass fast"><h2>stores passed options in config<span class="duration">0ms</span></h2><pre><code>return this.director.config.deniedReply.should.equal(&quot;DENIED!&quot;);</code></pre></li></ul></li><li class="suite"><h1>with env var for config</h1><ul><li class="test pass fast"><h2>has default config with env inherited<span class="duration">0ms</span></h2><pre><code>return this.director.config.should.eql({
  type: 'whitelist',
  scope: 'username',
  deniedReply: &quot;403 Sorry.&quot;
});</code></pre></li></ul></li><li class="suite"><h1>with env var for names</h1><ul><li class="suite"><h1>whitelist type, username scope</h1><ul><li class="test pass fast"><h2>stores the whitelisted usernames from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Emmanuel']);</code></pre></li></ul></li><li class="suite"><h1>whitelist type, room scope</h1><ul><li class="test pass fast"><h2>stores the whitelisted rooms from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Capital']);</code></pre></li></ul></li><li class="suite"><h1>blacklist type, username scope</h1><ul><li class="test pass fast"><h2>stores the blacklisted usernames from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Winston', 'Julia', 'Syme']);</code></pre></li></ul></li><li class="suite"><h1>blacklist type, room scope</h1><ul><li class="test pass fast"><h2>stores the blacklisted rooms from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Labour']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>with invalid option for type</h1><ul><li class="test pass fast"><h2>should throw error<span class="duration">0ms</span></h2><pre><code>return Director.prototype.constructor.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>with invalid option for scope</h1><ul><li class="test pass fast"><h2>should throw error<span class="duration">0ms</span></h2><pre><code>return Director.prototype.constructor.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>without key, with authorise function and options</h1><ul><li class="test pass fast"><h2>uses options<span class="duration">0ms</span></h2><pre><code>return this.director.config.scope.should.equal('room');</code></pre></li><li class="test pass fast"><h2>uses authorise function<span class="duration">0ms</span></h2><pre><code>return this.director.authorise.should.eql(this.authorise);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.add</h1><ul><li class="suite"><h1>given array of names</h1><ul><li class="test pass fast"><h2>stores them in the names array<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['pema', 'nima']);</code></pre></li></ul></li><li class="suite"><h1>given single name</h1><ul><li class="test pass fast"><h2>stores it in the names array<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['pema']);</code></pre></li></ul></li><li class="suite"><h1>given array of names, some existing</h1><ul><li class="test pass fast"><h2>adds any missing, not duplicating existing<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['yeon', 'juan', 'pema']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.remove</h1><ul><li class="suite"><h1>given array of names</h1><ul><li class="test pass fast"><h2>removes them from the names array<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['yeon', 'juan']);</code></pre></li></ul></li><li class="suite"><h1>with single name</h1><ul><li class="test pass fast"><h2>removes it from the names array<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['yeon', 'juan', 'nima']);</code></pre></li></ul></li><li class="suite"><h1>with array names, some not existing</h1><ul><li class="test pass fast"><h2>removes any missing, ignoring others<span class="duration">1ms</span></h2><pre><code>return this.director.names.should.eql(['yeon']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.isAllowed</h1><ul><li class="suite"><h1>whitelist without authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>blacklist without authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;true&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>whitelist with authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>calls authorise function with username and res<span class="duration">0ms</span></h2><pre><code>return this.authorise.should.have.calledWith('tester', this.res);</code></pre></li><li class="test pass fast"><h2>returns value of authorise function<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal('AUTHORISE');</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>does not call authorise function<span class="duration">0ms</span></h2><pre><code>return this.authorise.should.not.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns value of authorise function<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal('AUTHORISE');</code></pre></li></ul></li></ul></li><li class="suite"><h1>blacklist with authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>calls authorise function with username and res<span class="duration">0ms</span></h2><pre><code>return this.authorise.should.have.calledWith('tester', this.res);</code></pre></li><li class="test pass fast"><h2>returns value of authorise function<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal('AUTHORISE');</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>does not call authorise function<span class="duration">0ms</span></h2><pre><code>return this.authorise.should.not.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns value of authorise function<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal('AUTHORISE');</code></pre></li></ul></li></ul></li><li class="suite"><h1>room scope, blacklist room</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>room scope, whitelist room</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;true&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.process</h1><ul><li class="suite"><h1>denied user</h1><ul><li class="test pass fast"><h2>calls .isAllowed to determine if user is allowed or denied<span class="duration">0ms</span></h2><pre><code>return this.director.isAllowed.should.have.calledWith(this.res);</code></pre></li><li class="test pass fast"><h2>returns the same result as .isAllowed<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal(this.director.isAllowed.returnValues.pop());</code></pre></li></ul></li><li class="suite"><h1>denied with denied reply value</h1><ul><li class="test pass fast"><h2>calls response method reply with reply value<span class="duration">0ms</span></h2><pre><code>return this.res.reply.should.have.calledWith(this.director.config.deniedReply);</code></pre></li></ul></li><li class="suite"><h1>denied without denied reply value</h1><ul><li class="test pass fast"><h2>does not call response reply method<span class="duration">0ms</span></h2><pre><code>return this.res.reply.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>allowed user</h1><ul><li class="test pass fast"><h2>calls .isAllowed to determine if user is allowed or denied<span class="duration">0ms</span></h2><pre><code>return this.director.isAllowed.should.have.calledWith(this.res);</code></pre></li><li class="test pass fast"><h2>returns the same value as .isAllowed<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal(this.director.isAllowed.returnValues.pop());</code></pre></li><li class="test pass fast"><h2>does not send denied reply<span class="duration">0ms</span></h2><pre><code>return this.res.reply.should.not.have.called;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.directMatch</h1><ul><li class="suite"><h1>allowed user sending message matching directed match</h1><ul><li class="test pass fast"><h2>calls .process with response to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>triggers match callback normally<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>denied user sending message matching directed match</h1><ul><li class="test pass fast"><h2>calls .process to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>prevents match callback from triggering<span class="duration">0ms</span></h2><pre><code>return this.callback.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>denied user sending unmatched message</h1><ul><li class="test pass fast"><h2>does not call .process because middleware did not match<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.not.have.called;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.directListener</h1><ul><li class="suite"><h1>allowed user sending message matching directed listener id</h1><ul><li class="test pass fast"><h2>calls .process with response to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>triggers match callback normally<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>denied user sending message matching directed match</h1><ul><li class="test pass fast"><h2>calls .process to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>prevents match callback from triggering<span class="duration">0ms</span></h2><pre><code>return this.callback.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>denied user sending unmatched message</h1><ul><li class="test pass fast"><h2>does not call .process because middleware did not match<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.not.have.called;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.directScene</h1><ul><li class="test pass fast"><h2>calls .directListener to control access to scene listeners<span class="duration">1ms</span></h2><pre><code>return this.director.directListener.should.have.calledWith(this.scene.id);</code></pre></li><li class="suite"><h1>scene enter manually called (user allowed)</h1><ul><li class="test pass fast"><h2>calls .process to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledWith(this.res);</code></pre></li><li class="test pass fast"><h2>allowed the .enter method, returning a Dialogue object<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li></ul></li><li class="suite"><h1>scene enter manually called (user denied)</h1><ul><li class="test pass fast"><h2>calls .process to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledWith(this.res);</code></pre></li><li class="test pass fast"><h2>preempts scene.enter, returning false instead<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>allowed user sends message matching scene listener</h1><ul><li class="test pass fast"><h2>triggers the scene enter method<span class="duration">0ms</span></h2><pre><code>return this.enter.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls the scene listener callback<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>denied user sends message matching scene listener</h1><ul><li class="test pass fast"><h2>prevents the scene enter method<span class="duration">1ms</span></h2><pre><code>return this.enter.should.not.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>does not call the scene listener callback<span class="duration">0ms</span></h2><pre><code>return this.callback.should.not.have.calledOnce;</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Transcript</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>with saving enabled (default)</h1><ul><li class="test pass fast"><h2>uses brain for record keeping<span class="duration">1ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: 0,
    event: 'test'
  }
]);</code></pre></li></ul></li><li class="suite"><h1>with saving disabled</h1><ul><li class="test pass fast"><h2>keeps records in a new empty array<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([]);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.recordEvent</h1><ul><li class="suite"><h1>emitted from Hubot/brain</h1><ul><li class="test pass fast"><h2>records event &quot;other&quot; data<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: 0,
    event: 'mockEvent',
    other: [
      {
        test: 'data'
      }
    ]
  }
]);</code></pre></li></ul></li><li class="suite"><h1>emitted from Playbook module</h1><ul><li class="suite"><h1>with default config</h1><ul><li class="test pass fast"><h2>records default instance attributes<span class="duration">8ms</span></h2><pre><code>this.transcript.on('record', (function(_this) {
  return function() {
    _this.transcript.records[0].should.containSubset({
      instance: {
        name: _this.module.name,
        key: _this.module.key,
        id: _this.module.id
      }
    });
    return done();
  };
})(this));
return this.module.emit('mockEvent', pretend.response('tester', 'test'));</code></pre></li><li class="test pass fast"><h2>records default response attributes<span class="duration">9ms</span></h2><pre><code>var res;
res = pretend.response('tester', 'test');
this.transcript.on('record', (function(_this) {
  return function() {
    _this.transcript.records[0].should.containSubset({
      response: {
        match: res.match
      }
    });
    return done();
  };
})(this));
return this.module.emit('mockEvent', res);</code></pre></li><li class="test pass fast"><h2>records default message attributes<span class="duration">15ms</span></h2><pre><code>var res;
res = pretend.response('tester', 'test', 'testing');
this.transcript.on('record', (function(_this) {
  return function() {
    _this.transcript.records[0].should.containSubset({
      message: {
        user: {
          id: res.message.user.id,
          name: res.message.user.name
        },
        room: res.message.room,
        text: res.message.text
      }
    });
    return done();
  };
})(this));
return this.module.emit('mockEvent', pretend.response('tester', 'test'));</code></pre></li></ul></li><li class="suite"><h1>with transcript key</h1><ul><li class="test pass fast"><h2>records event with key property<span class="duration">0ms</span></h2><pre><code>return this.transcript.records[0].should.have.property('key', 'test-key');</code></pre></li></ul></li><li class="suite"><h1>with custom instance atts</h1><ul><li class="test pass fast"><h2>records custom instance attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  instance: {
    name: this.module.name,
    config: {
      scope: this.module.config.scope
    }
  }
});</code></pre></li></ul></li><li class="suite"><h1>with custom response atts</h1><ul><li class="test pass fast"><h2>records custom response attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  response: {
    message: {
      room: 'testing'
    }
  }
});</code></pre></li></ul></li><li class="suite"><h1>with custom message atts</h1><ul><li class="test pass fast"><h2>records custom message attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  message: {
    room: 'testing'
  }
});</code></pre></li></ul></li><li class="suite"><h1>on event without res argument</h1><ul><li class="test pass fast"><h2>records event without response or other attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: 0,
    event: 'mockEvent',
    instance: {
      name: this.module.name,
      key: this.module.key,
      id: this.module.id
    }
  }
]);</code></pre></li></ul></li><li class="suite"><h1>with invalid custom response atts</h1><ul><li class="test pass fast"><h2>records event without response attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: 0,
    event: 'mockEvent',
    instance: {
      name: this.module.name,
      key: this.module.key,
      id: this.module.id
    }
  }
]);</code></pre></li><li class="test pass fast"><h2>does not throw<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.not.have.threw;</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>.recordAll</h1><ul><li class="suite"><h1>with default event set</h1><ul><li class="test pass fast"><h2>records default events only<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.args.should.eql([['match'], ['mismatch'], ['catch'], ['send']]);</code></pre></li></ul></li><li class="suite"><h1>with custom event set</h1><ul><li class="test pass fast"><h2>records custom events only<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.args.should.eql([['foo'], ['bar']]);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.recordDialogue</h1><ul><li class="suite"><h1>with default event set</h1><ul><li class="test pass fast"><h2>attached listener for default events from dialogue and path<span class="duration">1ms</span></h2><pre><code>var expectedEvents;
expectedEvents = this.transcript.config.events;
expectedEvents.push('path');
return _.keys(pretend.robot._events).should.have.members(expectedEvents);</code></pre></li><li class="test pass fast"><h2>calls the listener when event emited from dialogue path<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.have.calledWith('match', this.dialogue.path);</code></pre></li></ul></li><li class="suite"><h1>with custom event set</h1><ul><li class="test pass fast"><h2>attached listener for default events from dialogue and path<span class="duration">0ms</span></h2><pre><code>return _.keys(pretend.robot._events).should.have.members(['match', 'mismatch', 'end', 'path']);</code></pre></li><li class="test pass fast"><h2>calls the listener when event emited from dialogue<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.have.calledWith('end', this.dialogue);</code></pre></li><li class="test pass fast"><h2>calls the listener when event emited from path<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.have.calledWith('match', this.dialogue.path);</code></pre></li><li class="test pass fast"><h2>does not call with any unconfigured events<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.not.have.calledWith('send', this.dialogue);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.recordScene</h1><ul><li class="test pass fast"><h2>records events emitted by scene, its dialogues and paths<span class="duration">12ms</span></h2><pre><code>return co(function*() {
  var dialogue, records, res, scene, transcript;
  res = pretend.response('tester', 'test');
  removeListeners(pretend.robot);
  transcript = new Transcript(pretend.robot, {
    save: false,
    events: ['enter', 'match', 'send']
  });
  scene = new Scene(pretend.robot);
  transcript.recordScene(scene);
  dialogue = scene.enter(res);
  dialogue.addBranch(/test/, 'response');
  yield dialogue.receive(res);
  records = transcript.recordEvent.args.map(function(record) {
    return _.take(record, 2);
  });
  return records.should.eql([['enter', scene], ['match', dialogue.path], ['send', dialogue]]);
});</code></pre></li></ul></li><li class="suite"><h1>.recordDirector</h1><ul><li class="test pass fast"><h2>attached listeners for director events<span class="duration">0ms</span></h2><pre><code>return _.keys(pretend.robot._events).should.eql(['allow', 'deny']);</code></pre></li><li class="test pass fast"><h2>records events emitted by director<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.args.should.eql([['deny', this.director, this.res], ['allow', this.director, this.res]]);</code></pre></li></ul></li><li class="suite"><h1>.findRecords</h1><ul><li class="suite"><h1>with record subset matcher</h1><ul><li class="test pass fast"><h2>returns records matching given attributes<span class="duration">1ms</span></h2><pre><code>return this.transcript.findRecords({
  message: {
    user: {
      name: 'jon'
    }
  }
}).should.eql([
  {
    time: 0,
    event: 'match',
    instance: {
      key: 'time'
    },
    message: {
      user: {
        name: 'jon'
      },
      text: 'now'
    }
  }, {
    time: 0,
    event: 'match',
    instance: {
      key: 'direction'
    },
    message: {
      user: {
        name: 'jon'
      },
      text: 'left'
    }
  }
]);</code></pre></li></ul></li><li class="suite"><h1>with record subset matcher</h1><ul><li class="test pass fast"><h2>returns only the values at given path<span class="duration">2ms</span></h2><pre><code>return this.transcript.findRecords({
  message: {
    user: {
      name: 'jon'
    }
  }
}, 'message.text').should.eql(['now', 'left']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.findKeyMatches</h1><ul><li class="suite"><h1>with an instance key and capture group</h1><ul><li class="test pass fast"><h2>returns the answers matching the key<span class="duration">1ms</span></h2><pre><code>return this.transcript.findKeyMatches('pick-a-color', 0).should.eql(['blue', 'orange', 'red']);</code></pre></li></ul></li><li class="suite"><h1>with an instance key, user ID and capture group</h1><ul><li class="test pass fast"><h2>returns the answers matching the key for the user<span class="duration">0ms</span></h2><pre><code>return this.transcript.findKeyMatches('pick-a-color', '111', 0).should.eql(['blue', 'orange']);</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Improv</h1><ul><li class="suite"><h1>singleton</h1><ul><li class="test pass fast"><h2>sequential use returns existing instance<span class="duration">1ms</span></h2><pre><code>var improvA, improvB;
improvA = improv.use(pretend.robot);
improvB = improv.use(pretend.robot);
return improvA.should.eql(improvB);</code></pre></li><li class="test pass fast"><h2>instance persists after test robot shutdown<span class="duration">0ms</span></h2><pre><code>return improv.instance.should.exist;</code></pre></li><li class="test pass fast"><h2>use after clear returns new instance<span class="duration">0ms</span></h2><pre><code>var improvA, improvB;
improvA = improv.use(pretend.robot);
improv.reset();
improvB = improv.use(pretend.robot);
return improvA.should.not.eql(improvB);</code></pre></li><li class="test pass fast"><h2>overwrite robot when reused<span class="duration">0ms</span></h2><pre><code>return improv.use(pretend.robot).robot.should.eql(pretend.robot);</code></pre></li><li class="test pass fast"><h2>configuration merges existing config<span class="duration">1ms</span></h2><pre><code>improv.configure({
  foo: 'bar'
});
improv.configure({
  baz: 'qux'
});
return improv.config.should.include({
  foo: 'bar',
  baz: 'qux'
});</code></pre></li></ul></li><li class="suite"><h1>instance</h1><ul><li class="suite"><h1>.use</h1><ul><li class="test pass fast"><h2>attaches response middleware to robot<span class="duration">0ms</span></h2><pre><code>return pretend.robot.responseMiddleware.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>.extend</h1><ul><li class="test pass fast"><h2>stores a function in extensions array<span class="duration">1ms</span></h2><pre><code>var func;
func = sinon.spy();
improv.extend(func);
return improv.extensions.should.eql([func]);</code></pre></li></ul></li><li class="suite"><h1>.remember</h1><ul><li class="test pass fast"><h2>stores data at key in context<span class="duration">0ms</span></h2><pre><code>improv.context.site = {
  name: 'Hub'
};
improv.remember('site', {
  lang: 'en'
});
return improv.context.should.eql({
  site: {
    lang: 'en'
  }
});</code></pre></li><li class="test pass fast"><h2>stores data at path in context<span class="duration">0ms</span></h2><pre><code>improv.context.site = {
  name: 'Hub'
};
improv.remember('site.lang', 'en');
return improv.context.should.eql({
  site: {
    name: 'Hub',
    lang: 'en'
  }
});</code></pre></li></ul></li><li class="suite"><h1>.forget</h1><ul><li class="test pass fast"><h2>removes data at path in context<span class="duration">0ms</span></h2><pre><code>improv.context.site = {
  name: 'Hub',
  lang: 'en'
};
improv.remember('site.lang', 'en');
return improv.context.should.eql({
  site: {
    name: 'Hub',
    lang: 'en'
  }
});</code></pre></li></ul></li><li class="suite"><h1>.mergeData</h1><ul><li class="suite"><h1>with data passed as option</h1><ul><li class="test pass fast"><h2>merges data with user data<span class="duration">1ms</span></h2><pre><code>improv.remember('site', {
  name: 'Hub'
});
return improv.mergeData(pretend.lastListen().message.user).should.eql({
  user: pretend.lastListen().message.user,
  site: {
    name: 'Hub'
  }
});</code></pre></li></ul></li><li class="suite"><h1>with data loaded from brain</h1><ul><li class="test pass fast"><h2>merges data with user data<span class="duration">0ms</span></h2><pre><code>improv.configure({
  save: true
});
pretend.robot.brain.set('improv', {
  site: {
    owner: 'Hubot'
  }
});
return improv.remember('site.name', 'Hub').mergeData(pretend.lastListen().message.user).should.eql({
  user: pretend.lastListen().message.user,
  site: {
    owner: 'Hubot',
    name: 'Hub'
  }
});</code></pre></li></ul></li><li class="suite"><h1>with extension functions added</h1><ul><li class="test pass fast"><h2>merges data with results of functions<span class="duration">1ms</span></h2><pre><code>return improv.extend(function() {
  return {
    custom1: 'foo'
  };
}).extend(function() {
  return {
    custom2: 'bar'
  };
}).mergeData(pretend.lastListen().message.user).should.eql({
  user: pretend.lastListen().message.user,
  custom1: 'foo',
  custom2: 'bar'
});</code></pre></li><li class="test pass fast"><h2>deep merges existing data with extensions<span class="duration">1ms</span></h2><pre><code>return improv.extend(function() {
  return {
    user: {
      type: 'human'
    }
  };
}).mergeData(pretend.lastListen().message.user).should.eql({
  user: _.assignIn(pretend.lastListen().message.user, {
    type: 'human'
  })
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.parse</h1><ul><li class="suite"><h1>with context object</h1><ul><li class="test pass fast"><h2>populates message template with data at path<span class="duration">1ms</span></h2><pre><code>return improv.parse(['welcome to ${ this.site }'], {
  site: 'The Hub'
}).should.eql(['welcome to The Hub']);</code></pre></li></ul></li><li class="suite"><h1>without context</h1><ul><li class="test pass fast"><h2>uses fallback value<span class="duration">0ms</span></h2><pre><code>var context, string;
context = {};
string = 'hey ${ this.user.name }, pay ${ this.product.price }';
return improv.parse([string], context).should.eql(['hey unknown, pay unknown']);</code></pre></li></ul></li><li class="suite"><h1>with partial context</h1><ul><li class="test pass fast"><h2>uses fallback for unknowns<span class="duration">0ms</span></h2><pre><code>var context, string;
context = {
  product: {
    price: '$55'
  }
};
string = 'hey ${ this.user.name }, pay ${ this.product.price }';
return improv.parse([string], context).should.eql(['hey unknown, pay $55']);</code></pre></li><li class="test pass fast"><h2>replaces entire string as configured<span class="duration">1ms</span></h2><pre><code>var context, string;
improv.configure({
  replacement: '¯\\_(ツ)_/¯'
});
context = {
  product: {
    price: '$55'
  }
};
string = 'hey ${ this.user.name }, pay ${ this.product.price }';
return improv.parse([string], context).should.eql(['¯\\_(ツ)_/¯']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.middleware</h1><ul><li class="suite"><h1>with series of hubot sends</h1><ul><li class="test pass fast"><h2>rendered messages with context<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  yield pretend.lastListen().send('hello you');
  yield pretend.lastListen().send('hi ${ this.user.name }');
  return pretend.messages.should.eql([['testing', 'tester', 'test'], ['testing', 'hubot', 'hello you'], ['testing', 'hubot', 'hi tester']]);
});</code></pre></li></ul></li><li class="suite"><h1>with multiple strings</h1><ul><li class="test pass fast"><h2>renders each message with context<span class="duration">1ms</span></h2><pre><code>return co(function*() {
  yield pretend.lastListen().send('testing', 'hi ${ this.user.name }', 'welcome to ${ this.site.name }');
  return pretend.messages.should.eql([['testing', 'tester', 'test'], ['testing', 'hubot', 'testing'], ['testing', 'hubot', 'hi tester'], ['testing', 'hubot', 'welcome to The Hub']]);
});</code></pre></li></ul></li></ul></li></ul></li></ul></li><li class="suite"><h1>Playbook - singleton</h1><ul><li class="test pass fast"><h2>require returns instance<span class="duration">0ms</span></h2><pre><code>return playbook.constructor.name.should.equal('Playbook');</code></pre></li><li class="test pass fast"><h2>instance contains modules<span class="duration">0ms</span></h2><pre><code>return playbook.should.containSubset({
  Dialogue: require('../../src/modules/dialogue'),
  Scene: require('../../src/modules/scene'),
  Director: require('../../src/modules/director'),
  Transcript: require('../../src/modules/transcript'),
  Outline: require('../../src/modules/outline'),
  improv: require('../../src/modules/improv')
});</code></pre></li><li class="test pass fast"><h2>re-require returns the same instance<span class="duration">0ms</span></h2><pre><code>playbook.foo = 'bar';
playbook = require('../../src');
return playbook.foo.should.equal('bar');</code></pre></li><li class="suite"><h1>.reset</h1><ul><li class="test pass fast"><h2>returns new instance<span class="duration">0ms</span></h2><pre><code>playbook.foo = 'bar';
playbook = playbook.reset();
return should.not.exist(playbook.foo);</code></pre></li></ul></li><li class="suite"><h1>.use</h1><ul><li class="test pass fast"><h2>attaches robot<span class="duration">16ms</span></h2><pre><code>pretend.start();
return playbook.use(pretend.robot).should.have.property('robot', pretend.robot);</code></pre></li><li class="test pass fast"><h2>inherits robot log<span class="duration">21ms</span></h2><pre><code>pretend.start();
return playbook.use(pretend.robot).should.have.property('log', pretend.log);</code></pre></li></ul></li></ul></li><li class="suite"><h1>Playbook</h1><ul><li class="suite"><h1>dialogue</h1><ul><li class="test pass fast"><h2>creates Dialogue instance<span class="duration">5ms</span></h2><pre><code>return playbook.dialogue(pretend.response('tester', 'test')).should.be[&quot;instanceof&quot;](playbook.Dialogue);</code></pre></li><li class="test pass fast"><h2>stores it in the dialogues array<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = playbook.dialogue(pretend.response('tester', 'test'));
return playbook.dialogues[0].should.eql(dialogue);</code></pre></li></ul></li><li class="suite"><h1>scene</h1><ul><li class="test pass fast"><h2>makes a Scene :P<span class="duration">0ms</span></h2><pre><code>return playbook.scene().should.be[&quot;instanceof&quot;](playbook.Scene);</code></pre></li><li class="test pass fast"><h2>stores it in the scenes array<span class="duration">0ms</span></h2><pre><code>var scene;
scene = playbook.scene();
return playbook.scenes[0].should.eql(scene);</code></pre></li></ul></li><li class="suite"><h1>.sceneEnter</h1><ul><li class="suite"><h1>without type or args (other than response)</h1><ul><li class="test pass fast"><h2>makes scene with default user type<span class="duration">6ms</span></h2><pre><code>playbook.sceneEnter(pretend.response('tester', 'test', 'testing'));
return playbook.scenes[0].should.be[&quot;instanceof&quot;](playbook.Scene);</code></pre></li><li class="test pass fast"><h2>returns a dialogue<span class="duration">4ms</span></h2><pre><code>return playbook.sceneEnter(pretend.response('tester', 'test')).should.be[&quot;instanceof&quot;](playbook.Dialogue);</code></pre></li><li class="test pass fast"><h2>enters scene, engaging user (stores against id)<span class="duration">5ms</span></h2><pre><code>var dialogue;
dialogue = playbook.sceneEnter(pretend.response('tester', 'test'));
return playbook.scenes[0].engaged[pretend.users.tester.id].should.eql(dialogue);</code></pre></li></ul></li><li class="suite"><h1>with type and options args</h1><ul><li class="test pass fast"><h2>used the given room type<span class="duration">4ms</span></h2><pre><code>var res;
res = pretend.response('tester', 'test', 'testing');
playbook.sceneEnter(res, {
  scope: 'room',
  sendReplies: false
});
return playbook.scenes[0].config.scope.should.equal('room');</code></pre></li><li class="test pass fast"><h2>passed the scene options to dialogue<span class="duration">6ms</span></h2><pre><code>return co(function() {
  var dialogue, res;
  res = pretend.response('tester', 'test', 'testing');
  dialogue = playbook.sceneEnter(res, {
    scope: 'room',
    sendReplies: false
  });
  return dialogue.config.sendReplies.should.equal(false);
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.sceneListen</h1><ul><li class="suite"><h1>with scene args</h1><ul><li class="test pass fast"><h2>creates Scene instance<span class="duration">0ms</span></h2><pre><code>return this.scene.should.be[&quot;instanceof&quot;](playbook.Scene);</code></pre></li><li class="test pass fast"><h2>passed args to the scene<span class="duration">0ms</span></h2><pre><code>return playbook.scene.should.have.calledWith({
  sendReplies: false,
  scope: 'room'
});</code></pre></li><li class="test pass fast"><h2>calls .listen on the scene with type, regex and callback<span class="duration">0ms</span></h2><pre><code>return this.listen.should.have.calledWith('hear', /test/, sinon.match.func);</code></pre></li></ul></li><li class="suite"><h1>without scene args</h1><ul><li class="test pass fast"><h2>creates Scene instance<span class="duration">0ms</span></h2><pre><code>return this.scene.should.be[&quot;instanceof&quot;](playbook.Scene);</code></pre></li><li class="test pass fast"><h2>passed no args to the scene<span class="duration">0ms</span></h2><pre><code>return playbook.scene.getCall(0).should.have.calledWith();</code></pre></li><li class="test pass fast"><h2>calls .listen on the scene with type, regex and callback<span class="duration">0ms</span></h2><pre><code>return this.listen.should.have.calledWith('hear', /test/, sinon.match.func);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.sceneHear</h1><ul><li class="test pass fast"><h2>calls .sceneListen with hear type and any other args<span class="duration">0ms</span></h2><pre><code>var args, ref;
args = [
  'hear', /test/, {
    scope: 'room'
  }, sinon.match.func
];
return (ref = playbook.sceneListen.lastCall.should.have).calledWith.apply(ref, args);</code></pre></li></ul></li><li class="suite"><h1>.sceneRespond</h1><ul><li class="test pass fast"><h2>calls .sceneListen with respond type and any other args<span class="duration">0ms</span></h2><pre><code>var args, ref;
args = [
  'respond', /test/, {
    scope: 'room'
  }, sinon.match.func
];
return (ref = playbook.sceneListen.getCall(0).should.have).calledWith.apply(ref, args);</code></pre></li></ul></li><li class="suite"><h1>.director</h1><ul><li class="test pass fast"><h2>creates and returns director<span class="duration">0ms</span></h2><pre><code>return this.director.should.be[&quot;instanceof&quot;](playbook.Director);</code></pre></li><li class="test pass fast"><h2>stores it in the directors array<span class="duration">0ms</span></h2><pre><code>return playbook.directors[0].should.eql(this.director);</code></pre></li></ul></li><li class="suite"><h1>.transcript</h1><ul><li class="test pass fast"><h2>creates and returns transcript<span class="duration">0ms</span></h2><pre><code>return this.transcript.should.be[&quot;instanceof&quot;](playbook.Transcript);</code></pre></li><li class="test pass fast"><h2>stores it in the transcripts array<span class="duration">0ms</span></h2><pre><code>return playbook.transcripts[0].should.eql(this.transcript);</code></pre></li></ul></li><li class="suite"><h1>.transcribe</h1><ul><li class="test pass fast"><h2>creates transcripts for each module<span class="duration">0ms</span></h2><pre><code>return playbook.transcript.should.have.calledThrice;</code></pre></li><li class="test pass fast"><h2>records events from given instances in brain<span class="duration">0ms</span></h2><pre><code>return pretend.robot.brain.get('transcripts').should.eql([
  {
    time: 0,
    event: 'deny',
    instance: {
      name: 'director'
    }
  }, {
    time: 0,
    event: 'enter',
    instance: {
      name: 'scene'
    }
  }, {
    time: 0,
    event: 'send',
    instance: {
      name: 'dialogue'
    },
    strings: ['test']
  }
]);</code></pre></li></ul></li><li class="suite"><h1>.improvise</h1><ul><li class="test pass fast"><h2>returns the improv singleton<span class="duration">0ms</span></h2><pre><code>return playbook.improvise().should.eql(playbook.improv);</code></pre></li><li class="suite"><h1>with non-improv playbook</h1><ul><li class="test pass fast"><h2>does not parse messages<span class="duration">6ms</span></h2><pre><code>return co(function*() {
  var res;
  res = pretend.response('tester', 'test');
  yield res.send('hello ${this.user.name}');
  return pretend.messages.pop().should.eql(['hubot', 'hello ${this.user.name}']);
});</code></pre></li><li class="test pass fast"><h2>parses after called<span class="duration">8ms</span></h2><pre><code>return co(function*() {
  var res;
  res = pretend.response('tester', 'test');
  playbook.improvise();
  yield res.send('hello ${ this.user.name }');
  return pretend.messages.pop().should.eql(['hubot', 'hello tester']);
});</code></pre></li></ul></li><li class="suite"><h1>using custom data transforms</h1><ul><li class="test pass fast"><h2>parses messages with extended context<span class="duration">5ms</span></h2><pre><code>return co(function*() {
  var res;
  res = pretend.response('tester', 'test');
  playbook.improv.extend(function(data) {
    data.user.name = data.user.name.toUpperCase();
    return data;
  });
  yield res.send('hello ${ this.user.name }');
  return pretend.messages.pop().should.eql(['hubot', 'hello TESTER']);
});</code></pre></li></ul></li><li class="suite"><h1>extended using transcript reocrds</h1><ul><li class="test pass fast"><h2>merge the recorded answers with attribute tags<span class="duration">12ms</span></h2><pre><code>return co(function*() {
  var dialogue, res, transcript;
  dialogue = playbook.sceneEnter(res = pretend.response('tester', 'test'));
  transcript = playbook.transcribe(dialogue, {
    events: ['match']
  });
  playbook.improv.extend(function(data) {
    var userColors, userId;
    userId = data.user.id;
    userColors = transcript.findKeyMatches('fav-color', data.user.id, 0);
    if (userColors.length) {
      return {
        user: {
          favColor: userColors.pop()
        }
      };
    }
  });
  yield dialogue.addPath('what is your favourite colour?', [[/.*/, 'nice! mine is ${ this.user.favColor } too!']], 'fav-color');
  yield pretend.user('tester').send('orange');
  return pretend.messages.should.eql([['hubot', 'what is your favourite colour?'], ['tester', 'orange'], ['hubot', 'nice! mine is orange too!']]);
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.shutdown</h1><ul><li class="test pass fast"><h2>calls .exitAll on scenes<span class="duration">4ms</span></h2><pre><code>var exit, scene;
scene = playbook.scene();
exit = sinon.spy(scene, 'exitAll');
playbook.shutdown();
return exit.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls .end on dialogues<span class="duration">5ms</span></h2><pre><code>var dialogue, end;
dialogue = playbook.dialogue(pretend.response('tester', 'test'));
end = sinon.spy(dialogue, 'end');
playbook.shutdown();
return end.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>.reset</h1><ul><li class="test pass fast"><h2>shuts down<span class="duration">0ms</span></h2><pre><code>sinon.spy(playbook, 'shutdown');
playbook.reset();
return playbook.shutdown.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>returns re-initialised instance<span class="duration">1ms</span></h2><pre><code>playbook = playbook.reset();
return should.not.exist(playbook.robot);</code></pre></li></ul></li></ul></li><ul>
    </div>
    <script>
        var tests = document.getElementsByClassName('test');

        for (var i = 0; i < tests.length; i++) {
            var elem = tests[i];

            if (elem.className.includes('pass')) {
                var head = elem.children[0];

                head.onclick = function () {
                    var code = this.parentElement.children[1];
                    var display = code.style.display;

                    if (display && display === 'block') {
                        code.style.display = 'none';
                    } else {
                        code.style.display = 'block';
                    }
                };
            }
        }
    </script>
</body>
</html>