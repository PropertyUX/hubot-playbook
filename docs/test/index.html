<html>
<head>
    <title>Mocha</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
    @charset "utf-8";

body {
  margin:0;
}

#mocha {
  font: 20px/1.5 "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: 60px 50px;
}

#mocha ul,
#mocha li {
  margin: 0;
  padding: 0;
}

#mocha ul {
  list-style: none;
}

#mocha h1,
#mocha h2 {
  margin: 0;
}

#mocha h1 {
  margin-top: 15px;
  font-size: 1em;
  font-weight: 200;
}

#mocha h1 a {
  text-decoration: none;
  color: inherit;
}

#mocha h1 a:hover {
  text-decoration: underline;
}

#mocha .suite .suite h1 {
  margin-top: 0;
  font-size: .8em;
}

#mocha .hidden {
  display: none;
}

#mocha h2 {
  font-size: 12px;
  font-weight: normal;
  cursor: pointer;
}

#mocha .suite {
  margin-left: 15px;
}

#mocha .test {
  margin-left: 15px;
  overflow: hidden;
}

#mocha .test.pending:hover h2::after {
  content: '(pending)';
  font-family: arial, sans-serif;
}

#mocha .test.pass.medium .duration {
  background: #c09853;
}

#mocha .test.pass.slow .duration {
  background: #b94a48;
}

#mocha .test.pass::before {
  content: '✓';
  font-size: 12px;
  display: block;
  float: left;
  margin-right: 5px;
  color: #00d6b2;
}

#mocha .test.pass .duration {
  font-size: 9px;
  margin-left: 5px;
  padding: 2px 5px;
  color: #fff;
  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  -ms-border-radius: 5px;
  -o-border-radius: 5px;
  border-radius: 5px;
}

#mocha .test.pass.fast .duration {
  display: none;
}

#mocha .test.pending {
  color: #0b97c4;
}

#mocha .test.pending::before {
  content: '◦';
  color: #0b97c4;
}

#mocha .test.fail {
  color: #c00;
}

#mocha .test.fail pre {
  color: black;
}

#mocha .test.fail::before {
  content: '✖';
  font-size: 12px;
  display: block;
  float: left;
  margin-right: 5px;
  color: #c00;
}

#mocha .test pre.error {
  color: #c00;
  max-height: 300px;
  overflow: auto;
}

#mocha .test .html-error {
  overflow: auto;
  color: black;
  line-height: 1.5;
  display: block;
  float: left;
  clear: left;
  font: 12px/1.5 monaco, monospace;
  margin: 5px;
  padding: 15px;
  border: 1px solid #eee;
  max-width: 85%; /*(1)*/
  max-width: -webkit-calc(100% - 42px);
  max-width: -moz-calc(100% - 42px);
  max-width: calc(100% - 42px); /*(2)*/
  max-height: 300px;
  word-wrap: break-word;
  border-bottom-color: #ddd;
  -webkit-box-shadow: 0 1px 3px #eee;
  -moz-box-shadow: 0 1px 3px #eee;
  box-shadow: 0 1px 3px #eee;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}

#mocha .test .html-error pre.error {
  border: none;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-box-shadow: 0;
  -moz-box-shadow: 0;
  box-shadow: 0;
  padding: 0;
  margin: 0;
  margin-top: 18px;
  max-height: none;
}

/**
 * (1): approximate for browsers not supporting calc
 * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)
 *      ^^ seriously
 */
#mocha .test pre {
  display: block;
  float: left;
  clear: left;
  font: 12px/1.5 monaco, monospace;
  margin: 5px;
  padding: 15px;
  border: 1px solid #eee;
  max-width: 85%; /*(1)*/
  max-width: -webkit-calc(100% - 42px);
  max-width: -moz-calc(100% - 42px);
  max-width: calc(100% - 42px); /*(2)*/
  word-wrap: break-word;
  border-bottom-color: #ddd;
  -webkit-box-shadow: 0 1px 3px #eee;
  -moz-box-shadow: 0 1px 3px #eee;
  box-shadow: 0 1px 3px #eee;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}

#mocha .test h2 {
  position: relative;
}

#mocha .test a.replay {
  position: absolute;
  top: 3px;
  right: 0;
  text-decoration: none;
  vertical-align: middle;
  display: block;
  width: 15px;
  height: 15px;
  line-height: 15px;
  text-align: center;
  background: #eee;
  font-size: 15px;
  -webkit-border-radius: 15px;
  -moz-border-radius: 15px;
  border-radius: 15px;
  -webkit-transition:opacity 200ms;
  -moz-transition:opacity 200ms;
  -o-transition:opacity 200ms;
  transition: opacity 200ms;
  opacity: 0.3;
  color: #888;
}

#mocha .test:hover a.replay {
  opacity: 1;
}

#mocha-report.pass .test.fail {
  display: none;
}

#mocha-report.fail .test.pass {
  display: none;
}

#mocha-report.pending .test.pass,
#mocha-report.pending .test.fail {
  display: none;
}
#mocha-report.pending .test.pass.pending {
  display: block;
}

#mocha-error {
  color: #c00;
  font-size: 1.5em;
  font-weight: 100;
  letter-spacing: 1px;
}

#mocha-stats {
  position: fixed;
  top: 15px;
  right: 10px;
  font-size: 12px;
  margin: 0;
  color: #888;
  z-index: 1;
}

#mocha-stats .progress {
  float: right;
  padding-top: 0;

  /**
   * Set safe initial values, so mochas .progress does not inherit these
   * properties from Bootstrap .progress (which causes .progress height to
   * equal line height set in Bootstrap).
   */
  height: auto;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  background-color: initial;
}

#mocha-stats em {
  color: black;
}

#mocha-stats a {
  text-decoration: none;
  color: inherit;
}

#mocha-stats a:hover {
  border-bottom: 1px solid #eee;
}

#mocha-stats li {
  display: inline-block;
  margin: 0 5px;
  list-style: none;
  padding-top: 11px;
}

#mocha-stats canvas {
  width: 40px;
  height: 40px;
}

#mocha code .comment { color: #ddd; }
#mocha code .init { color: #2f6fad; }
#mocha code .string { color: #5890ad; }
#mocha code .keyword { color: #8a6343; }
#mocha code .number { color: #2f6fad; }

@media screen and (max-device-width: 480px) {
  #mocha {
    margin: 60px 0px;
  }

  #mocha #stats {
    position: absolute;
  }
}

    #mocha .test.pass pre {
        display: none;
    }
    #mocha .test:hover h2:after {
        color: #888888;
        content: "(view source)";
        font-family: arial;
        font-size: 12px;
        position: relative;
        right: -10px;
        top: 0;
    }
    </style>
</head>

<body>
    <div id="mocha">
        <ul id="stats">
            <li class="passes">passes: <em>330</em></li>
            <li class="failures">failures: <em>0</em></li>
            <li class="duration">duration: <em>3.1s</em></li>
        </ul>
        <ul id="report"><li class="suite"><h1>Diagnostics</h1><ul><li class="suite"><h1>script sets up a &quot;respond&quot; and a &quot;hear&quot; listener</h1><ul><li class="test pass fast"><h2>robot.respond called once to set up listener<span class="duration">1ms</span></h2><pre><code>return pretend.robot.respond.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>registers a respond listener with RegExp and function<span class="duration">0ms</span></h2><pre><code>return pretend.robot.respond.getCall(0).should.have.calledWithMatch(sinon.match.regexp, sinon.match.func);</code></pre></li><li class="test pass fast"><h2>robot.hear called twice (by respond then directly)<span class="duration">0ms</span></h2><pre><code>return pretend.robot.hear.should.have.calledTwice;</code></pre></li><li class="test pass fast"><h2>registers a hear listener with RegExp and callback (no options)<span class="duration">0ms</span></h2><pre><code>return pretend.robot.hear.getCall(1).should.have.calledWithMatch(sinon.match.regexp, sinon.match.func);</code></pre></li><li class="test pass fast"><h2>robbot has two listeners<span class="duration">0ms</span></h2><pre><code>return pretend.robot.listeners.length.should.equal(2);</code></pre></li></ul></li><li class="suite"><h1>bot responds to a matching message</h1><ul><li class="test pass fast"><h2>bot creates response<span class="duration">0ms</span></h2><pre><code>return pretend.responses.incoming.length.should.equal(1);</code></pre></li><li class="test pass fast"><h2>bot calls listener callback with response<span class="duration">0ms</span></h2><pre><code>return this.cb.should.have.calledWithMatch(sinon.match.instanceOf(pretend.Response));</code></pre></li></ul></li><li class="suite"><h1>bot hears a matching message</h1><ul><li class="test pass fast"><h2>bot creates response<span class="duration">0ms</span></h2><pre><code>return pretend.responses.incoming.length.should.equal(1);</code></pre></li><li class="test pass fast"><h2>bot calls listener callback with response<span class="duration">0ms</span></h2><pre><code>return this.cb.should.have.calledWithMatch(sinon.match.instanceOf(pretend.Response));</code></pre></li></ul></li><li class="suite"><h1>bot responds to its alias</h1><ul><li class="test pass fast"><h2>calls callback with response<span class="duration">0ms</span></h2><pre><code>return this.cb.should.have.calledWithMatch(sinon.match.instanceOf(pretend.Response));</code></pre></li></ul></li><li class="suite"><h1>user asks for version number</h1><ul><li class="test pass fast"><h2>replies to tester with a version number<span class="duration">0ms</span></h2><pre><code>return pretend.messages[1][1].should.match(/@tester .*\d+.\d+.\d+/);</code></pre></li></ul></li><li class="suite"><h1>user asks different ways if Hubot is listening</h1><ul><li class="test pass fast"><h2>replies to each confirming Hubot listening<span class="duration">0ms</span></h2><pre><code>return pretend.messages[1].should.eql(pretend.messages[3]);</code></pre></li></ul></li></ul></li><li class="suite"><h1>Base</h1><ul><li class="suite"><h1>.constructor</h1><ul><li class="suite"><h1>with name, robot and options and key</h1><ul><li class="test pass fast"><h2>stores the robot<span class="duration">0ms</span></h2><pre><code>return this.base.robot.should.eql(pretend.robot);</code></pre></li><li class="test pass fast"><h2>inherits the robot logger<span class="duration">0ms</span></h2><pre><code>return this.base.log.should.eql(pretend.robot.logger);</code></pre></li><li class="test pass fast"><h2>calls configure with options<span class="duration">0ms</span></h2><pre><code>return this.base.configure.should.have.calledWith({
  test: 'testing'
});</code></pre></li><li class="test pass fast"><h2>sets key attribute<span class="duration">0ms</span></h2><pre><code>return this.base.key.should.equal('basey-mcbase');</code></pre></li></ul></li><li class="suite"><h1>without robot</h1><ul><li class="test pass fast"><h2>runs error handler<span class="duration">0ms</span></h2><pre><code>return Base.prototype.error.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>without name</h1><ul><li class="test pass fast"><h2>runs error handler<span class="duration">0ms</span></h2><pre><code>return Base.prototype.error.should.have.calledOnce;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.error</h1><ul><li class="suite"><h1>with an error</h1><ul><li class="test pass fast"><h2>logs an error<span class="duration">0ms</span></h2><pre><code>return this.errLog[0].should.equal('error');</code></pre></li><li class="test pass fast"><h2>emits the error through robot<span class="duration">0ms</span></h2><pre><code>return pretend.robot.emit.should.have.calledWith('error', this.err);</code></pre></li><li class="test pass fast"><h2>threw error<span class="duration">0ms</span></h2><pre><code>return this.base.error.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>with error context string</h1><ul><li class="test pass fast"><h2>logs an error with the module instance ID and context string<span class="duration">0ms</span></h2><pre><code>return this.errLog[1].should.match(new RegExp(this.base.id + &quot;.*something broke&quot;));</code></pre></li><li class="test pass fast"><h2>emits an error through robot<span class="duration">0ms</span></h2><pre><code>return pretend.robot.emit.should.have.calledWith('error');</code></pre></li><li class="test pass fast"><h2>threw error<span class="duration">0ms</span></h2><pre><code>return this.base.error.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>using inherited method for error</h1><ul><li class="test pass fast"><h2>calls inherited method<span class="duration">0ms</span></h2><pre><code>return Base.prototype.error.should.have.calledWith('Throw me an error');</code></pre></li><li class="test pass fast"><h2>threw<span class="duration">0ms</span></h2><pre><code>return this.module.error.should.have.threw;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.configure</h1><ul><li class="test pass fast"><h2>saves new options<span class="duration">0ms</span></h2><pre><code>this.base.configure({
  foo: true
});
return this.base.config.foo.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>overrides existing config<span class="duration">0ms</span></h2><pre><code>this.base.configure({
  setting: false
});
return this.base.config.setting.should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>overrides deep attributes<span class="duration">1ms</span></h2><pre><code>this.base.configure({
  deep: {
    baz: true
  }
});
return this.base.config.should.eql({
  setting: true,
  deep: {
    foo: 'bar',
    baz: true
  }
});</code></pre></li><li class="test pass fast"><h2>throws when not given options<span class="duration">0ms</span></h2><pre><code>try {
  this.base.configure('not an object');
} catch (error) {}
return this.base.configure.should.have.threw;</code></pre></li><li class="suite"><h1>with config inherited from module</h1><ul><li class="test pass fast"><h2>used inherited config<span class="duration">0ms</span></h2><pre><code>return this.module.config.test.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>overwrites inherited when options conflict<span class="duration">0ms</span></h2><pre><code>this.module.configure({
  test: false
});
return this.module.config.test.should.be[&quot;false&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.emit</h1><ul><li class="test pass fast"><h2>emits event via the robot with instance as first arg<span class="duration">0ms</span></h2><pre><code>this.mockEvent = sinon.spy();
pretend.robot.on('mockEvent', this.mockEvent);
this.base = new Base('module', pretend.robot);
this.base.emit('mockEvent', {
  foo: 'bar'
});
return this.mockEvent.should.have.calledWith(this.base, {
  foo: 'bar'
});</code></pre></li></ul></li><li class="suite"><h1>.on</h1><ul><li class="test pass fast"><h2>relays events from robot with instance as first arg<span class="duration">0ms</span></h2><pre><code>this.base = new Base('module', pretend.robot);
this.mockEvent = sinon.spy();
this.base.on('mockEvent', this.mockEvent);
pretend.robot.emit('mockEvent', this.base, {
  foo: 'bar'
});
return this.mockEvent.should.have.calledWith(this.base, {
  foo: 'bar'
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>Path</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>with branches</h1><ul><li class="test pass fast"><h2>creates branches<span class="duration">0ms</span></h2><pre><code>return this.path.addBranch.args.should.eql([[/left/, 'Ok, going left!'], [/right/, 'Ok, going right!']]);</code></pre></li><li class="test pass fast"><h2>is not closed<span class="duration">0ms</span></h2><pre><code>return this.path.closed.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>with a single branch</h1><ul><li class="test pass fast"><h2>creates branches<span class="duration">0ms</span></h2><pre><code>return this.path.addBranch.args.should.eql([[/ok/, 'OK, ok!']]);</code></pre></li><li class="test pass fast"><h2>is not closed<span class="duration">0ms</span></h2><pre><code>return this.path.closed.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>with undefined branches and options</h1><ul><li class="test pass fast"><h2>creates no branches<span class="duration">0ms</span></h2><pre><code>return this.path.addBranch.should.not.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>stays closed<span class="duration">0ms</span></h2><pre><code>return this.path.closed.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>does not throw<span class="duration">0ms</span></h2><pre><code>return this.constructor.should.not.have.threw;</code></pre></li></ul></li><li class="suite"><h1>with bad arguments for branch</h1><ul><li class="test pass fast"><h2>throws<span class="duration">0ms</span></h2><pre><code>return this.constructor.should.have.threw;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.addBranch</h1><ul><li class="suite"><h1>with regex, message and callback</h1><ul><li class="test pass fast"><h2>creates branch object<span class="duration">0ms</span></h2><pre><code>return this.path.branches[0].should.be.an('object');</code></pre></li><li class="test pass fast"><h2>branch has valid regex<span class="duration">0ms</span></h2><pre><code>return this.path.branches[0].regex.should.be[&quot;instanceof&quot;](RegExp);</code></pre></li><li class="test pass fast"><h2>branch has valid handler<span class="duration">1ms</span></h2><pre><code>return this.path.branches[0].handler.should.be.a('function');</code></pre></li><li class="test pass fast"><h2>opens path<span class="duration">0ms</span></h2><pre><code>return this.path.closed.should.be[&quot;false&quot;];</code></pre></li><li class="suite"><h1>when handler called</h1><ul><li class="test pass fast"><h2>sends the message with given dialogue<span class="duration">0ms</span></h2><pre><code>return this.mockDlg.send.should.have.calledWith('foo');</code></pre></li><li class="test pass fast"><h2>calls the callback with response and dialogue<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledWithExactly(this.mockRes, this.mockDlg);</code></pre></li></ul></li></ul></li><li class="suite"><h1>with invalid regex</h1><ul><li class="test pass fast"><h2>throws<span class="duration">0ms</span></h2><pre><code>return this.path.addBranch.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>with invalid message and/or callback</h1><ul><li class="test pass fast"><h2>always throws<span class="duration">0ms</span></h2><pre><code>return this.path.addBranch.should.have.alwaysThrew;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.catch</h1><ul><li class="suite"><h1>with message and callback in config</h1><ul><li class="test pass fast"><h2>returns valid handler<span class="duration">1ms</span></h2><pre><code>return this.path[&quot;catch&quot;].returnValues[0].handler.should.be.a('function');</code></pre></li><li class="suite"><h1>when handler called</h1><ul><li class="test pass fast"><h2>sends the message with given dialogue<span class="duration">0ms</span></h2><pre><code>return this.mockDlg.send.should.have.calledWith('always be catching');</code></pre></li><li class="test pass fast"><h2>calls the callback with response and dialogue<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledWithExactly(this.mockRes, this.mockDlg);</code></pre></li></ul></li></ul></li><li class="suite"><h1>with no catch configured</h1><ul><li class="test pass fast"><h2>returns undefined<span class="duration">0ms</span></h2><pre><code>var path;
path = new Path(pretend.robot);
return should.not.exist(path[&quot;catch&quot;]());</code></pre></li></ul></li></ul></li><li class="suite"><h1>.match</h1><ul><li class="suite"><h1>with string matching branch regex</h1><ul><li class="test pass fast"><h2>returns the matching branch<span class="duration">0ms</span></h2><pre><code>return this.branch.should.eql(this.path.branches[1]);</code></pre></li><li class="test pass fast"><h2>updates match in response object<span class="duration">0ms</span></h2><pre><code>return this.res.match.should.eql('door 2'.match(this.path.branches[1].regex));</code></pre></li><li class="test pass fast"><h2>closes the path<span class="duration">0ms</span></h2><pre><code>return this.path.closed.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>with string matching multiple branches</h1><ul><li class="test pass fast"><h2>returns the first matching branch<span class="duration">0ms</span></h2><pre><code>return this.branch.should.eql(this.path.branches[0]);</code></pre></li><li class="test pass fast"><h2>updates match in response object<span class="duration">0ms</span></h2><pre><code>return this.res.match.should.eql('door 1 and door 2'.match(this.path.branches[0].regex));</code></pre></li><li class="test pass fast"><h2>closes the path<span class="duration">0ms</span></h2><pre><code>return this.path.closed.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>with string matching no branches</h1><ul><li class="test pass fast"><h2>returns undefined<span class="duration">0ms</span></h2><pre><code>return should.not.exist(this.branch);</code></pre></li><li class="test pass fast"><h2>updates match in response object<span class="duration">0ms</span></h2><pre><code>return should.equal(this.res.match, 'door X'.match(this.path.branches.pop().regex));</code></pre></li><li class="test pass fast"><h2>path stays open<span class="duration">0ms</span></h2><pre><code>return this.path.closed.should.be[&quot;false&quot;];</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Dialogue</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="test pass fast"><h2>has null path<span class="duration">0ms</span></h2><pre><code>return should.equal(this.dialogue.path, null);</code></pre></li><li class="test pass fast"><h2>is not ended<span class="duration">1ms</span></h2><pre><code>return this.dialogue.ended.should.be[&quot;false&quot;];</code></pre></li><li class="suite"><h1>with defaults, including an env var</h1><ul><li class="test pass fast"><h2>has timeout value configured from env<span class="duration">0ms</span></h2><pre><code>return this.dialogue.config.timeout.should.equal(500);</code></pre></li><li class="test pass fast"><h2>has timeout text configured<span class="duration">0ms</span></h2><pre><code>return this.dialogue.config.timeoutText.should.be.a('string');</code></pre></li></ul></li><li class="suite"><h1>with timeout options</h1><ul><li class="test pass fast"><h2>uses passed timeout value<span class="duration">0ms</span></h2><pre><code>return this.dialogue.config.timeout.should.equal(555);</code></pre></li><li class="test pass fast"><h2>uses passed timeout text<span class="duration">0ms</span></h2><pre><code>return this.dialogue.config.timeoutText.should.equal('Testing timeout options');</code></pre></li></ul></li></ul></li><li class="suite"><h1>.end</h1><ul><li class="suite"><h1>before messages received</h1><ul><li class="test pass fast"><h2>emits end with self and initial response<span class="duration">0ms</span></h2><pre><code>return this.end.should.have.calledWith(this.dialogue, this.res);</code></pre></li><li class="test pass fast"><h2>sets ended to true<span class="duration">0ms</span></h2><pre><code>return this.dialogue.ended.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.dialogue.end.returnValues.pop().should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>after messages received</h1><ul><li class="test pass fast"><h2>emits end with self and latest response<span class="duration">0ms</span></h2><pre><code>return this.end.should.have.calledWith(this.dialogue, pretend.responses.incoming.pop());</code></pre></li></ul></li><li class="suite"><h1>when timeout is running</h1><ul><li class="test pass fast"><h2>clears the timeout<span class="duration">0ms</span></h2><pre><code>return this.dialogue.clearTimeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>when already ended</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.dialogue.end.returnValues.pop().should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>should only emit end event once<span class="duration">0ms</span></h2><pre><code>return this.end.should.have.calledOnce;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.send</h1><ul><li class="suite"><h1>with config.sendReplies set to false</h1><ul><li class="test pass fast"><h2>sends to the room from original res<span class="duration">0ms</span></h2><pre><code>return pretend.messages.pop().should.eql(['hubot', 'test']);</code></pre></li><li class="test pass fast"><h2>emits send event with original response and sent strings<span class="duration">0ms</span></h2><pre><code>return this.send.should.have.calledWith(this.dialogue, this.res, 'test');</code></pre></li></ul></li><li class="suite"><h1>with config.sendReplies set to true</h1><ul><li class="test pass fast"><h2>sends to the room from original res, responding to the @user<span class="duration">0ms</span></h2><pre><code>return pretend.messages.pop().should.eql(['hubot', '@tester test']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.onTimeout</h1><ul><li class="suite"><h1>default method</h1><ul><li class="test pass fast"><h2>sends timeout message to room<span class="duration">0ms</span></h2><pre><code>return pretend.messages.pop().should.eql(['hubot', this.dialogue.config.timeoutText]);</code></pre></li></ul></li><li class="suite"><h1>method override (as argument)</h1><ul><li class="test pass fast"><h2>calls the override method<span class="duration">0ms</span></h2><pre><code>return this.timeout.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>does not send the default timeout message<span class="duration">0ms</span></h2><pre><code>return pretend.messages.pop().should.not.eql(['hubot', this.dialogue.config.timeoutText]);</code></pre></li></ul></li><li class="suite"><h1>method override (by assignment)</h1><ul><li class="test pass fast"><h2>calls the override method<span class="duration">0ms</span></h2><pre><code>return this.timeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>method override with invalid function</h1><ul><li class="test pass fast"><h2>throws exception<span class="duration">0ms</span></h2><pre><code>return this.override.should.have.threw;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.startTimeout</h1><ul><li class="suite"><h1>with 1 second timeout</h1><ul><li class="test pass fast"><h2>emits timeout event<span class="duration">0ms</span></h2><pre><code>return this.timeout.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>emits end event<span class="duration">0ms</span></h2><pre><code>return this.end.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls .onTimeout<span class="duration">0ms</span></h2><pre><code>return this.dialogue.onTimeout.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls .end<span class="duration">0ms</span></h2><pre><code>return this.dialogue.end.should.have.calledOnce;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.addPath</h1><ul><li class="suite"><h1>with a prompt, branches and key</h1><ul><li class="test pass fast"><h2>returns new Path instance<span class="duration">0ms</span></h2><pre><code>return this.path.should.be[&quot;instanceof&quot;](this.dialogue.Path);</code></pre></li><li class="test pass fast"><h2>passes options to path<span class="duration">0ms</span></h2><pre><code>return this.path.key.should.eql('which-way');</code></pre></li><li class="test pass fast"><h2>sends the prompt<span class="duration">0ms</span></h2><pre><code>return this.dialogue.send.should.have.calledWith('Turn left or right?');</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">0ms</span></h2><pre><code>return this.dialogue.startTimeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>with a prompt and branches (no options)</h1><ul><li class="test pass fast"><h2>returns new Path instance<span class="duration">0ms</span></h2><pre><code>return this.path.should.be[&quot;instanceof&quot;](this.dialogue.Path);</code></pre></li><li class="test pass fast"><h2>sends the prompt<span class="duration">0ms</span></h2><pre><code>return this.dialogue.send.should.have.calledWith('Pick door 1 or 2?');</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">0ms</span></h2><pre><code>return this.dialogue.startTimeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>with branches only</h1><ul><li class="test pass fast"><h2>returns new Path instance<span class="duration">0ms</span></h2><pre><code>return this.path.should.be[&quot;instanceof&quot;](this.dialogue.Path);</code></pre></li><li class="test pass fast"><h2>sends nothing<span class="duration">0ms</span></h2><pre><code>return this.dialogue.send.should.not.have.called;</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">1ms</span></h2><pre><code>return this.dialogue.startTimeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>without branches</h1><ul><li class="test pass fast"><h2>returns new Path instance<span class="duration">0ms</span></h2><pre><code>return this.path.should.be[&quot;instanceof&quot;](this.dialogue.Path);</code></pre></li><li class="test pass fast"><h2>does not start timeout<span class="duration">0ms</span></h2><pre><code>return this.dialogue.startTimeout.should.not.have.called;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.addBranch</h1><ul><li class="suite"><h1>with existing path</h1><ul><li class="test pass fast"><h2>passes branch args on to path.addBranch<span class="duration">1ms</span></h2><pre><code>return this.dialogue.path.addBranch.should.have.calledWith(/foo/, 'foo');</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">0ms</span></h2><pre><code>return this.dialogue.startTimeout.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>when no path exists</h1><ul><li class="test pass fast"><h2>creates a new path<span class="duration">0ms</span></h2><pre><code>return this.dialogue.path.should.be[&quot;instanceof&quot;](this.dialogue.Path);</code></pre></li><li class="test pass fast"><h2>passes branch args on to path.addBranch<span class="duration">1ms</span></h2><pre><code>return this.dialogue.path.addBranch.should.have.calledWith(/foo/, 'foo');</code></pre></li><li class="test pass fast"><h2>starts timeout<span class="duration">0ms</span></h2><pre><code>return this.dialogue.startTimeout.should.have.calledOnce;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.receive</h1><ul><li class="suite"><h1>when already ended</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.dialogue.receive.returnValues[0].should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>does not call the handler<span class="duration">0ms</span></h2><pre><code>return this.handler1.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on matching branch</h1><ul><li class="test pass fast"><h2>clears timeout<span class="duration">1ms</span></h2><pre><code>return this.dialogue.clearTimeout.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>emits match with self and res<span class="duration">0ms</span></h2><pre><code>var ref;
return (ref = this.match.should.have).calledWith.apply(ref, this.matchArgs);</code></pre></li><li class="test pass fast"><h2>ends dialogue<span class="duration">0ms</span></h2><pre><code>return this.dialogue.end.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>on matching branch with message and handler</h1><ul><li class="test pass fast"><h2>calls the created handler<span class="duration">0ms</span></h2><pre><code>return this.handler1.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>sends the message<span class="duration">0ms</span></h2><pre><code>return this.dialogue.send.should.have.calledWith('got 1');</code></pre></li></ul></li><li class="suite"><h1>on matching branch with just a handler</h1><ul><li class="test pass fast"><h2>calls the custom handler<span class="duration">0ms</span></h2><pre><code>return this.handler2.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>does not send any messages<span class="duration">0ms</span></h2><pre><code>return this.dialogue.send.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on matching branch with just a message</h1><ul><li class="test pass fast"><h2>calls the default handler<span class="duration">0ms</span></h2><pre><code>return this.handler3.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>sends the response<span class="duration">0ms</span></h2><pre><code>return this.dialogue.send.should.have.calledWith('got 3');</code></pre></li></ul></li><li class="suite"><h1>on matching branches consecutively</h1><ul><li class="test pass fast"><h2>only processes first match<span class="duration">0ms</span></h2><pre><code>return this.match.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>does not reply to the second<span class="duration">0ms</span></h2><pre><code>return this.dialogue.send.should.not.have.calledWith('got 2');</code></pre></li></ul></li><li class="suite"><h1>on mismatch with catch</h1><ul><li class="test pass fast"><h2>emits catch with self and res<span class="duration">0ms</span></h2><pre><code>var ref;
return (ref = this[&quot;catch&quot;].should.have).calledWith.apply(ref, this.matchArgs);</code></pre></li><li class="test pass fast"><h2>sends the catch message<span class="duration">0ms</span></h2><pre><code>return this.dialogue.send.should.have.calledWith('huh?');</code></pre></li><li class="test pass fast"><h2>does not clear timeout<span class="duration">0ms</span></h2><pre><code>return this.dialogue.clearTimeout.should.not.have.called;</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">0ms</span></h2><pre><code>return this.dialogue.end.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on mismatch without catch</h1><ul><li class="test pass fast"><h2>emits mismatch with self and res<span class="duration">0ms</span></h2><pre><code>var ref;
return (ref = this.mismatch.should.have).calledWith.apply(ref, this.matchArgs);</code></pre></li><li class="test pass fast"><h2>does not clear timeout<span class="duration">0ms</span></h2><pre><code>return this.dialogue.clearTimeout.should.not.have.called;</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">0ms</span></h2><pre><code>return this.dialogue.end.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on matching branch that adds a new branch</h1><ul><li class="test pass fast"><h2>added branches to current path<span class="duration">0ms</span></h2><pre><code>return _.map(this.dialogue.path.branches, function(branch) {
  return branch.regex;
}).should.eql([/foo/, /1/, /2/, /3/, /more/, /4/, /5/]);</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">0ms</span></h2><pre><code>return this.dialogue.end.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>on matching branch that adds a new path</h1><ul><li class="test pass fast"><h2>added new branches to new path, overwrites prev path<span class="duration">0ms</span></h2><pre><code>return _.map(this.dialogue.path.branches, function(branch) {
  return branch.regex;
}).should.eql([/1/, /2/]);</code></pre></li><li class="test pass fast"><h2>does not call end<span class="duration">0ms</span></h2><pre><code>return this.dialogue.end.should.not.have.called;</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Scene</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>without options</h1><ul><li class="test pass fast"><h2>defaults to `user` scope<span class="duration">0ms</span></h2><pre><code>return this.scene.config.scope.should.equal('user');</code></pre></li><li class="test pass fast"><h2>attaches the receive middleware to robot<span class="duration">0ms</span></h2><pre><code>return pretend.robot.receiveMiddleware.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>with options</h1><ul><li class="test pass fast"><h2>stored options in config object<span class="duration">0ms</span></h2><pre><code>return this.scene.config.sendReplies.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>with room scope option</h1><ul><li class="test pass fast"><h2>accepts given room scope<span class="duration">1ms</span></h2><pre><code>return this.scene.config.scope.should.equal('room');</code></pre></li><li class="test pass fast"><h2>stores config with default options for scope<span class="duration">0ms</span></h2><pre><code>return this.scene.config.sendReplies.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>with invalid scope</h1><ul><li class="test pass fast"><h2>throws error when given invalid scope<span class="duration">0ms</span></h2><pre><code>return Scene.prototype.constructor.should.have.threw;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.listen</h1><ul><li class="suite"><h1>with hear type and message matching regex</h1><ul><li class="test pass fast"><h2>registers a robot hear listener with scene as attribute<span class="duration">0ms</span></h2><pre><code>return pretend.robot.hear.should.have.calledWithMatch(sinon.match.regexp, sinon.match.has('scene', this.scene, sinon.match.func));</code></pre></li><li class="test pass fast"><h2>calls the given callback from listener<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>callback should receive res and dialogue<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledWith(this.matchRes, this.matchDlg);</code></pre></li></ul></li><li class="suite"><h1>with respond type and message matching regex</h1><ul><li class="test pass fast"><h2>registers a robot respond listener with scene as attribute<span class="duration">0ms</span></h2><pre><code>return pretend.robot.respond.should.have.calledWithMatch(sinon.match.regexp, sinon.match.has('scene', this.scene, sinon.match.func));</code></pre></li><li class="test pass fast"><h2>calls the given callback from listener<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>callback should receive res and dialogue<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledWith(this.matchRes, this.matchDlg);</code></pre></li></ul></li><li class="suite"><h1>with an invalid type</h1><ul><li class="test pass fast"><h2>throws<span class="duration">0ms</span></h2><pre><code>return this.scene.listen.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>with an invalid regex</h1><ul><li class="test pass fast"><h2>throws<span class="duration">0ms</span></h2><pre><code>return this.scene.listen.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>with an invalid callback</h1><ul><li class="test pass fast"><h2>throws<span class="duration">0ms</span></h2><pre><code>return this.scene.listen.should.have.threw;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.hear</h1><ul><li class="test pass fast"><h2>calls .listen with hear listen type and arguments<span class="duration">0ms</span></h2><pre><code>var args, ref1;
args = ['hear', /test/, sinon.match.func];
return (ref1 = this.scene.listen.getCall(0).should.have).calledWith.apply(ref1, args);</code></pre></li></ul></li><li class="suite"><h1>.respond</h1><ul><li class="test pass fast"><h2>calls .listen with respond listen type and arguments<span class="duration">1ms</span></h2><pre><code>var args, ref1;
args = ['respond', /test/, sinon.match.func];
return (ref1 = this.scene.listen.getCall(0).should.have).calledWith.apply(ref1, args);</code></pre></li></ul></li><li class="suite"><h1>.whoSpeaks</h1><ul><li class="suite"><h1>user scene</h1><ul><li class="test pass fast"><h2>returns the ID of engaged user<span class="duration">0ms</span></h2><pre><code>return this.scene.whoSpeaks.returnValues.pop().should.equal('tester');</code></pre></li></ul></li><li class="suite"><h1>room sceene</h1><ul><li class="test pass fast"><h2>returns the room ID<span class="duration">0ms</span></h2><pre><code>return this.scene.whoSpeaks.returnValues.pop().should.equal('testing');</code></pre></li></ul></li><li class="suite"><h1>direct scene</h1><ul><li class="test pass fast"><h2>returns the concatenated user ID and room ID<span class="duration">0ms</span></h2><pre><code>return this.scene.whoSpeaks.returnValues.pop().should.equal('tester_testing');</code></pre></li></ul></li></ul></li><li class="suite"><h1>.enter</h1><ul><li class="suite"><h1>user scene</h1><ul><li class="test pass fast"><h2>saves engaged Dialogue instance with user ID<span class="duration">0ms</span></h2><pre><code>return this.scene.engaged['tester'].should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li></ul></li><li class="suite"><h1>room scene</h1><ul><li class="test pass fast"><h2>saves engaged Dialogue instance with room key<span class="duration">0ms</span></h2><pre><code>return this.scene.engaged['testing'].should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li></ul></li><li class="suite"><h1>direct scene</h1><ul><li class="test pass fast"><h2>saves engaged Dialogue instance with composite key<span class="duration">0ms</span></h2><pre><code>return this.scene.engaged['tester_testing'].should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li></ul></li><li class="suite"><h1>with timeout options</h1><ul><li class="test pass fast"><h2>passes the options to dialogue config<span class="duration">1ms</span></h2><pre><code>this.dialogue.config.timeout.should.equal(100);
return this.dialogue.config.timeoutText.should.equal('foo');</code></pre></li></ul></li><li class="suite"><h1>dialogue allowed to timeout after branch added</h1><ul><li class="test pass fast"><h2>calls .exit first on &quot;timeout&quot;<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.getCall(0).should.have.calledWith(this.res, 'timeout');</code></pre></li><li class="test pass fast"><h2>calls .exit again on &quot;incomplete&quot;<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.getCall(1).should.have.calledWith(this.res, 'incomplete');</code></pre></li></ul></li><li class="suite"><h1>dialogue completed (by message matching branch)</h1><ul><li class="test pass fast"><h2>calls .exit once only<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls .exit once with last (matched) res and &quot;complete&quot;<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.should.have.calledWith(this.dialogue.res, 'complete');</code></pre></li></ul></li><li class="suite"><h1>re-enter currently engaged participants</h1><ul><li class="test pass fast"><h2>returns undefined the second time<span class="duration">0ms</span></h2><pre><code>return should.not.exist(this.scene.enter.returnValues[1]);</code></pre></li></ul></li><li class="suite"><h1>re-enter previously engaged participants</h1><ul><li class="test pass fast"><h2>returns Dialogue instance (as per normal)<span class="duration">0ms</span></h2><pre><code>return this.dialogueB.should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.exit</h1><ul><li class="suite"><h1>with user in scene, called manually</h1><ul><li class="test pass fast"><h2>does not call onTimeout on dialogue<span class="duration">0ms</span></h2><pre><code>return this.timeout.should.not.have.called;</code></pre></li><li class="test pass fast"><h2>removes the dialogue instance from engaged array<span class="duration">0ms</span></h2><pre><code>return should.not.exist(this.scene.engaged['tester']);</code></pre></li><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.returnValues.pop().should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>dialogue does not continue receiving after scene exit<span class="duration">0ms</span></h2><pre><code>return this.dialogue.receive.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>with user in scene, called from events</h1><ul><li class="test pass fast"><h2>gets called twice (on timeout and end)<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.should.have.calledTwice;</code></pre></li><li class="test pass fast"><h2>returns true the first time<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.getCall(0).should.have.returned(true);</code></pre></li><li class="test pass fast"><h2>returns false the second time (because already disengaged)<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.getCall(1).should.have.returned(false);</code></pre></li></ul></li><li class="suite"><h1>user not in scene, called manually</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.scene.exit.returnValues.pop().should.be[&quot;false&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.exitAll</h1><ul><li class="suite"><h1>with two users in scene</h1><ul><li class="test pass fast"><h2>created two dialogues<span class="duration">0ms</span></h2><pre><code>this.dialogueA.should.be[&quot;instanceof&quot;](Dialogue);
return this.dialogueB.should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li><li class="test pass fast"><h2>calls clearTimeout on both dialogues<span class="duration">0ms</span></h2><pre><code>this.dialogueA.clearTimeout.should.have.calledOnce;
return this.dialogueB.clearTimeout.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>has no remaining engaged dialogues<span class="duration">0ms</span></h2><pre><code>return this.scene.engaged.length.should.equal(0);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.getDialogue</h1><ul><li class="suite"><h1>with user in scene</h1><ul><li class="test pass fast"><h2>returns the matching dialogue<span class="duration">0ms</span></h2><pre><code>return this.dialogueB.should.eql(this.dialogueA);</code></pre></li></ul></li><li class="suite"><h1>no user in scene</h1><ul><li class="test pass fast"><h2>returns undefined<span class="duration">0ms</span></h2><pre><code>return should.not.exist(this.dialogue);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.inDialogue</h1><ul><li class="suite"><h1>in engaged user scene</h1><ul><li class="test pass fast"><h2>returns true with user ID<span class="duration">1ms</span></h2><pre><code>return this.userEngaged.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>returns false with room name<span class="duration">0ms</span></h2><pre><code>return this.roomEngaged.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>no participants in scene</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.userEngaged.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>room scene, in scene</h1><ul><li class="test pass fast"><h2>returns true with roomname<span class="duration">0ms</span></h2><pre><code>return this.roomEngaged.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>returns false with user ID<span class="duration">0ms</span></h2><pre><code>return this.userEngaged.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>direct scene, in scene</h1><ul><li class="test pass fast"><h2>returns true with userID_roomID<span class="duration">0ms</span></h2><pre><code>return this.directEngaged.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>returns false with roomname<span class="duration">0ms</span></h2><pre><code>return this.roomEngaged.should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>returns false with user ID<span class="duration">0ms</span></h2><pre><code>return this.userEngaged.should.be[&quot;false&quot;];</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Director</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>without optional args</h1><ul><li class="test pass fast"><h2>has empty array names<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql([]);</code></pre></li></ul></li><li class="suite"><h1>with authorise function</h1><ul><li class="test pass fast"><h2>stores the given function as its authorise method<span class="duration">0ms</span></h2><pre><code>return this.director.authorise = this.authorise;</code></pre></li></ul></li><li class="suite"><h1>with options (denied reply and key string)</h1><ul><li class="test pass fast"><h2>stores passed options in config<span class="duration">0ms</span></h2><pre><code>return this.director.config.deniedReply.should.equal(&quot;DENIED!&quot;);</code></pre></li></ul></li><li class="suite"><h1>with env var for config</h1><ul><li class="test pass fast"><h2>has default config with env inherited<span class="duration">0ms</span></h2><pre><code>return this.director.config.should.eql({
  type: 'whitelist',
  scope: 'username',
  deniedReply: &quot;403 Sorry.&quot;
});</code></pre></li></ul></li><li class="suite"><h1>with env var for names</h1><ul><li class="suite"><h1>whitelist type, username scope</h1><ul><li class="test pass fast"><h2>stores the whitelisted usernames from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Emmanuel']);</code></pre></li></ul></li><li class="suite"><h1>whitelist type, room scope</h1><ul><li class="test pass fast"><h2>stores the whitelisted rooms from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Capital']);</code></pre></li></ul></li><li class="suite"><h1>blacklist type, username scope</h1><ul><li class="test pass fast"><h2>stores the blacklisted usernames from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Winston', 'Julia', 'Syme']);</code></pre></li></ul></li><li class="suite"><h1>blacklist type, room scope</h1><ul><li class="test pass fast"><h2>stores the blacklisted rooms from env<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['Labour']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>with invalid option for type</h1><ul><li class="test pass fast"><h2>should throw error<span class="duration">0ms</span></h2><pre><code>return Director.prototype.constructor.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>with invalid option for scope</h1><ul><li class="test pass fast"><h2>should throw error<span class="duration">0ms</span></h2><pre><code>return Director.prototype.constructor.should.have.threw;</code></pre></li></ul></li><li class="suite"><h1>without key, with authorise function and options</h1><ul><li class="test pass fast"><h2>uses options<span class="duration">0ms</span></h2><pre><code>return this.director.config.scope.should.equal('room');</code></pre></li><li class="test pass fast"><h2>uses authorise function<span class="duration">0ms</span></h2><pre><code>return this.director.authorise.should.eql(this.authorise);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.add</h1><ul><li class="suite"><h1>given array of names</h1><ul><li class="test pass fast"><h2>stores them in the names array<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['pema', 'nima']);</code></pre></li></ul></li><li class="suite"><h1>given single name</h1><ul><li class="test pass fast"><h2>stores it in the names array<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['pema']);</code></pre></li></ul></li><li class="suite"><h1>given array of names, some existing</h1><ul><li class="test pass fast"><h2>adds any missing, not duplicating existing<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['yeon', 'juan', 'pema']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.remove</h1><ul><li class="suite"><h1>given array of names</h1><ul><li class="test pass fast"><h2>removes them from the names array<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['yeon', 'juan']);</code></pre></li></ul></li><li class="suite"><h1>with single name</h1><ul><li class="test pass fast"><h2>removes it from the names array<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['yeon', 'juan', 'nima']);</code></pre></li></ul></li><li class="suite"><h1>with array names, some not existing</h1><ul><li class="test pass fast"><h2>removes any missing, ignoring others<span class="duration">0ms</span></h2><pre><code>return this.director.names.should.eql(['yeon']);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.isAllowed</h1><ul><li class="suite"><h1>whitelist without authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>blacklist without authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;true&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;true&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>whitelist with authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>calls authorise function with username and res<span class="duration">0ms</span></h2><pre><code>return this.authorise.should.have.calledWith('tester', this.res);</code></pre></li><li class="test pass fast"><h2>returns value of authorise function<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal('AUTHORISE');</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;true&quot;];</code></pre></li><li class="test pass fast"><h2>does not call authorise function<span class="duration">0ms</span></h2><pre><code>return this.authorise.should.not.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns value of authorise function<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal('AUTHORISE');</code></pre></li></ul></li></ul></li><li class="suite"><h1>blacklist with authorise function</h1><ul><li class="suite"><h1>no list</h1><ul><li class="test pass fast"><h2>calls authorise function with username and res<span class="duration">0ms</span></h2><pre><code>return this.authorise.should.have.calledWith('tester', this.res);</code></pre></li><li class="test pass fast"><h2>returns value of authorise function<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal('AUTHORISE');</code></pre></li></ul></li><li class="suite"><h1>has list, username on list</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li><li class="test pass fast"><h2>does not call authorise function<span class="duration">0ms</span></h2><pre><code>return this.authorise.should.not.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>has list, username not on list</h1><ul><li class="test pass fast"><h2>returns value of authorise function<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal('AUTHORISE');</code></pre></li></ul></li></ul></li><li class="suite"><h1>room scope, blacklist room</h1><ul><li class="test pass fast"><h2>returns false<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>room scope, whitelist room</h1><ul><li class="test pass fast"><h2>returns true<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;true&quot;];</code></pre></li></ul></li></ul></li><li class="suite"><h1>.process</h1><ul><li class="suite"><h1>denied user</h1><ul><li class="test pass fast"><h2>calls .isAllowed to determine if user is allowed or denied<span class="duration">0ms</span></h2><pre><code>return this.director.isAllowed.should.have.calledWith(this.res);</code></pre></li><li class="test pass fast"><h2>returns the same result as .isAllowed<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal(this.director.isAllowed.returnValues.pop());</code></pre></li></ul></li><li class="suite"><h1>denied with denied reply value</h1><ul><li class="test pass fast"><h2>calls response method reply with reply value<span class="duration">0ms</span></h2><pre><code>return this.reply.should.have.calledWith(this.director.config.deniedReply);</code></pre></li></ul></li><li class="suite"><h1>denied without denied reply value</h1><ul><li class="test pass fast"><h2>does not call response reply method<span class="duration">0ms</span></h2><pre><code>return this.reply.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>allowed user</h1><ul><li class="test pass fast"><h2>calls .isAllowed to determine if user is allowed or denied<span class="duration">0ms</span></h2><pre><code>return this.director.isAllowed.should.have.calledWith(this.res);</code></pre></li><li class="test pass fast"><h2>returns the same value as .isAllowed<span class="duration">0ms</span></h2><pre><code>return this.result.should.equal(this.director.isAllowed.returnValues.pop());</code></pre></li><li class="test pass fast"><h2>does not send denied reply<span class="duration">0ms</span></h2><pre><code>return this.reply.should.not.have.called;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.directMatch</h1><ul><li class="suite"><h1>allowed user sending message matching directed match</h1><ul><li class="test pass fast"><h2>calls .process with response to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>triggers match callback normally<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>denied user sending message matching directed match</h1><ul><li class="test pass fast"><h2>calls .process to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>prevents match callback from triggering<span class="duration">0ms</span></h2><pre><code>return this.callback.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>denied user sending unmatched message</h1><ul><li class="test pass fast"><h2>does not call .process because middleware did not match<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.not.have.called;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.directListener</h1><ul><li class="suite"><h1>allowed user sending message matching directed listener id</h1><ul><li class="test pass fast"><h2>calls .process with response to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>triggers match callback normally<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>denied user sending message matching directed match</h1><ul><li class="test pass fast"><h2>calls .process to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>prevents match callback from triggering<span class="duration">0ms</span></h2><pre><code>return this.callback.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>denied user sending unmatched message</h1><ul><li class="test pass fast"><h2>does not call .process because middleware did not match<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.not.have.called;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.directScene</h1><ul><li class="test pass fast"><h2>calls .directListener to control access to scene listeners<span class="duration">0ms</span></h2><pre><code>return this.director.directListener.should.have.calledWith(this.scene.id);</code></pre></li><li class="suite"><h1>scene enter manually called (user allowed)</h1><ul><li class="test pass fast"><h2>calls .process to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledWith(this.res);</code></pre></li><li class="test pass fast"><h2>allowed the .enter method, returning a Dialogue object<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;instanceof&quot;](Dialogue);</code></pre></li></ul></li><li class="suite"><h1>scene enter manually called (user denied)</h1><ul><li class="test pass fast"><h2>calls .process to perform access checks and reply<span class="duration">0ms</span></h2><pre><code>return this.director.process.should.have.calledWith(this.res);</code></pre></li><li class="test pass fast"><h2>preempts scene.enter, returning false instead<span class="duration">0ms</span></h2><pre><code>return this.result.should.be[&quot;false&quot;];</code></pre></li></ul></li><li class="suite"><h1>allowed user sends message matching scene listener</h1><ul><li class="test pass fast"><h2>triggers the scene enter method<span class="duration">0ms</span></h2><pre><code>return this.enter.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls the scene listener callback<span class="duration">0ms</span></h2><pre><code>return this.callback.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>denied user sends message matching scene listener</h1><ul><li class="test pass fast"><h2>prevents the scene enter method<span class="duration">0ms</span></h2><pre><code>return this.enter.should.not.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>does not call the scene listener callback<span class="duration">0ms</span></h2><pre><code>return this.callback.should.not.have.calledOnce;</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Transcript</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="suite"><h1>with saving enabled (default)</h1><ul><li class="test pass fast"><h2>uses brain for record keeping<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: this.now,
    event: 'test'
  }
]);</code></pre></li></ul></li><li class="suite"><h1>with saving disabled</h1><ul><li class="test pass fast"><h2>keeps records in a new empty array<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([]);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.recordEvent</h1><ul><li class="suite"><h1>emitted from Hubot/brain</h1><ul><li class="test pass fast"><h2>records event &quot;other&quot; data<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: this.now,
    event: 'mockEvent',
    other: [
      {
        test: 'data'
      }
    ]
  }
]);</code></pre></li></ul></li><li class="suite"><h1>emitted from Playbook module</h1><ul><li class="suite"><h1>with default config</h1><ul><li class="test pass fast"><h2>records default instance attributes<span class="duration">1ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  instance: {
    name: this.module.name,
    key: this.module.key,
    id: this.module.id
  }
});</code></pre></li><li class="test pass fast"><h2>records default response attributes<span class="duration">1ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  response: {
    match: this.res.match
  }
});</code></pre></li><li class="test pass fast"><h2>records default message attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  message: {
    user: {
      id: this.res.message.user.id,
      name: this.res.message.user.name
    },
    room: this.res.message.room,
    text: this.res.message.text
  }
});</code></pre></li><li class="test pass fast"><h2>emits new record once created<span class="duration">0ms</span></h2><pre><code>return this.record.should.have.calledWith(this.transcript, this.transcript.records.pop());</code></pre></li></ul></li><li class="suite"><h1>with transcript key</h1><ul><li class="test pass fast"><h2>records event with key property<span class="duration">1ms</span></h2><pre><code>return this.transcript.records[0].should.have.property('key', 'test-key');</code></pre></li></ul></li><li class="suite"><h1>with custom instance atts</h1><ul><li class="test pass fast"><h2>records custom instance attributes<span class="duration">1ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  instance: {
    name: this.module.name,
    config: {
      scope: this.module.config.scope
    }
  }
});</code></pre></li></ul></li><li class="suite"><h1>with custom response atts</h1><ul><li class="test pass fast"><h2>records custom response attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  response: {
    message: {
      room: 'testing'
    }
  }
});</code></pre></li></ul></li><li class="suite"><h1>with custom message atts</h1><ul><li class="test pass fast"><h2>records custom message attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records[0].should.containSubset({
  message: {
    room: 'testing'
  }
});</code></pre></li></ul></li><li class="suite"><h1>on event without res argument</h1><ul><li class="test pass fast"><h2>records event without response or other attributes<span class="duration">1ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: this.now,
    event: 'mockEvent',
    instance: {
      name: this.module.name,
      key: this.module.key,
      id: this.module.id
    }
  }
]);</code></pre></li></ul></li><li class="suite"><h1>with invalid custom response atts</h1><ul><li class="test pass fast"><h2>records event without response attributes<span class="duration">0ms</span></h2><pre><code>return this.transcript.records.should.eql([
  {
    time: this.now,
    event: 'mockEvent',
    instance: {
      name: this.module.name,
      key: this.module.key,
      id: this.module.id
    }
  }
]);</code></pre></li><li class="test pass fast"><h2>does not throw<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.not.have.threw;</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>.recordAll</h1><ul><li class="suite"><h1>with default event set</h1><ul><li class="test pass fast"><h2>records default events only<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.args.should.eql([['match'], ['mismatch'], ['catch'], ['send']]);</code></pre></li></ul></li><li class="suite"><h1>with custom event set</h1><ul><li class="test pass fast"><h2>records custom events only<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.args.should.eql([['foo'], ['bar']]);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.recordDialogue</h1><ul><li class="suite"><h1>with default event set</h1><ul><li class="test pass fast"><h2>attached listener for default events from dialogue<span class="duration">0ms</span></h2><pre><code>return _.keys(pretend.robot.events._events).should.eql(this.transcript.config.events);</code></pre></li><li class="test pass fast"><h2>calls the listener when event emmited from dialogue<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.have.calledWith('match', this.dialogue);</code></pre></li></ul></li><li class="suite"><h1>with custom event set</h1><ul><li class="test pass fast"><h2>attached listener for default events from dialogue<span class="duration">0ms</span></h2><pre><code>return _.keys(pretend.robot.events._events).should.eql(['match', 'mismatch']);</code></pre></li><li class="test pass fast"><h2>calls the listener when event emmited from dialogue<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.have.calledWith('match', this.dialogue);</code></pre></li><li class="test pass fast"><h2>does not call with any unconfigured events<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.should.not.have.calledWith('send', this.dialogue);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.recordScene</h1><ul><li class="test pass fast"><h2>attached listener for scene and dialogue events<span class="duration">0ms</span></h2><pre><code>return _.keys(pretend.robot.events._events).should.containSubset(['enter', 'exit', 'match']);</code></pre></li><li class="test pass fast"><h2>records events emitted by scene and its dialogues<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.args.should.eql([['enter', this.scene, this.res], ['match', this.dialogue, this.res]]);</code></pre></li></ul></li><li class="suite"><h1>.recordDirector</h1><ul><li class="test pass fast"><h2>attached listeners for director events<span class="duration">0ms</span></h2><pre><code>return _.keys(pretend.robot.events._events).should.eql(['allow', 'deny']);</code></pre></li><li class="test pass fast"><h2>records events emitted by director<span class="duration">0ms</span></h2><pre><code>return this.transcript.recordEvent.args.should.eql([['deny', this.director, this.res], ['allow', this.director, this.res]]);</code></pre></li></ul></li><li class="suite"><h1>.findRecords</h1><ul><li class="suite"><h1>with record subset matcher</h1><ul><li class="test pass fast"><h2>returns records matching given attributes<span class="duration">2ms</span></h2><pre><code>return this.transcript.findRecords({
  message: {
    user: {
      name: 'jon'
    }
  }
}).should.eql([
  {
    time: 0,
    event: 'match',
    instance: {
      key: 'time'
    },
    message: {
      user: {
        name: 'jon',
        text: 'now'
      }
    }
  }, {
    time: 0,
    event: 'match',
    instance: {
      key: 'direction'
    },
    message: {
      user: {
        name: 'jon',
        text: 'left'
      }
    }
  }
]);</code></pre></li></ul></li><li class="suite"><h1>with record subset and path matcher</h1><ul><li class="test pass fast"><h2>returns only the values at path<span class="duration">1ms</span></h2><pre><code>return this.transcript.findRecords({
  message: {
    user: {
      name: 'jon'
    }
  }
}, 'message.user.text').should.eql(['now', 'left']);</code></pre></li></ul></li></ul></li></ul></li><li class="suite"><h1>Improv</h1><ul><li class="suite"><h1>singleton</h1><ul><li class="suite"><h1>without args</h1><ul><li class="test pass fast"><h2>returns existing instance<span class="duration">0ms</span></h2><pre><code>return Improv.get(pretend.robot).should.eql(this.improv);</code></pre></li><li class="test pass fast"><h2>still have the same robot<span class="duration">0ms</span></h2><pre><code>return Improv.get(pretend.robot).robot.should.eql(pretend.robot);</code></pre></li></ul></li><li class="suite"><h1>with args</h1><ul><li class="test pass fast"><h2>returns existing instance with new configuration<span class="duration">1ms</span></h2><pre><code>return Improv.get(pretend.robot, {
  foo: 'bar'
}).should.eql(this.improv).and.have.deep.property('config.foo');</code></pre></li></ul></li></ul></li><li class="suite"><h1>instance</h1><ul><li class="suite"><h1>constructor</h1><ul><li class="test pass fast"><h2>attaches response middleware to robot<span class="duration">0ms</span></h2><pre><code>return pretend.robot.responseMiddleware.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>.reset</h1><ul><li class="test pass fast"><h2>restarts with defaults<span class="duration">0ms</span></h2><pre><code>this.improv.config = null;
this.improv.extensions = null;
this.improv.reset();
this.improv.config.should.not.be[&quot;null&quot;];
return this.improv.extensions.should.not.be[&quot;null&quot;];</code></pre></li></ul></li><li class="suite"><h1>.configure</h1><ul><li class="test pass fast"><h2>configures and returns singleton<span class="duration">0ms</span></h2><pre><code>var result;
result = this.improv.configure({
  admins: ['Marius', 'Sulla']
});
return result.should.eql(this.improv).and.have.deep.property('config.admins');</code></pre></li></ul></li><li class="suite"><h1>.extend</h1><ul><li class="test pass fast"><h2>stores a function in extensions array<span class="duration">0ms</span></h2><pre><code>var func;
func = sinon.spy();
this.improv.extend(func);
return this.improv.extensions.should.eql([func]);</code></pre></li></ul></li><li class="suite"><h1>.mergeData</h1><ul><li class="suite"><h1>with data passed as option</h1><ul><li class="test pass fast"><h2>merges data with user data<span class="duration">1ms</span></h2><pre><code>return this.improv.configure({
  save: false,
  data: {
    instance: {
      name: 'Hub'
    }
  }
}).mergeData(this.res.message.user).should.eql({
  user: this.res.message.user,
  instance: {
    name: 'Hub'
  }
});</code></pre></li></ul></li><li class="suite"><h1>with data loaded from brain</h1><ul><li class="test pass fast"><h2>merges data with user data<span class="duration">1ms</span></h2><pre><code>pretend.robot.brain.set('improv', {
  instance: {
    owner: 'Hubot'
  }
});
return this.improv.configure({
  data: {
    instance: {
      name: 'The Hub'
    }
  }
}).mergeData(this.res.message.user).should.eql({
  user: this.res.message.user,
  instance: {
    owner: 'Hubot',
    name: 'The Hub'
  }
});</code></pre></li></ul></li><li class="suite"><h1>with extension functions added</h1><ul><li class="test pass fast"><h2>merges data with results of functions<span class="duration">1ms</span></h2><pre><code>return this.improv.extend(function() {
  return {
    custom1: 'foo'
  };
}).extend(function() {
  return {
    custom2: 'bar'
  };
}).mergeData(this.res.message.user).should.eql({
  user: this.res.message.user,
  custom1: 'foo',
  custom2: 'bar'
});</code></pre></li><li class="test pass fast"><h2>deep merges existing data with extensions<span class="duration">0ms</span></h2><pre><code>this.improv.reset();
return this.improv.extend(function() {
  return {
    user: {
      type: 'human'
    }
  };
}).mergeData(this.res.message.user).should.eql({
  user: _.assignIn(this.res.message.user, {
    type: 'human'
  })
});</code></pre></li></ul></li></ul></li><li class="suite"><h1>.parse</h1><ul><li class="suite"><h1>with deep context object</h1><ul><li class="test pass fast"><h2>populates message template with data at path<span class="duration">10ms</span></h2><pre><code>return this.improv.parse(['welcome to {{ instance }}'], {
  instance: 'The Hub'
}).should.eql(['welcome to The Hub']);</code></pre></li></ul></li><li class="suite"><h1>with intl disabled</h1><ul><li class="test pass fast"><h2>returns default values<span class="duration">24ms</span></h2><pre><code>return this.improv.parse(['{{ formatDate date }}'], {
  date: new Date('2001-01-31')
}).should.eql(['31/01/2001']);</code></pre></li></ul></li><li class="suite"><h1>with formats configured</h1><ul><li class="test pass fast"><h2>renders using configured formats<span class="duration">2ms</span></h2><pre><code>return this.improv.configure({
  formats: {
    date: {
      short: {
        day: 'numeric',
        month: 'long',
        year: 'numeric'
      }
    }
  }
}).parse(['{{formatDate date &quot;short&quot;}}'], {
  date: new Date('2001-01-31')
}).should.eql(['31 January 2001']);</code></pre></li></ul></li><li class="suite"><h1>with locales and (possibly) ICU data</h1><ul><li class="test pass fast"><h2>renders relative values if ICU data loaded<span class="duration">2ms</span></h2><pre><code>var localDate;
this.improv.configure({
  locales: 'fr-FR',
  formats: {
    date: {
      short: {
        day: 'numeric',
        month: 'long',
        year: 'numeric'
      }
    }
  }
});
localDate = this.improv.parse(['{{formatDate date &quot;short&quot;}}'], {
  date: new Date('2001-01-31')
});
console.log(&quot;\tICU &quot; + this.improv.icuInfo + &quot; (e.g. &quot; + localDate + &quot;)&quot;);
if (!this.improv.icu.icu_small) {
  return localDate.should.eql(['31 janvier 2001']);
} else {
  return localDate.should.eql(['31 January 2001']);
}</code></pre></li></ul></li></ul></li><li class="suite"><h1>.middleware</h1><ul><li class="suite"><h1>with series of hubot sends</h1><ul><li class="test pass fast"><h2>gets called whenever robot sends<span class="duration">0ms</span></h2><pre><code>return this.improv.middleware.should.have.calledTwice;</code></pre></li></ul></li><li class="suite"><h1>when message has no tempalte tags</h1><ul><li class="test pass fast"><h2>does not parse strings<span class="duration">0ms</span></h2><pre><code>return this.improv.parse.should.not.have.called;</code></pre></li></ul></li><li class="suite"><h1>when message has template tags</h1><ul><li class="test pass fast"><h2>parses strings<span class="duration">0ms</span></h2><pre><code>return this.improv.parse.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>merges data with user object<span class="duration">0ms</span></h2><pre><code>return this.improv.mergeData.should.have.calledWith(this.res.message.user);</code></pre></li><li class="test pass fast"><h2>sends the merged strings to room<span class="duration">0ms</span></h2><pre><code>return pretend.messages.slice(2).should.eql([['testing', 'hubot', 'hi tester'], ['testing', 'hubot', 'welcome to The Hub']]);</code></pre></li></ul></li></ul></li></ul></li></ul></li><li class="suite"><h1>Playbook - singleton</h1><ul><li class="suite"><h1>require as property</h1><ul><li class="test pass slow"><h2>returns instance<span class="duration">85ms</span></h2><pre><code>playbook = require('../../src').playbook;
return playbook.should.have.property('transcripts');</code></pre></li></ul></li><li class="suite"><h1>require with get method</h1><ul><li class="test pass fast"><h2>returns instance<span class="duration">0ms</span></h2><pre><code>playbook = require('../../src').get();
return playbook.should.have.property('transcripts');</code></pre></li></ul></li><li class="suite"><h1>require and use robot in one</h1><ul><li class="test pass fast"><h2>returns instance initialised with bot<span class="duration">6ms</span></h2><pre><code>pretend.startup();
playbook = require('../../src').use(pretend.robot);
return playbook.should.have.property('log');</code></pre></li></ul></li><li class="suite"><h1>re-require instance</h1><ul><li class="test pass fast"><h2>returns the same instance<span class="duration">1ms</span></h2><pre><code>playbook = require('../../src').playbook;
playbook.foo = 'bar';
playbook = require('../../src').playbook;
return playbook.foo.should.equal('bar');</code></pre></li></ul></li><li class="suite"><h1>require a recreated instance</h1><ul><li class="test pass fast"><h2>creates a new instance<span class="duration">0ms</span></h2><pre><code>playbook = require('../../src').get();
playbook.foo = 'bar';
playbook = require('../../src').create();
return should.not.exist(playbook.foo);</code></pre></li></ul></li></ul></li><li class="suite"><h1>Playbook</h1><ul><li class="suite"><h1>.use</h1><ul><li class="suite"><h1>first time with robot</h1><ul><li class="test pass fast"><h2>attaches playbook to bot<span class="duration">0ms</span></h2><pre><code>playbook.use(pretend.robot);
return pretend.robot.playbook.should.eql(playbook);</code></pre></li></ul></li><li class="suite"><h1>used again with robot</h1><ul><li class="test pass fast"><h2>returns the robots existing Playbook<span class="duration">0ms</span></h2><pre><code>playbook.use(pretend.robot);
pretend.robot.playbook.foo = 'bar';
playbook.use(pretend.robot);
return pretend.robot.playbook.foo.should.equal('bar');</code></pre></li></ul></li></ul></li><li class="suite"><h1>.dialogue</h1><ul><li class="test pass fast"><h2>creates Dialogue instance<span class="duration">0ms</span></h2><pre><code>return this.dialogue.should.be[&quot;instanceof&quot;](playbook.Dialogue);</code></pre></li><li class="test pass fast"><h2>does not throw any errors<span class="duration">0ms</span></h2><pre><code>return playbook.dialogue.should.not.have.threw;</code></pre></li></ul></li><li class="suite"><h1>.scene</h1><ul><li class="test pass fast"><h2>makes a Scene :P<span class="duration">0ms</span></h2><pre><code>return this.scene.should.be[&quot;instanceof&quot;](playbook.Scene);</code></pre></li><li class="test pass fast"><h2>stores it in the scenes array<span class="duration">0ms</span></h2><pre><code>return playbook.scenes[0].should.eql(this.scene);</code></pre></li></ul></li><li class="suite"><h1>.sceneEnter</h1><ul><li class="suite"><h1>without type or args (other than response)</h1><ul><li class="test pass fast"><h2>makes scene with default user type<span class="duration">0ms</span></h2><pre><code>return playbook.scenes[0].should.be[&quot;instanceof&quot;](playbook.Scene);</code></pre></li><li class="test pass fast"><h2>returns a dialogue<span class="duration">0ms</span></h2><pre><code>return this.dialogue.should.be[&quot;instanceof&quot;](playbook.Dialogue);</code></pre></li><li class="test pass fast"><h2>enters scene, engaging user (stores against id)<span class="duration">0ms</span></h2><pre><code>return playbook.scenes[0].engaged['user_111'].should.eql(this.dialogue);</code></pre></li></ul></li><li class="suite"><h1>with type and options args</h1><ul><li class="test pass fast"><h2>used the given room type<span class="duration">0ms</span></h2><pre><code>return playbook.scenes[0].config.scope.should.equal('room');</code></pre></li><li class="test pass fast"><h2>passed the scene options to dialogue<span class="duration">0ms</span></h2><pre><code>return this.dialogue.config.sendReplies = false;</code></pre></li></ul></li></ul></li><li class="suite"><h1>.sceneListen</h1><ul><li class="suite"><h1>with scene args</h1><ul><li class="test pass fast"><h2>creates Scene instance<span class="duration">0ms</span></h2><pre><code>return this.scene.should.be[&quot;instanceof&quot;](playbook.Scene);</code></pre></li><li class="test pass fast"><h2>passed args to the scene<span class="duration">1ms</span></h2><pre><code>return playbook.scene.should.have.calledWith({
  sendReplies: false,
  scope: 'room'
});</code></pre></li><li class="test pass fast"><h2>calls .listen on the scene with type, regex and callback<span class="duration">0ms</span></h2><pre><code>return this.listen.should.have.calledWith('hear', /test/, sinon.match.func);</code></pre></li></ul></li><li class="suite"><h1>without scene args</h1><ul><li class="test pass fast"><h2>creates Scene instance<span class="duration">0ms</span></h2><pre><code>return this.scene.should.be[&quot;instanceof&quot;](playbook.Scene);</code></pre></li><li class="test pass fast"><h2>passed no args to the scene<span class="duration">0ms</span></h2><pre><code>return playbook.scene.getCall(0).should.have.calledWith();</code></pre></li><li class="test pass fast"><h2>calls .listen on the scene with type, regex and callback<span class="duration">0ms</span></h2><pre><code>return this.listen.should.have.calledWith('hear', /test/, sinon.match.func);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.sceneHear</h1><ul><li class="test pass fast"><h2>calls .sceneListen with hear type and any other args<span class="duration">0ms</span></h2><pre><code>var args, ref;
args = [
  'hear', /test/, {
    scope: 'room'
  }, sinon.match.func
];
return (ref = playbook.sceneListen.lastCall.should.have).calledWith.apply(ref, args);</code></pre></li></ul></li><li class="suite"><h1>.sceneRespond</h1><ul><li class="test pass fast"><h2>calls .sceneListen with respond type and any other args<span class="duration">0ms</span></h2><pre><code>var args, ref;
args = [
  'respond', /test/, {
    scope: 'room'
  }, sinon.match.func
];
return (ref = playbook.sceneListen.getCall(0).should.have).calledWith.apply(ref, args);</code></pre></li></ul></li><li class="suite"><h1>.director</h1><ul><li class="test pass fast"><h2>creates and returns director<span class="duration">0ms</span></h2><pre><code>return this.director.should.be[&quot;instanceof&quot;](playbook.Director);</code></pre></li><li class="test pass fast"><h2>stores it in the directors array<span class="duration">0ms</span></h2><pre><code>return playbook.directors[0].should.eql(this.director);</code></pre></li></ul></li><li class="suite"><h1>.transcript</h1><ul><li class="test pass fast"><h2>creates and returns transcript<span class="duration">0ms</span></h2><pre><code>return this.transcript.should.be[&quot;instanceof&quot;](playbook.Transcript);</code></pre></li><li class="test pass fast"><h2>stores it in the transcripts array<span class="duration">0ms</span></h2><pre><code>return playbook.transcripts[0].should.eql(this.transcript);</code></pre></li></ul></li><li class="suite"><h1>.transcribe</h1><ul><li class="test pass fast"><h2>creates transcripts<span class="duration">0ms</span></h2><pre><code>return playbook.transcript.should.have.calledThrice;</code></pre></li><li class="test pass fast"><h2>records events from given instances in brain<span class="duration">0ms</span></h2><pre><code>return pretend.robot.brain.get('transcripts').should.eql([
  {
    time: this.now,
    event: 'deny',
    instance: {
      name: 'director'
    }
  }, {
    time: this.now,
    event: 'enter',
    instance: {
      name: 'scene'
    }
  }, {
    time: this.now,
    event: 'send',
    instance: {
      name: 'dialogue'
    },
    strings: ['test']
  }
]);</code></pre></li></ul></li><li class="suite"><h1>.improvise</h1><ul><li class="test pass fast"><h2>returned an Improv singleton<span class="duration">0ms</span></h2><pre><code>return this.improv_A.should.eql(playbook.Improv.get());</code></pre></li><li class="test pass fast"><h2>kept the singleton as property<span class="duration">0ms</span></h2><pre><code>return playbook.improv.should.eql(playbook.Improv.get());</code></pre></li><li class="test pass fast"><h2>subsequent calls return same instance<span class="duration">0ms</span></h2><pre><code>return this.improv_A.should.eql(this.improv_B);</code></pre></li><li class="suite"><h1>messages after called</h1><ul><li class="test pass fast"><h2>parses messages with default context<span class="duration">1ms</span></h2><pre><code>return pretend.messages.pop().should.eql(['testing', 'hubot', 'hello tester']);</code></pre></li></ul></li><li class="suite"><h1>using custom data transforms</h1><ul><li class="test pass fast"><h2>parses messages with extended context<span class="duration">0ms</span></h2><pre><code>return pretend.messages.pop().should.eql(['testing', 'hubot', 'hello TESTER']);</code></pre></li></ul></li><li class="suite"><h1>extended using transcript reocrds</h1><ul><li class="test pass fast"><h2>merge the recorded answers with attribute tags<span class="duration">0ms</span></h2><pre><code>return pretend.messages.should.eql([['testing', 'tester', 'test'], ['testing', 'hubot', 'what is your favourite colour?'], ['testing', 'tester', 'orange'], ['testing', 'hubot', 'nice!'], ['testing', 'hubot', 'mine is orange too!']]);</code></pre></li></ul></li></ul></li><li class="suite"><h1>.shutdown</h1><ul><li class="test pass fast"><h2>calls .exitAll on scenes<span class="duration">0ms</span></h2><pre><code>return this.exit.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>calls .end on dialogues<span class="duration">0ms</span></h2><pre><code>return this.end.should.have.calledOnce;</code></pre></li></ul></li><li class="suite"><h1>.reset</h1><ul><li class="test pass fast"><h2>shuts down<span class="duration">0ms</span></h2><pre><code>return playbook.shutdown.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>re-initialises<span class="duration">0ms</span></h2><pre><code>return playbook.init.should.have.calledOnce;</code></pre></li><li class="test pass fast"><h2>retains any custom properties<span class="duration">0ms</span></h2><pre><code>return playbook.foo.should.equal('bar');</code></pre></li></ul></li></ul></li><ul>
    </div>
    <script>
        var tests = document.getElementsByClassName('test');

        for (var i = 0; i < tests.length; i++) {
            var elem = tests[i];

            if (elem.className.includes('pass')) {
                var head = elem.children[0];

                head.onclick = function () {
                    var code = this.parentElement.children[1];
                    var display = code.style.display;

                    if (display && display === 'block') {
                        code.style.display = 'none';
                    } else {
                        code.style.display = 'block';
                    }
                };
            }
        }
    </script>
</body>
</html>