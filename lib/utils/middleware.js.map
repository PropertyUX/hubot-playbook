{"version":3,"sources":["../../src/utils/middleware.js"],"names":["async","require","Middleware","instance","stack","context","next","done","Promise","resolve","reject","self","pieceDone","executeSingleMiddleware","doneFunc","middlewareFunc","cb","nextFunc","newDoneFunc","err","emit","response","allDone","_","finalDoneFunc","process","nextTick","reduce","bind","piece","length","Error","push","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAMA,QAAQC,QAAQ,OAAR,CAAd;;IAEMC,U;AACJ,sBAAaC,QAAb,EAAuB;AAAA;;AACrB,SAAKA,QAAL,GAAgBA,QAAhB,CADqB,CACI;AACzB,SAAKC,KAAL,GAAa,EAAb;AACD;;AAED;;;;;;;;;;;;;;;;4BAYSC,O,EAASC,I,EAAMC,I,EAAM;AAAA;;AAC5B,aAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,YAAMC,YAAN;;AAEA;AACA,YAAIJ,QAAQ,IAAZ,EAAkBA,OAAO,gBAAY,CAAE,CAArB;;AAElB;AACA,YAAMK,YAAY,SAAZA,SAAY,GAAM;AACtBH,kBAAQF,KAAKF,OAAL,CAAR;AACD,SAFD;;AAIA;AACA;AACA;AACA,iBAASQ,uBAAT,CAAkCC,QAAlC,EAA4CC,cAA5C,EAA4DC,EAA5D,EAAgE;AAC9D;AACA,mBAASC,QAAT,CAAmBC,WAAnB,EAAgC;AAC9BF,eAAG,IAAH,EAASE,eAAeJ,QAAxB;AACD;;AAED;AACA,cAAI;AACFC,2BAAeV,OAAf,EAAwBY,QAAxB,EAAkCH,QAAlC;AACD,WAFD,CAEE,OAAOK,GAAP,EAAY;AACZ;AACAR,iBAAKR,QAAL,CAAciB,IAAd,CAAmB,OAAnB,EAA4BD,GAA5B,EAAiCd,QAAQgB,QAAzC;AACA;AACAP;AACAK,gBAAId,OAAJ,GAAcA,OAAd;AACAK,mBAAOS,GAAP;AACD;AACF;;AAED;AACA,iBAASG,OAAT,CAAkBC,CAAlB,EAAqBC,aAArB,EAAoC;AAClCf,kBAAQH,KAAKD,OAAL,EAAcmB,aAAd,CAAR;AACD;;AAED;AACA;AACAC,gBAAQC,QAAR,CAAiB1B,MAAM2B,MAAN,CAAaC,IAAb,CAAkB,IAAlB,EAAwB,MAAKxB,KAA7B,EAAoCQ,SAApC,EAA+CC,uBAA/C,EAAwES,OAAxE,CAAjB;AACD,OAzCM,CAAP;AA0CD;;AAED;;;;;;;;;;;;;;;;;;;;6BAiBUO,K,EAAO;AACf,UAAIA,MAAMC,MAAN,KAAiB,CAArB,EAAwB;AACtB,cAAM,IAAIC,KAAJ,6EAAoFF,MAAMC,MAA1F,OAAN;AACD;AACD,WAAK1B,KAAL,CAAW4B,IAAX,CAAgBH,KAAhB;AACD;;;;;;AAGHI,OAAOC,OAAP,GAAiBhC,UAAjB","file":"middleware.js","sourcesContent":["'use strict'\n\nconst async = require('async')\n\nclass Middleware {\n  constructor (instance) {\n    this.instance = instance // for writing logs, errors\n    this.stack = []\n  }\n\n  /**\n   * Execute all middleware in order and call 'next' with the latest 'done'\n   * callback if last middleware calls through. If all middleware is compliant,\n   * 'done' should be called with no arguments when the entire round trip is\n   * complete.\n   *\n   * @param  {Object}   context Passed through the middleware stack\n   * @param  {Function} next    Called when all middleware is complete\n   * @param  {Function} [done]  Initial (final) completion callback.\n   *                            May be wrapped by executed middleware.\n   * @return {Promise}          Resolves with context when middleware completes\n   */\n  execute (context, next, done) {\n    return new Promise((resolve, reject) => {\n      const self = this\n\n      // If none provided, needs something to do finally\n      if (done == null) done = function () {}\n\n      // Allow each middleware to resolve the promise early if it calls done()\n      const pieceDone = () => {\n        resolve(done(context))\n      }\n\n      // Execute a single piece of middleware and update the completion callback\n      // (each piece of middleware can wrap the 'done' callback with additional\n      // logic).\n      function executeSingleMiddleware (doneFunc, middlewareFunc, cb) {\n        // Match the async.reduce interface\n        function nextFunc (newDoneFunc) {\n          cb(null, newDoneFunc || doneFunc)\n        }\n\n        // Catch errors in synchronous middleware\n        try {\n          middlewareFunc(context, nextFunc, doneFunc)\n        } catch (err) {\n          // Maintaining the existing error interface (Response object)\n          self.instance.emit('error', err, context.response)\n          // Forcibly fail the middleware and stop executing deeper\n          doneFunc()\n          err.context = context\n          reject(err)\n        }\n      }\n\n      // Executed when the middleware stack is finished\n      function allDone (_, finalDoneFunc) {\n        resolve(next(context, finalDoneFunc))\n      }\n\n      // Execute each piece of middleware, collecting the latest 'done' callback\n      // at each step.\n      process.nextTick(async.reduce.bind(null, this.stack, pieceDone, executeSingleMiddleware, allDone))\n    })\n  }\n\n  /**\n   * Add a function to the middleware stack, to either continue or interrupt the\n   * pipeline. Called with:\n   * - bound 'this' containing the executing instance\n   * - context, object containing relevant attributes for the pipeline\n   * - next, function to call to continue the pipeline\n   * - done, final pipeline function, optionally given as argument to next\n   *\n   * Call next to continue on to the next piece of middleware/execute. Call with\n   * no argument or with a single, optional argument: either the provided done\n   * function or a new function that eventually calls done.\n   *\n   * Call done to interrupt middleware execution and begin executing the chain\n   * of completion functions.\n   *\n   * @param  {Function} piece Pipeline function to add to the stack.\n   */\n  register (piece) {\n    if (piece.length !== 3) {\n      throw new Error(`Incorrect number of arguments for middleware callback (expected 3, got ${piece.length})`)\n    }\n    this.stack.push(piece)\n  }\n}\n\nmodule.exports = Middleware\n"]}