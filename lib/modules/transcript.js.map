{"version":3,"sources":["../../src/modules/transcript.js"],"names":["mixin","obj","keys","size","difference","pickKeys","omitBy","pick","isUndefined","Transcript","args","defaults","save","events","instanceAtts","responseAtts","messageAtts","config","castArray","robot","brain","get","set","records","event","instance","response","hasKeys","shift","record","time","now","key","pickHas","message","isEmpty","strings","other","push","emit","map","on","recordEvent","dialogue","dialogueEvents","intersection","pathEvents","path","scene","res","includes","recordDialogue","director","subsetMatch","returnPath","found","filter","foundAtPath","at","head","remove","instanceKey","userId","isString","captureGroup","isInteger","subset","extend","user","id","findRecords"],"mappings":"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","file":"transcript.js","sourcesContent":["'use strict'\n\nimport _ from 'lodash'\nimport Base from './base'\n\n_.mixin({\n  'hasKeys': (obj, keys) => _.size(_.difference(keys, _.keys(obj))) === 0\n})\n_.mixin({\n  'pickHas': (obj, pickKeys) => _.omitBy(_.pick(obj, pickKeys), _.isUndefined)\n})\n\n/**\n * Transcripts record conversation events, including meta about the user,\n * message and current module.\n *\n * Transcripts are searchable, to provide context from conversation history with\n * a given user, or based on any other attribute, such as listener ID.\n *\n * Different instances can be configured to record an overview or drilled down\n * analytics for a specific moduleâ€™s interactions using its key.\n *\n * @param {Robot}  robot                  Hubot Robot instance\n * @param {Object} [options]              Key/val options for config\n * @param {Object} [options.save]         Store records in hubot brain\n * @param {array} [options.events]        Event names to record\n * @param {array} [options.responseAtts]  Response keys or paths to record\n * @param {array} [options.instanceAtts]  Module instance keys or paths to record\n * @param {string} [key]                  Key name for this instance\n *\n * @todo Add config to record response middleware context including listener ID\n *\n * @example <caption>transcript to record room name when match emitted</caption>\n * let matchRecordRooms = new Transcript(robot, {\n *   responseAtts: ['message.room']\n *   events: ['match']\n * })\n * // does not start recording until calling one of the record methods, like:\n * matchRecordRooms.recordAll()\n*/\nclass Transcript extends Base {\n  constructor (...args) {\n    super('transcript', ...args)\n    this.defaults({\n      save: true,\n      events: ['match', 'mismatch', 'catch', 'send'],\n      instanceAtts: ['name', 'key', 'id'],\n      responseAtts: ['match'],\n      messageAtts: ['user.id', 'user.name', 'room', 'text']\n    })\n    if (this.config.instanceAtts != null) _.castArray(this.config.instanceAtts)\n    if (this.config.responseAtts != null) _.castArray(this.config.responseAtts)\n    if (this.config.messageAtts != null) _.castArray(this.config.messageAtts)\n\n    if (this.config.save) {\n      if (!this.robot.brain.get('transcripts')) {\n        this.robot.brain.set('transcripts', [])\n      }\n      this.records = this.robot.brain.get('transcripts')\n    }\n    if (this.records == null) this.records = []\n  }\n\n  /**\n   * Record given event details in array, save to hubot brain if configured to.\n   *\n   * Events emitted by Playbook always include module instance as first param.\n   *\n   * This is only called internally on watched events after running `recordAll`,\n   * `recordDialogue`, `recordScene` or `recordDirector`\n   *\n   * @param {string} event The event name\n   * @param {*} args...    Args passed with the event, usually consists of:<br>\n   *                       - Playbook module instance<br>\n   *                       - Hubot response object<br>\n   *                       - other additional (special context) arguments\n  */\n  recordEvent (event, ...args) {\n    let instance, response\n    if (_.hasKeys(args[0], ['name', 'id', 'config'])) instance = args.shift()\n    if (_.hasKeys(args[0], ['robot', 'message'])) response = args.shift()\n    const record = {time: _.now(), event}\n    if (this.key != null) record.key = this.key\n    if ((instance != null) && (this.config.instanceAtts != null)) {\n      record.instance = _.pickHas(instance, this.config.instanceAtts)\n    }\n    if ((response != null) && (this.config.responseAtts != null)) {\n      record.response = _.pickHas(response, this.config.responseAtts)\n    }\n    if ((response != null) && (this.config.messageAtts != null)) {\n      record.message = _.pickHas(response.message, this.config.messageAtts)\n    }\n\n    if (!_.isEmpty(args)) {\n      if (event === 'send' && args[0].strings) record.strings = args[0].strings\n      else record.other = args\n    }\n\n    this.records.push(record)\n    this.emit('record', record)\n  }\n\n  /**\n   * Record events emitted by all Playbook modules and/or the robot itself\n   * (still only applies to configured event types).\n  */\n  recordAll () {\n    _.castArray(this.config.events).map((event) =>\n      this.robot.on(event, (...args) =>\n        this.recordEvent(event, ...args))\n    )\n  }\n\n  /**\n   * @todo Re-instate `recordListener` when regular listeners emit event with\n   * context containing options and ID.\n   */\n  /*\n  recordListener (context) {\n\n  }\n  */\n\n  /**\n   * Record events emitted by a given dialogue and it's path/s.\n   *\n   * Whenever a path is added to a dialogue, event handlers are added on the\n   * path for the configured events.\n   *\n   * @param {Dialogue} dialogue The Dialogue instance\n  */\n  recordDialogue (dialogue) {\n    let dialogueEvents = _.intersection(this.config.events, ['end', 'send', 'timeout', 'path'])\n    let pathEvents = _.intersection(this.config.events, ['match', 'catch', 'mismatch'])\n    dialogueEvents.map((event) => {\n      dialogue.on(event, (...args) => this.recordEvent(event, dialogue, ...args))\n    })\n    dialogue.on('path', (path) => {\n      pathEvents.map((event) => {\n        path.on(event, (...args) => this.recordEvent(event, path, ...args))\n      })\n    })\n  }\n\n  /**\n   * Record events emitted by a given scene and any dialogue it enters, captures\n   * configured events from scene and its created dialogues and paths.\n   *\n   * @param {Scene} scene The Scnee instance\n  */\n  recordScene (scene) {\n    scene.on('enter', (res) => {\n      if (_.includes(this.config.events, 'enter')) this.recordEvent('enter', scene, res)\n      this.recordDialogue(res.dialogue)\n    })\n    scene.on('exit', (...args) => {\n      if (_.includes(this.config.events, 'exit')) this.recordEvent('exit', scene, ...args)\n    })\n  }\n\n  /**\n   * Record allow/deny events emitted by a given director. Ignores configured\n   * events because director has distinct events.\n   *\n   * @param {Director} director The Director instance\n  */\n  recordDirector (director) {\n    director.on('allow', (...args) => this.recordEvent('allow', director, ...args))\n    director.on('deny', (...args) => this.recordEvent('deny', director, ...args))\n  }\n\n  /**\n   * Filter records matching a subset, e.g. user name or instance key.\n   *\n   * Optionally return the whole record or values for a given key.\n   *\n   * @param  {Object} subsetMatch  Key/s:value/s to match (accepts path key)\n   * @param  {string} [returnPath] Key or path within record to return\n   * @return {array}               Whole records or selected values found\n   *\n   * @example\n   * transcript.findRecords({\n   *   message: { user: { name: 'jon' } }\n   * })\n   * // returns array of recorded event objects\n   *\n   * transcript.findRecords({\n   *   message: { user: { name: 'jon' } }\n   * }, 'message.text')\n   * // returns array of message text attribute from recroded events\n  */\n  findRecords (subsetMatch, returnPath) {\n    let found = _.filter(this.records, subsetMatch)\n    if (returnPath == null) return found\n    let foundAtPath = found.map((record) => _(record).at(returnPath).head())\n    _.remove(foundAtPath, _.isUndefined)\n    return foundAtPath\n  }\n\n  /**\n   * Alias for findRecords for just response match attributes with a given\n   * instance key, useful for simple lookups of information provided by users\n   * within a specific conversation.\n   *\n   * @param  {string}  instanceKey    Recorded instance key to lookup\n   * @param  {string}  [userId]       Filter results by a user ID\n   * @param  {integer} [captureGroup] Filter match by regex capture group subset\n   * @return {array}                  Contains full match or just capture group\n   *\n   * @example <caption>find answers from a specific dialogue path</caption>\n   * const transcript = new Transcript(robot)\n   * robot.hear(/color/, (res) => {\n   *   let favColor = new Dialogue(res, 'fav-color')\n   *   transcript.recordDialogue(favColor)\n   *   favColor.addPath([\n   *     [ /my favorite color is (.*)/, 'duly noted' ]\n   *   ])\n   *   favColor.receive(res)\n   * })\n   * robot.respond(/what is my favorite color/, (res) => {\n   *   let colorMatches = transcript.findKeyMatches('fav-color', 1)\n   *   # ^ word we're looking for from capture group is at index: 1\n   *   if (colorMatches.length) {\n   *     res.reply(`I remember, it's ${ colorMatches.pop() }`)\n   *   } else {\n   *     res.reply(\"I don't know!?\")\n   *   }\n   * })\n   *\n  */\n  findKeyMatches (instanceKey, ...args) {\n    let userId = (_.isString(args[0])) ? args.shift() : null\n    let captureGroup = (_.isInteger(args[0])) ? args.shift() : null\n    let subset = { instance: { key: instanceKey } }\n    let path = 'response.match'\n    if (userId != null) _.extend(subset, { message: { user: { id: userId } } })\n    if (captureGroup != null) path += `[${captureGroup}]`\n    return this.findRecords(subset, path)\n  }\n\n  /**\n   * Alias for findRecords for just response match attributes with a given\n   * listener ID, useful for lookups of matches from a specific listener.\n   *\n   * @param  {string}  listenerId     Listener ID match to lookup\n   * @param  {string}  [userId]       Filter results by a user ID\n   * @param  {integer} [captureGroup] Filter match by regex capture group subset\n   * @return {array}                  Contains full match or just capture group\n   *\n   * @todo Re-instate `findIdMatches` when `recordListener` is funtional\n  */\n  /*\n  findIdMatches (listenerId, ...args) {\n    let userId = (_.isString(args[0])) ? args.shift() : null\n    let captureGroup = (_.isInteger(args[0])) ? args.shift() : null\n    let subset = { listener: { options: { id: listenerId } } }\n    let path = 'response.match'\n    if (userId != null) subset.message = { user: { id: userId } }\n    if (captureGroup != null) path += `[${captureGroup}]`\n    return this.findRecords(subset, path)\n  }\n  */\n}\n\nexport default Transcript\n"]}