{"version":3,"sources":["../../src/modules/path.js"],"names":["Path","constructor","robot","args","branches","isArray","shift","closed","error","branch","addBranch","regex","callback","message","isRegExp","isString","isFunction","push","handler","res","dialogue","send","_catch","config","catchMessage","catchCallback","match","text","find"],"mappings":"2EAAA,gC;AACA,8B;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,MAAMA,IAAN,wBAAwB;AACtBC,cAAaC,KAAb,EAAoB,GAAGC,IAAvB,EAA6B;AAC3B,QAAIC,WAAW,iBAAEC,OAAF,CAAUF,KAAK,CAAL,CAAV,IAAqBA,KAAKG,KAAL,EAArB,GAAoC,KAAnD;AACA,UAAM,MAAN,EAAcJ,KAAd,EAAqB,GAAGC,IAAxB;;AAEA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKG,MAAL,GAAc,IAAd;AACA,QAAIH,QAAJ,EAAc;AACZ,UAAI,CAAC,iBAAEC,OAAF,CAAUD,QAAV,CAAL,EAA0B,KAAKI,KAAL,CAAW,wBAAX;AAC1B,UAAI,CAAC,iBAAEH,OAAF,CAAUD,SAAS,CAAT,CAAV,CAAL,EAA6BA,WAAW,CAACA,QAAD,CAAX,CAFjB,CAEuC;AACnD,WAAK,IAAIK,MAAT,IAAmBL,QAAnB,EAA6B,KAAKM,SAAL,CAAe,GAAGD,MAAlB;AAC9B;AACF;;AAED;;;;;;;;;;;;AAYAC,YAAWC,KAAX,EAAkB,GAAGR,IAArB,EAA2B;AACzB,QAAIS,QAAJ,EAAcC,OAAd;AACA,QAAI,CAAC,iBAAEC,QAAF,CAAWH,KAAX,CAAL,EAAwB,KAAKH,KAAL,CAAW,2BAAX;AACxB,QAAI,iBAAEO,QAAF,CAAWZ,KAAK,CAAL,CAAX,CAAJ,EAAyBU,UAAUV,KAAKG,KAAL,EAAV;AACzB,QAAI,iBAAEU,UAAF,CAAab,KAAK,CAAL,CAAb,CAAJ,EAA2BS,WAAWT,KAAKG,KAAL,EAAX;AAC3B,QAAKO,WAAW,IAAZ,IAAsBD,YAAY,IAAtC,EAA6C,KAAKJ,KAAL,CAAW,yBAAX;AAC7C,SAAKJ,QAAL,CAAca,IAAd,CAAmB;AACjBN,aAAOA,KADU;AAEjBO,eAAS,CAACC,GAAD,EAAMC,QAAN,KAAmB;AAC1B,YAAIP,WAAW,IAAf,EAAqBO,SAASC,IAAT,CAAcR,OAAd;AACrB,YAAID,YAAY,IAAhB,EAAsBA,SAASO,GAAT,EAAcC,QAAd;AACvB,OALgB,EAAnB;;AAOA,SAAKb,MAAL,GAAc,KAAd,CAbyB,CAaL;AACrB;;AAED;;;;;;;;;AASAe,WAAU;AACR,QAAK,KAAKC,MAAL,CAAYC,YAAZ,IAA4B,IAA7B,IAAuC,KAAKD,MAAL,CAAYE,aAAZ,IAA6B,IAAxE,EAA+E;AAC/E,WAAO;AACLP,eAAS,CAACC,GAAD,EAAMC,QAAN,KAAmB;AAC1B,YAAI,KAAKG,MAAL,CAAYC,YAAZ,IAA4B,IAAhC,EAAsCJ,SAASC,IAAT,CAAc,KAAKE,MAAL,CAAYC,YAA1B;AACtC,YAAI,KAAKD,MAAL,CAAYE,aAAZ,IAA6B,IAAjC,EAAuC,KAAKF,MAAL,CAAYE,aAAZ,CAA0BN,GAA1B,EAA+BC,QAA/B;AACxC,OAJI,EAAP;;AAMD;;AAED;;;;;;;;;;;;;;;;;;;;AAoBAM,QAAOP,GAAP,EAAY;AACV,UAAM,EAAEQ,IAAF,KAAWR,IAAIN,OAArB;AACA,UAAMJ,SAAS,iBAAEmB,IAAF,CAAO,KAAKxB,QAAZ,EAAsB,UAAUK,MAAV,EAAkB;AACrDU,UAAIO,KAAJ,GAAYC,KAAKD,KAAL,CAAWjB,OAAOE,KAAlB,CAAZ;AACA,aAAOQ,IAAIO,KAAX;AACD,KAHc,CAAf,CAFU,CAKP;AACH,QAAIjB,UAAU,IAAd,EAAoB,CAAE,KAAKF,MAAL,GAAc,IAAd,CAAoB;AAC1C,WAAOE,UAAU,KAAKa,MAAL,EAAjB;AACD,GAzFqB,C;;;AA4FTtB,I","file":"path.js","sourcesContent":["import _ from 'lodash'\nimport Base from './base'\n\n/**\n * Paths and their child branches are the smallest and most essential node for\n * conversations. Instead of listening for all triggers at all times, paths\n * allow matching multiple choices in a tightly scoped context.\n *\n * A path usually contains one or more _branches_ to follow when matched.\n *\n * A path is _opened_ when branches added and _closed_ when a branch is\n * matched (unless more are added). Using brnach callbacks, the path can keep\n * laying new branches to remain open, until finally a branch is matched\n * without any new ones added.\n *\n * @param {Robot}  robot      Hubot Robot instance\n * @param {array}  [branches] Array of args for each branch, each containing:<br>\n *                            - RegExp for listener<br>\n *                            - String to send and/or<br>\n *                            - Function to call on match\n * @param {Object} [options]  Key/val options for config\n * @param {string} [key]      Key name for this instance\n *\n * @example <caption>with an array of text responses</caption>\n * let choice = new Path(robot, [\n *   [ /door 1/, 'foo' ]\n *   [ /door 2/, 'bar', () => bar() ]\n *   [ /door 3/, () => baz() ]\n * ])\n *\n * @example <caption>with message and callback options</caption>\n * let choice = new Path(robot, {\n *   catchMessage: 'sorry, nothing matched'\n *   catchCallback: () => noMatch()\n * })\n*/\nclass Path extends Base {\n  constructor (robot, ...args) {\n    let branches = _.isArray(args[0]) ? args.shift() : false\n    super('path', robot, ...args)\n\n    this.branches = []\n    this.closed = true\n    if (branches) {\n      if (!_.isArray(branches)) this.error('Branches must be Array')\n      if (!_.isArray(branches[0])) branches = [branches] // cast 2D array\n      for (let branch of branches) this.addBranch(...branch)\n    }\n  }\n\n  /**\n   * Add a branch (matching expression and handler) for optional dialogue input.\n   *\n   * On match, handler either fires callback, sends a message or both.\n   *\n   * @param {RegExp} regex        Matching pattern\n   * @param {string} [message]    Message text for response on match\n   * @param {Function} [callback] Function called when matched\n   *\n   * @example <caption>with regex, message and callback</caption>\n   * path.addBranch(/hello/i, 'hello there', helloCallback)\n  */\n  addBranch (regex, ...args) {\n    let callback, message\n    if (!_.isRegExp(regex)) this.error('Invalid RegExp for branch')\n    if (_.isString(args[0])) message = args.shift()\n    if (_.isFunction(args[0])) callback = args.shift()\n    if ((message == null) && (callback == null)) this.error('Missing args for branch')\n    this.branches.push({\n      regex: regex,\n      handler: (res, dialogue) => {\n        if (message != null) dialogue.send(message)\n        if (callback != null) callback(res, dialogue)\n      }\n    })\n    this.closed = false // path is open as long as branches are added\n  }\n\n  /**\n   * Called when nothing matches, behaviour depends on config:\n   * - catchMessage: Message to send via handler\n   * - catchCallback: Function to call within handler\n   *\n   * If neither is set, nothing happens.\n   *\n   * @return {Object} Contains .handler (function) or null if not configured\n  */\n  _catch () {\n    if ((this.config.catchMessage == null) && (this.config.catchCallback == null)) return\n    return {\n      handler: (res, dialogue) => {\n        if (this.config.catchMessage != null) dialogue.send(this.config.catchMessage)\n        if (this.config.catchCallback != null) this.config.catchCallback(res, dialogue)\n      }\n    }\n  }\n\n  /**\n   * Attempt to match an incoming response object.\n   *\n   * Overrides the response match (from dialogue listener) even if null match.\n   *\n   * Matching closes the path, but the handler may add branches, re-opening it.\n   *\n   * Without match, will attempt catch (which may also return null).\n   *\n   * @param  {Response} res     Hubot Response object\n   * @return {Object|undefined} Matched branch with regex and handler\n   *\n   * @example\n   * let choice = new Path(robot, [\n   *   [ /door 1/, 'foo' ]\n   *   [ /door 2/, 'bar', () => bar() ]\n   *   [ /door 3/, () => baz() ]\n   * ])\n   * robot.hear(/door/, (res) => choice.match(res))\n  */\n  match (res) {\n    const { text } = res.message\n    const branch = _.find(this.branches, function (branch) {\n      res.match = text.match(branch.regex)\n      return res.match\n    }) // truthy / falsey\n    if (branch != null) { this.closed = true }\n    return branch || this._catch()\n  }\n}\n\nexport default Path\n"]}