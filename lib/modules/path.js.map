{"version":3,"sources":["../../src/modules/path.js"],"names":["Path","robot","args","branches","isArray","shift","closed","error","branch","addBranch","regex","callback","strings","isRegExp","isString","isFunction","push","handler","getHandler","res","sent","called","castArray","dialogue","send","reply","Promise","all","then","merge","values","config","catchMessage","catchCallback","handled","catchHandler","matchedBranch","find","match","message","text","emit","resolve"],"mappings":"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","file":"path.js","sourcesContent":["'use strict'\n\nimport _ from 'lodash'\nimport Base from './base'\n\n/**\n * Paths are the smallest and most essential node for conversations. They allow\n * matching message text against multiple branches in a tightly scoped context.\n *\n * A path is open when branches are added and closed when a branch is matched.\n * While open, it can process incoming messages against the possible branches.\n *\n * A matched branch can respond to the user and lay more branches to keep the\n * path open, until finally a branch is matched without any new ones added.\n *\n * @param {Robot}  robot                   Hubot Robot instance\n * @param {array}  [branches]              Array of args for each branch, each containing:<br>\n *                                         - RegExp for listener<br>\n *                                         - String to send and/or<br>\n *                                         - Function to call on match\n * @param {Object} [options]               Key/val options for config\n * @param {Object} [options.catchMessage]  Message to send via catch handler\n * @param {Object} [options.catchCallback] Function to call within catch handler\n * @param {string} [key]                   Key name for this instance\n *\n * @example <caption>showing branch argument variations</caption>\n * let choice = new Path(robot, [\n *   [ /door 1/, 'foo' ]\n *   [ /door 2/, 'bar', () => bar() ]\n *   [ /door 3/, () => baz() ]\n * ])\n *\n * @example <caption>with message and callback options</caption>\n * let choice = new Path(robot, {\n *   catchMessage: 'sorry, nothing matched'\n *   catchCallback: () => noMatch()\n * })\n*/\nclass Path extends Base {\n  constructor (robot, ...args) {\n    let branches = _.isArray(args[0]) ? args.shift() : false\n    super('path', robot, ...args)\n\n    this.branches = []\n    this.closed = true\n    if (branches) {\n      if (!_.isArray(branches)) this.error('Branches must be Array')\n      if (!_.isArray(branches[0])) branches = [branches] // cast 2D array\n      for (let branch of branches) this.addBranch(...branch)\n    }\n  }\n\n  /**\n   * Add an optional dialogue branch.\n   *\n   * Each branch is assigned a handler to call on match, which can sends a\n   * message and/or fire a given callback.\n   *\n   * Branch handlers are called by `.match`, if input matches a branch, which\n   * then returns the matched handler's return value.\n   *\n   * @param {RegExp} regex           Matching pattern\n   * @param {string/array} [strings] Message text for response on match\n   * @param {Function} [callback]    Function called when matched\n   *\n   * @example <caption>with regex, message and callback</caption>\n   * path.addBranch(/hello/i, 'hello there', helloCallback)\n  */\n  addBranch (regex, ...args) {\n    let callback, strings\n    if (!_.isRegExp(regex)) this.error('Invalid RegExp for branch')\n    if (_.isString(args[0]) || _.isArray(args[0])) strings = args.shift()\n    if (_.isFunction(args[0])) callback = args.shift()\n    if ((strings == null) && (callback == null)) this.error('Missing args for branch')\n    this.branches.push({\n      regex: regex,\n      handler: this.getHandler(strings, callback)\n    })\n    this.closed = false // path is open as long as branches are added\n  }\n\n  /**\n   * Ready a function to call on a match or catch, sending stirngs and/or doing\n   * a callback.\n   *\n   * Handlers return a promise that resolves with a merged object containing the\n   * conext returned by send middleware if strings were sent, and the return\n   * value of the callback if there was one.\n   *\n   * Either may return a promise so the result is wrapped to resolve both.\n   *\n   * @param  {string/array} strings Message text to send on match\n   * @param  {Function} callback    Function to call on match\n   * @return {Function}             The handler\n   */\n  getHandler (strings, callback) {\n    return (res) => {\n      let sent, called\n      if (strings) {\n        strings = _.castArray(strings)\n        if (res.dialogue) sent = res.dialogue.send(...strings)\n        else sent = res.reply(...strings)\n      }\n      if (callback) called = callback(res)\n      return Promise.all([sent, called]).then(values => {\n        return _.merge({}, values[0], values[1])\n      })\n    }\n  }\n\n  /**\n   * Get handler for when nothing matches, if configured.\n   *\n   * If neither `catchMessage` or `catchCallback` is set, nothing happens.\n   *\n   * @return {Function} Handler (or undefined)\n  */\n  catchHandler () {\n    if (this.config.catchMessage || this.config.catchCallback) {\n      return this.getHandler(this.config.catchMessage, this.config.catchCallback)\n    } else return false\n  }\n\n  /**\n   * Attempt to match an incoming response object. Overrides the response match\n   * (from the more general dialogue listener) even if null.\n   *\n   * Matching closes the path and fires the handler which may add branches,\n   * re-opening it. Without a match, it will attempt to use a catch handler\n   * (which may be null). The matched branch or catch handler method may return\n   * a promise or not, the response is returned wrapped in a promise either way.\n   *\n   * @param  {Response} res Hubot Response object\n   * @return {Promise}      Resolves with matched/catch branch handler result\n   *\n   * @example listener matching against possible branches\n   * let choice = new Path(robot, [\n   *   [ /door 1/, 'pies' ]\n   *   [ /door 2/, 'lies' ]\n   * ])\n   * robot.hear(/door/, (res) => choice.match(res))\n  */\n  match (res) {\n    let handler, handled\n    const catchHandler = this.catchHandler()\n    const matchedBranch = _.find(this.branches, function (branch) {\n      res.match = res.message.text.match(branch.regex)\n      return res.match // truthy / falsey\n    })\n    if (matchedBranch) handler = matchedBranch.handler\n    if (handler) {\n      this.closed = true\n      this.emit('match', res)\n      handled = handler(res)\n    } else if (catchHandler) {\n      this.emit('catch', res)\n      handled = catchHandler(res)\n    } else {\n      this.emit('mismatch', res)\n    }\n    return Promise.resolve(handled)\n  }\n}\n\nexport default Path\n"]}