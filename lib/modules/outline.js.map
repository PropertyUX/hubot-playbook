{"version":3,"sources":["../../src/modules/outline.js"],"names":["Outline","robot","bits","args","scenes","filter","map","bit","setupScene","res","key","setupDialogue","send","next","setupPath","listen","push","regex","bitCondition","type","scope","options","callback","doBit","scene","dialogue","reply","sendReplies","timeout","timeoutText","configure","dlg","catch","catchMessage","branches","nextKey","addPath","RegExp","condition"],"mappings":";;;;;;;;AAAA;;;;AACA;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;IA2BMA,O;;;AACJ,mBAAaC,KAAb,EAAoBC,IAApB,EAAmC;AAAA;;AAAA;;AAAA,sCAANC,IAAM;AAANA,UAAM;AAAA;;AAAA,sIAC3B,SAD2B,EAChBF,KADgB,SACNE,IADM;;AAEjC,UAAKC,MAAL,GAAc,EAAd;AACA,UAAKF,IAAL,GAAYA,IAAZ;AACA,qBAAEG,MAAF,CAAS,MAAKH,IAAd,EAAoB,QAApB,EAA8BI,GAA9B,CAAkC,UAACC,GAAD;AAAA,aAAS,MAAKC,UAAL,CAAgBD,GAAhB,CAAT;AAAA,KAAlC;AAJiC;AAKlC;;AAED;;;;;;;;;;;;;0BASOE,G,EAAKC,G,EAAK;AAAA;;AACfD,UAAIF,GAAJ,GAAU,KAAKL,IAAL,CAAUQ,GAAV,CAAV;AACA,6BAAKC,aAAL,CAAmBF,GAAnB,GAAwBG,IAAxB,0CAAgCH,IAAIF,GAAJ,CAAQK,IAAxC;AACA,UAAIH,IAAIF,GAAJ,CAAQM,IAAZ,EAAkB,KAAKC,SAAL,CAAeL,GAAf;AACnB;;AAED;;;;;;;;;;;;;;;;+BAaYF,G,EAAK;AAAA;;AACf,UAAIA,IAAIQ,MAAJ,KAAe,IAAnB,EAAyB;AACvB,aAAKX,MAAL,CAAYY,IAAZ,CAAiB;AACfD,kBAAQR,IAAIQ,MADG;AAEfE,iBAAO,KAAKC,YAAL,CAAkBX,IAAIG,GAAtB,CAFQ;AAGfS,gBAAMZ,IAAIa,KAHK;AAIfC,mBAASd,IAAIc,OAJE;AAKfX,eAAKH,IAAIG,GALM;AAMfY,oBAAU,kBAACb,GAAD;AAAA,mBAAS,OAAKc,KAAL,CAAWd,GAAX,EAAgBF,IAAIG,GAApB,CAAT;AAAA;AANK,SAAjB;AAQD;AACF;;AAED;;;;;;;;;;;;;;;;;mCAcgB;AACd,aAAO,KAAKN,MAAL,CAAYE,GAAZ,CAAgB,UAACkB,KAAD;AAAA,eAAW,CAChCA,MAAMT,MAD0B,EAClBS,MAAMP,KADY,EACLO,MAAML,IADD,EACOK,MAAMH,OADb,EACsBG,MAAMF,QAD5B,CAAX;AAAA,OAAhB,CAAP;AAGD;;AAED;;;;;;;;kCAKeb,G,EAAK;AAClB,UAAIY,UAAU,EAAd;AACA,UAAId,MAAME,IAAIF,GAAd;AACA,UAAIkB,WAAWhB,IAAIgB,QAAnB;AACA,UAAIlB,IAAImB,KAAJ,KAAc,IAAlB,EAAwBL,QAAQM,WAAR,GAAsBpB,IAAImB,KAA1B;AACxB,UAAInB,IAAIqB,OAAJ,KAAgB,IAApB,EAA0BP,QAAQO,OAAR,GAAkBrB,IAAIqB,OAAtB;AAC1B,UAAIrB,IAAIsB,WAAJ,KAAoB,IAAxB,EAA8BR,QAAQQ,WAAR,GAAsBtB,IAAIqB,OAA1B;AAC9BH,eAASK,SAAT,CAAmBT,OAAnB;AACAI,eAASf,GAAT,GAAeH,IAAIG,GAAnB;AACA,aAAOe,QAAP;AACD;;AAED;;;;;;;;8BAKWhB,G,EAAKsB,G,EAAK;AAAA;;AACnB,UAAMxB,MAAME,IAAIF,GAAhB;AACA,UAAMc,UAAU,EAAhB;AACA,UAAId,IAAIyB,KAAR,EAAeX,QAAQY,YAAR,GAAuB1B,IAAIyB,KAA3B;AACf,UAAME,WAAW3B,IAAIM,IAAJ,CAASP,GAAT,CAAa,UAAC6B,OAAD,EAAa;AACzC,YAAIlB,QAAQ,OAAKC,YAAL,CAAkBiB,OAAlB,CAAZ;AACA,YAAIb,WAAW,SAAXA,QAAW,CAACb,GAAD;AAAA,iBAAS,OAAKc,KAAL,CAAWd,GAAX,EAAgB0B,OAAhB,CAAT;AAAA,SAAf;AACA,eAAO,CAAClB,KAAD,EAAQK,QAAR,CAAP;AACD,OAJgB,CAAjB;AAKAS,UAAIK,OAAJ,CAAYF,QAAZ,EAAsBb,OAAtB,EAA+Bd,IAAIG,GAAnC;AACD;;AAED;;;;;;;;;;;iCAQcA,G,EAAK;AACjB,aAAO,IAAI2B,MAAJ,SAAiB,KAAKnC,IAAL,CAAUQ,GAAV,EAAe4B,SAAhC,UAAgD,GAAhD,CAAP;AACD;;;;;;kBAGYtC,O","file":"outline.js","sourcesContent":["import _ from 'lodash'\nimport Base from './base'\n\n/**\n * Outlines are a conversation modelling schema / handler, with collections of\n * attributes for setting up scenes, dialogues, paths and directors, for\n * interactions defined as bits.\n *\n * Define a key and condition to execute each bit, either consecutively off a\n * prior bit, or with a listen attribute to become effectively a global entry\n * point to a scene.\n *\n * A subsequent bit can even lead back to itâ€™s own parent or any other bit,\n * creating a mesh of possible conversational pathways.\n *\n * @param {string/Object[]} bits      Attributes to setup bits\n * @param {array}  bits[].send        String/s to send when doing bit (minimum requirement)\n * @param {string} [bits[].catch]     To send if response unmatched by listeners\n * @param {string} [bits[].condition] Converted to regex for listener to trigger bit\n * @param {string} [bits[].listen]    Type of listener (hear/respond) for scene entry bit\n * @param {string} [bits[].scene]     Scope for the scene (only used if it has a listen type)\n * @param {string} [bits[].key]       Key for scene and/or dialogue running the bit\n * @param {Object} [bits[].options]   Key/val options for scene and/or dialogue config\n * @param {array} [bits[].next]       Key/s (strings) for consequitive bits\n * @param {Object} [options]          Key/val options for outline config\n * @param {string} [key]              Key name for this instance\n *\n * @todo Add bit attribute for callback function as a key of extended response\n * @todo Add bit attribute for director whitelist/blacklist names and/or auth function\n */\nclass Outline extends Base {\n  constructor (robot, bits, ...args) {\n    super('outline', robot, ...args)\n    this.scenes = []\n    this.bits = bits\n    _.filter(this.bits, 'listen').map((bit) => this.setupScene(bit))\n  }\n\n  /**\n   * Send messages and setup any following listeners for a bit.\n   *\n   * Called in an open dialogue, as a callback on entering the scene or\n   * continuing from a prior bit. Adds the bit as a property of the response.\n   *\n   * @param  {Response} res Hubot Response object\n   * @param  {string} key   The key for a loaded bit\n   */\n  doBit (res, key) {\n    res.bit = this.bits[key]\n    this.setupDialogue(res).send(...res.bit.send)\n    if (res.bit.next) this.setupPath(res)\n  }\n\n  /**\n   * Prepare the arguments required to add listener for a scene entering bit.\n   *\n   * Only applicable to bits with a `listen` attribute (hear or respond).\n   * Subsequent bits will play out within the same scene so their listen type is\n   * irrelevant because all responses from an engaged audience will be routed\n   * through the current dialogue.\n   *\n   * Bits only require a `.listen` and `.condition` property to setup a scene\n   * listener and will use defaults if `.scope` and `.options` are null.\n   *\n   * @param  {Object} bit Attributes to setup scene for entry to bit\n   */\n  setupScene (bit) {\n    if (bit.listen !== null) {\n      this.scenes.push({\n        listen: bit.listen,\n        regex: this.bitCondition(bit.key),\n        type: bit.scope,\n        options: bit.options,\n        key: bit.key,\n        callback: (res) => this.doBit(res, bit.key)\n      })\n    }\n  }\n\n  /**\n   * Get arguments to pass into scene listeners for _global_ bits.\n   *\n   * @return {array} Items contain required arguments (call with spread syntax)\n   *\n   * @example <caption>The hard way</caption>\n   * const scene = new Scene(robot)\n   * const outline = new Outline('./conversation.yml')\n   * outline.getSceneArgs().map((args) => scene.listen(...args)\n   *\n   * @example <caption>The easy way</caption>\n   * const pb = new Playbook(robot).outline('./conversation.yml')\n   * // ^ playbook helper creates outline and sets up scenes\n   */\n  getSceneArgs () {\n    return this.scenes.map((scene) => [\n      scene.listen, scene.regex, scene.type, scene.options, scene.callback\n    ])\n  }\n\n  /**\n   * Dialogue is already open from the scene being triggered.\n   *\n   * @param  {Response} res Hubot Response object\n   */\n  setupDialogue (res) {\n    let options = {}\n    let bit = res.bit\n    let dialogue = res.dialogue\n    if (bit.reply !== null) options.sendReplies = bit.reply\n    if (bit.timeout !== null) options.timeout = bit.timeout\n    if (bit.timeoutText !== null) options.timeoutText = bit.timeout\n    dialogue.configure(options)\n    dialogue.key = bit.key\n    return dialogue\n  }\n\n  /**\n   * Add path options and branches to\n   *\n   * @param  {Response} res Hubot Response object\n   */\n  setupPath (res, dlg) {\n    const bit = res.bit\n    const options = {}\n    if (bit.catch) options.catchMessage = bit.catch\n    const branches = bit.next.map((nextKey) => {\n      let regex = this.bitCondition(nextKey)\n      let callback = (res) => this.doBit(res, nextKey)\n      return [regex, callback]\n    })\n    dlg.addPath(branches, options, bit.key)\n  }\n\n  /**\n   * Convert a bit's condition attribute into a regex.\n   *\n   * @param  {string} key The key for a loaded bit\n   * @return {RegExp}     The pattern for the bit's listener\n   *\n   * @todo Use `conditioner-regex` to convert array of conditions to pattern\n   */\n  bitCondition (key) {\n    return new RegExp(`\\\\b${this.bits[key].condition}\\\\b`, 'i')\n  }\n}\n\nexport default Outline\n"]}