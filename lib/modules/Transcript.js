// Generated by CoffeeScript 1.12.5
(function() {
  var Base, Transcript, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Base = require('./Base');

  _.mixin({
    'hasKeys': function(obj, keys) {
      return 0 === _.size(_.difference(keys, _.keys(obj)));
    }
  });

  _.mixin({
    'pickHas': function(obj, pickKeys) {
      return _.omitBy(_.pick(obj, pickKeys), _.isUndefined);
    }

    /**
     * Keep a record of configured events and emmitted data. Can record any events
     * emitted by the robot or just those originating from a given instance
     * Config keys:
     * - events: array of event names to record
     * - responseAtts: Hubot Response attribute keys to add to record
     * - instanceAtts: as above, for Playbook module instance attributes
     * @param {Robot}  robot     - Hubot Robot instance
     * @param {Object} [options] - Key/val options for config
     * @param {String} [key]     - Key name for this instance
     */
  });

  Transcript = (function(superClass) {
    extend(Transcript, superClass);

    function Transcript() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.defaults = {
        save: true,
        events: ['match', 'mismatch', 'catch', 'send'],
        instanceAtts: ['name', 'key', 'id'],
        responseAtts: ['match'],
        messageAtts: ['user.id', 'user.name', 'room', 'text']
      };
      Transcript.__super__.constructor.apply(this, ['transcript'].concat(slice.call(args)));
      if (this.config.instanceAtts != null) {
        _.castArray(this.config.instanceAtts);
      }
      if (this.config.responseAtts != null) {
        _.castArray(this.config.responseAtts);
      }
      if (this.config.messageAtts != null) {
        _.castArray(this.config.messageAtts);
      }
      if (this.config.save) {
        if (!this.robot.brain.get('transcripts')) {
          this.robot.brain.set('transcripts', []);
        }
        this.records = this.robot.brain.get('transcripts');
      }
      if (this.records == null) {
        this.records = [];
      }
    }


    /**
     * Record given event in records array, save to hubot brain if configured
     * Events emitted by Playbook always include module instance as first param
     * @param  {String} event   - The event name
     * @param  {Mixed} args...  - Args passed with the event, usually consists of:
     *                            - Playbook module instance
     *                            - Hubot response object
     *                            - other additional (special context) arguments
     */

    Transcript.prototype.recordEvent = function() {
      var args, event, instance, record, response;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (_.hasKeys(args[0], ['name', 'id', 'config'])) {
        instance = args.shift();
      }
      if (_.hasKeys(args[0], ['robot', 'message'])) {
        response = args.shift();
      }
      record = {
        time: _.now(),
        event: event
      };
      if (this.key != null) {
        record.key = this.key;
      }
      if ((instance != null) && (this.config.instanceAtts != null)) {
        record.instance = _.pickHas(instance, this.config.instanceAtts);
      }
      if ((response != null) && (this.config.responseAtts != null)) {
        record.response = _.pickHas(response, this.config.responseAtts);
      }
      if ((response != null) && (this.config.messageAtts != null)) {
        record.message = _.pickHas(response.message, this.config.messageAtts);
      }
      if (!_.isEmpty(args)) {
        record.other = args;
      }
      this.records.push(record);
      this.emit('record', record);
    };


    /**
     * Record events emitted by all Playbook modules and/or the robot itself
     * (still only applies to configured event types)
     */

    Transcript.prototype.recordAll = function() {
      _.each(_.castArray(this.config.events), (function(_this) {
        return function(event) {
          return _this.robot.on(event, function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this.recordEvent.apply(_this, [event].concat(slice.call(args)));
          });
        };
      })(this));
    };


    /**
     * Record events emitted by a given dialogue
     * @param  {Dialogue} dialogue - The Dialogue instance
     */

    Transcript.prototype.recordDialogue = function(dialogue) {
      _.each(_.castArray(this.config.events), (function(_this) {
        return function(event) {
          return dialogue.on(event, function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this.recordEvent.apply(_this, [event].concat(slice.call(args)));
          });
        };
      })(this));
    };


    /**
     * Record events emitted by a given scene and any dialogue it enters
     * Records all events fromn the scene but only configured events from dialogue
     * @param  {Scene} scene - The Scnee instance
     */

    Transcript.prototype.recordScene = function(scene) {
      scene.on('enter', (function(_this) {
        return function(scene, res, dialogue) {
          _this.recordEvent('enter', scene, res);
          return _this.recordDialogue(dialogue);
        };
      })(this));
      scene.on('exit', (function(_this) {
        return function(scene, res, reason) {
          return _this.recordEvent('exit', scene, res, reason);
        };
      })(this));
    };


    /**
     * Record denial events emitted by a given director
     * Ignores configured events because director has distinct events
     * @param  {Director} scene - The Director instance
     */

    Transcript.prototype.recordDirector = function(director) {
      director.on('allow', (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this.recordEvent.apply(_this, ['allow'].concat(slice.call(args)));
        };
      })(this));
      director.on('deny', (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this.recordEvent.apply(_this, ['deny'].concat(slice.call(args)));
        };
      })(this));
    };


    /**
     * Filter records matching a subset, e.g. user name or instance key
      * Optionally return the whole record or values for a given key
     * @param  {Object} subsetMatch  - Key/s:value/s to match (accepts path key)
     * @param  {String} [returnPath] - Key or path within record to return
     * @return {Array}               - Whole records or selected values found
     */

    Transcript.prototype.findRecords = function(subsetMatch, returnPath) {
      var found;
      found = _.filter(this.records, subsetMatch);
      if (returnPath == null) {
        return found;
      }
      return _.map(found, function(record) {
        return _.head(_.at(record, returnPath));
      });
    };

    return Transcript;

  })(Base);

  module.exports = Transcript;

}).call(this);
