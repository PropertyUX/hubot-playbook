// Generated by CoffeeScript 1.12.5
(function() {
  var Base, Transcript, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  _ = require('lodash');

  Base = require('./Base');

  _.mixin({
    'hasKeys': function(obj, keys) {
      if (!_.isObject(obj)) {
        return false;
      }
      return 0 === _.size(_.difference(keys, _.keys(obj)));
    }
  });

  _.mixin({
    'hasPaths': function(obj, paths) {
      if (!_.isObject(obj)) {
        return false;
      }
      return _.every(paths, function(path) {
        return _.hasIn(obj, path);
      });
    }

    /**
     * Keep a record of events and Playbook conversation attributes
     * Transcript can record all events on the Robot or a specified module instance
     * @param {Robot}  robot  - Hubot Robot instance
     * @param {Object} [opts] - Config options:
     *                          key: for grouping records
     *                          events: array of event names to record
     *                          responseAtts: Hubot Response attribute paths (array)
     *                          to record from each event containing a response;
     *                          defaults keep message and match subpaths
     *                          instanceAtts: as above, for Playbook module atts
     *                          defaults keep name, key and id
     */
  });

  Transcript = (function(superClass) {
    extend(Transcript, superClass);

    function Transcript(robot, opts) {
      this.defaults = {
        save: true,
        events: ['match', 'mismatch', 'catch', 'send'],
        instanceKeys: [],
        instanceAtts: ['name', 'config.key', 'id'],
        responseAtts: ['match'],
        messageAtts: ['user.id', 'user.name', 'room', 'text']
      };
      Transcript.__super__.constructor.call(this, 'transcript', robot, opts);
      if (indexOf.call(this.config.events, 'record') >= 0) {
        this.error('cannot record record event - infinite loop');
      }
      if (this.config.save) {
        this.records = this.robot.brain.get('transcripts');
      }
      if (this.records == null) {
        this.records = [];
      }
    }


    /**
     * Record given event in records array, save to hubot brain if configured
     * Events emitted by Playbook always include module instance as first param
     * @param  {String} event   - The event name
     * @param  {Mixed} args...  - Args passed with the event, usually consists of:
     *                            - Playbook module instance
     *                            - Hubot response object
     *                            - other additional (special context) arguments
     */

    Transcript.prototype.recordEvent = function() {
      var args, event, instance, record, ref, response;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (_.hasKeys(args[0], ['name', 'id', 'config'])) {
        instance = args.shift();
      }
      if (_.hasKeys(args[0], ['robot', 'message'])) {
        response = args.shift();
      }
      if (_.size(this.config.instanceKeys)) {
        if (instance == null) {
          return;
        }
        if (ref = instance.config.key, indexOf.call(this.config.instanceKeys, ref) < 0) {
          return;
        }
      }
      record = {
        time: _.now(),
        event: event
      };
      if (this.config.key != null) {
        record.key = this.config.key;
      }
      if (instance != null) {
        record.instance = _.pick(instance, this.config.instanceAtts);
      }
      if (response != null) {
        record.response = _.pick(response, this.config.responseAtts);
      }
      if (response != null) {
        record.message = _.pick(response.message, this.config.messageAtts);
      }
      if (!_.isEmpty(args)) {
        record.other = args;
      }
      this.records.push(record);
      this.emit('record', record);
      this.robot.brain.save();
    };


    /**
     * Record events emitted by all Playbook modules and/or the robot itself
     * (still only applies to configured event types)
     */

    Transcript.prototype.recordAll = function() {
      _.each(_.castArray(this.config.events), (function(_this) {
        return function(event) {
          return _this.robot.on(event, function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this.recordEvent.apply(_this, [event].concat(slice.call(args)));
          });
        };
      })(this));
    };


    /**
     * Record events emitted by a given dialogue
     * @param  {Dialogue} dialogue The Dialogue instance
     */

    Transcript.prototype.recordDialogue = function(dialogue) {
      _.each(_.castArray(this.config.events), (function(_this) {
        return function(event) {
          return dialogue.on(event, function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this.recordEvent.apply(_this, [event].concat(slice.call(args)));
          });
        };
      })(this));
    };


    /**
     * Record events emitted by a given scene and any dialogue it enters
     * Records all events fromn the scene but only configured events from dialogue
     * @param  {Scene} scene The Scnee instance
     */

    Transcript.prototype.recordScene = function(scene) {
      scene.on('enter', (function(_this) {
        return function(scene, res, dialogue) {
          _this.recordEvent('enter', scene, res);
          return _this.recordDialogue(dialogue);
        };
      })(this));
      scene.on('exit', (function(_this) {
        return function(scene, res, reason) {
          return _this.recordEvent('exit', scene, res, reason);
        };
      })(this));
    };


    /**
     * Record denial events emitted by a given director
     * Ignores configured events because director has distinct events
     * @param  {Director} scene The Director instance
     */

    Transcript.prototype.recordDirector = function(director) {
      director.on('allow', (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this.recordEvent.apply(_this, ['allow'].concat(slice.call(args)));
        };
      })(this));
      director.on('deny', (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this.recordEvent.apply(_this, ['deny'].concat(slice.call(args)));
        };
      })(this));
    };

    Transcript.prototype.findRecords = function(subsetMatch, returnPath) {
      var found;
      found = _.filter(this.records, subsetMatch);
      if (returnPath == null) {
        return found;
      }
      return _.map(found, function(record) {
        return _.head(_.at(record, returnPath));
      });
    };

    return Transcript;

  })(Base);

  module.exports = Transcript;

}).call(this);
