{"version":3,"sources":["../../src/modules/playbook.js"],"names":["instance","Playbook","dialogues","scenes","directors","transcripts","outlines","Scene","Dialogue","Director","Transcript","Outline","improv","robot","improvise","playbook","log","logger","debug","name","res","args","dialogue","push","scene","processEnter","enter","type","regex","callback","pop","listen","sceneListen","director","transcript","recordDialogue","recordScene","recordDirector","options","use","configure","info","invokeMap","shutdown","reset","bits","outline","getSceneArgs","map"],"mappings":"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","file":"playbook.js","sourcesContent":["import _ from 'lodash'\nimport Dialogue from './dialogue'\nimport Scene from './scene'\nimport Director from './director'\nimport Transcript from './transcript'\nimport Outline from './outline'\nimport improv from './improv'\n\nlet instance\n\n/**\n * Playbook brings conversational context and branching to Hubot.\n *\n * Modules are available as properties and their instances as collection items.\n *\n * Uses singleton pattern to make sure only one Playbook is created when used\n * in multiple script files loaded by the same Hubot.\n*/\n\nclass Playbook {\n  constructor () {\n    if (!instance) {\n      this.dialogues = []\n      this.scenes = []\n      this.directors = []\n      this.transcripts = []\n      this.outlines = []\n      this.Scene = Scene\n      this.Dialogue = Dialogue\n      this.Director = Director\n      this.Transcript = Transcript\n      this.Outline = Outline\n      this.improv = improv\n      instance = this\n    }\n    return instance\n  }\n\n  /**\n   * Attach Playbook to robot unless already done.\n   *\n   * @param  {Robot}    robot       Hubot instance\n   * @param  {boolean}  [improvise] Enable/disable improv module and middleware (default true)\n   * @return {Playbook}             Self for chaining\n  */\n  use (robot, improvise = true) {\n    this.robot = robot\n    if (this.robot.playbook === this) return this.robot.playbook\n    this.robot.playbook = this\n    this.log = this.robot.logger\n    this.log.debug(`Playbook using ${this.robot.name} bot`)\n    if (improvise) this.improvise()\n    return this\n  }\n\n  /**\n   * Create stand-alone dialogue (not within scene).\n   *\n   * @param {Response} res Hubot Response object\n   * @param  {*} [args]    Optional other Dialogue constructor args\n   * @return {Dialogue}    New Dialogue instance\n  */\n  dialogue (res, ...args) {\n    const dialogue = new this.Dialogue(res, ...args)\n    this.dialogues.push(dialogue)\n    return dialogue\n  }\n\n  /**\n   * Create new Scene.\n   *\n   * @param  {*} [args] Optional Scene constructor args\n   * @return {Scene}    New Scene instance\n  */\n  scene (...args) {\n    const scene = new this.Scene(this.robot, ...args)\n    this.scenes.push(scene)\n    return scene\n  }\n\n  /**\n   * Create and enter Scene.\n   *\n   * @param  {Response} res    Response object from entering participant\n   * @param  {*}        [args] Both Scene and Dialogue constructor args\n   * @param  {Function} [cb]   Called with context after enter middleware done\n   * @return {Promise}         Resolves with final enter middleware context\n  */\n  sceneEnter (res, ...args) {\n    const scene = new this.Scene(this.robot, ...args)\n    const processEnter = scene.enter(res, ...args)\n    this.scenes.push(scene)\n    return processEnter\n  }\n\n  /**\n   * Create scene and setup listener to enter.\n   *\n   * @param  {string}   type     Robot listener type: hear|respond\n   * @param  {RegExp}   regex    Match pattern\n   * @param  {*}        [args]   Scene constructor args\n   * @param  {Function} callback Callback to fire after entered\n   * @return {Scene}             New Scene instance\n  */\n  sceneListen (type, regex, ...args) {\n    const callback = args.pop()\n    const scene = this.scene(...args)\n    scene.listen(type, regex, callback)\n    return scene\n  }\n\n  /**\n   * Alias of sceneListen with hear as specified type.\n   *\n   * @param  {*}   [args] Scene constructor args\n  */\n  sceneHear (...args) {\n    return this.sceneListen('hear', ...args)\n  }\n\n  /**\n   * Alias of sceneListen with respond as specified type.\n   *\n   * @param  {*}   [args] Scene constructor args\n  */\n  sceneRespond (...args) {\n    return this.sceneListen('respond', ...args)\n  }\n\n  /**\n   * Create new Director.\n   *\n   * @param  {*} [args] Director constructor args\n   * @return {Director} New Director instance\n  */\n  director (...args) {\n    const director = new this.Director(this.robot, ...args)\n    this.directors.push(director)\n    return director\n  }\n\n  /**\n   * Create a transcript with optional config to record events from modules\n   *\n   * @param  {*}          [args] Transcript constructor args\n   * @return {Transcript}        The new transcript\n  */\n  transcript (...args) {\n    const transcript = new this.Transcript(this.robot, ...args)\n    this.transcripts.push(transcript)\n    return transcript\n  }\n\n  /**\n   * Create transcript and record a given module in one step.\n   *\n   * @param  {*}  instance A Playbook module (dialogue, scene or director)\n   * @param  {*}  [args]   Constructor args\n   * @return {Transcript}  The new transcript\n   *\n   * @todo Allow passing instance key instead of object, to find from arrays\n  */\n  transcribe (instance, ...args) {\n    const transcript = this.transcript(...args)\n    if (instance instanceof this.Dialogue) transcript.recordDialogue(instance)\n    if (instance instanceof this.Scene) transcript.recordScene(instance)\n    if (instance instanceof this.Director) transcript.recordDirector(instance)\n    return transcript\n  }\n\n  /**\n   * Initialise Improv singleton module, or update configuration if exists.\n   *\n   * Access methods via `Playbook.improv` property.\n   *\n   * @param {Object} [options] Key/val options for config\n   * @return {Improv}          Improv interface\n  */\n  improvise (options) {\n    this.improv.use(this.robot)\n    this.improv.configure(options)\n    return this.improv\n  }\n\n  /**\n   * Exit all scenes, end all dialogues.\n   *\n   * TODO: detach listeners for scenes, directors, transcripts and improv\n  */\n  shutdown () {\n    if (this.log) this.log.info('Playbook shutting down')\n    _.invokeMap(this.scenes, 'exitAll')\n    _.invokeMap(this.dialogues, 'end')\n  }\n\n  /**\n   * Shutdown and re-initialise instance (mostly for tests).\n   *\n   * @return {Playbook} - The reset instance\n  */\n  reset () {\n    if (instance !== null) {\n      instance.shutdown()\n      instance.improv.reset()\n      instance = null\n    }\n    return new Playbook()\n  }\n\n  /**\n   * Load outline and setup scene listeners for _global_ bits.\n   *\n   * @param  {*} [args] Outline constructor args\n   * @return {Playbook} The reset instance\n   */\n  outline (bits, ...args) {\n    let outline = new this.Outline(this.robot, bits, ...args)\n    outline.getSceneArgs().map((args) => this.sceneListen(...args))\n    this.outlines.push(outline)\n  }\n}\n\nexport default new Playbook()\n"]}