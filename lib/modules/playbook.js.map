{"version":3,"sources":["../../src/modules/playbook.js"],"names":["instance","Playbook","dialogues","scenes","directors","transcripts","outlines","Scene","Dialogue","Director","Transcript","Outline","improv","robot","improvise","playbook","log","logger","info","name","res","args","dialogue","push","scene","enter","type","regex","callback","pop","listen","sceneListen","director","transcript","recordDialogue","recordScene","recordDirector","options","use","configure","invokeMap","shutdown","reset","bits","outline","getSceneArgs","map"],"mappings":"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","file":"playbook.js","sourcesContent":["import _ from 'lodash'\nimport Dialogue from './dialogue'\nimport Scene from './scene'\nimport Director from './director'\nimport Transcript from './transcript'\nimport Outline from './outline'\nimport improv from './improv'\n\nlet instance\n\n/**\n * Playbook brings conversational context and branching to Hubot.\n *\n * Modules are available as properties and their instances as collection items.\n *\n * Uses singleton pattern to make sure only one Playbook is created when used\n * in multiple script files loaded by the same Hubot.\n*/\n\nclass Playbook {\n  constructor () {\n    if (!instance) {\n      this.dialogues = []\n      this.scenes = []\n      this.directors = []\n      this.transcripts = []\n      this.outlines = []\n      this.Scene = Scene\n      this.Dialogue = Dialogue\n      this.Director = Director\n      this.Transcript = Transcript\n      this.Outline = Outline\n      this.improv = improv\n      instance = this\n    }\n    return instance\n  }\n\n  /**\n   * Attach Playbook to robot unless already done.\n   *\n   * @param  {Robot}    robot       Hubot instance\n   * @param  {boolean}  [improvise] Enable/disable improv module and middleware (default true)\n   * @return {Playbook}             Self for chaining\n  */\n  use (robot, improvise = true) {\n    this.robot = robot\n    if (this.robot.playbook === this) return this.robot.playbook\n    this.robot.playbook = this\n    this.log = this.robot.logger\n    this.log.info(`Playbook using ${this.robot.name} bot`)\n    if (improvise) this.improvise()\n    return this\n  }\n\n  /**\n   * Create stand-alone dialogue (not within scene).\n   *\n   * @param {Response} res Hubot Response object\n   * @param  {*} [args]    Optional other Dialogue constructor args\n   * @return {Dialogue}    New Dialogue instance\n  */\n  dialogue (res, ...args) {\n    const dialogue = new this.Dialogue(res, ...args)\n    this.dialogues.push(dialogue)\n    return dialogue\n  }\n\n  /**\n   * Create new Scene.\n   *\n   * @param  {*} [args] Optional Scene constructor args\n   * @return {Scene}    New Scene instance\n  */\n  scene (...args) {\n    const scene = new this.Scene(this.robot, ...args)\n    this.scenes.push(scene)\n    return scene\n  }\n\n  /**\n   * Create and enter Scene.\n   *\n   * @param  {Response} res     Response object from entering participant\n   * @param  {*}   [args]       Both Scene and Dialogue constructor args\n   * @return {Dialogue/boolean} Entered Dialogue or false if failed\n  */\n  sceneEnter (res, ...args) {\n    const scene = new this.Scene(this.robot, ...args)\n    const dialogue = scene.enter(res, ...args)\n    this.scenes.push(scene)\n    return dialogue\n  }\n\n  /**\n   * Create scene and setup listener to enter.\n   *\n   * @param  {string}   type     Robot listener type: hear|respond\n   * @param  {RegExp}   regex    Match pattern\n   * @param  {*}        [args]   Scene constructor args\n   * @param  {Function} callback Callback to fire after entered\n   * @return {Scene}             New Scene instance\n  */\n  sceneListen (type, regex, ...args) {\n    const callback = args.pop()\n    const scene = this.scene(...args)\n    scene.listen(type, regex, callback)\n    return scene\n  }\n\n  /**\n   * Alias of sceneListen with hear as specified type.\n   *\n   * @param  {*}   [args] Scene constructor args\n  */\n  sceneHear (...args) {\n    return this.sceneListen('hear', ...args)\n  }\n\n  /**\n   * Alias of sceneListen with respond as specified type.\n   *\n   * @param  {*}   [args] Scene constructor args\n  */\n  sceneRespond (...args) {\n    return this.sceneListen('respond', ...args)\n  }\n\n  /**\n   * Create new Director.\n   *\n   * @param  {*} [args] Director constructor args\n   * @return {Director} New Director instance\n  */\n  director (...args) {\n    const director = new this.Director(this.robot, ...args)\n    this.directors.push(director)\n    return director\n  }\n\n  /**\n   * Create a transcript with optional config to record events from modules\n   *\n   * @param  {*}          [args] Transcript constructor args\n   * @return {Transcript}        The new transcript\n  */\n  transcript (...args) {\n    const transcript = new this.Transcript(this.robot, ...args)\n    this.transcripts.push(transcript)\n    return transcript\n  }\n\n  /**\n   * Create transcript and record a given module in one step.\n   *\n   * @param  {*}  instance A Playbook module (dialogue, scene or director)\n   * @param  {*}  [args]   Constructor args\n   * @return {Transcript}  The new transcript\n   *\n   * @todo Allow passing instance key instead of object, to find from arrays\n  */\n  transcribe (instance, ...args) {\n    const transcript = this.transcript(...args)\n    if (instance instanceof this.Dialogue) transcript.recordDialogue(instance)\n    if (instance instanceof this.Scene) transcript.recordScene(instance)\n    if (instance instanceof this.Director) transcript.recordDirector(instance)\n    return transcript\n  }\n\n  /**\n   * Initialise Improv singleton module, or update configuration if exists.\n   *\n   * Access methods via `Playbook.improv` property.\n   *\n   * @param {Object} [options] Key/val options for config\n   * @return {Improv}          Improv interface\n  */\n  improvise (options) {\n    this.improv.use(this.robot)\n    this.improv.configure(options)\n    return this.improv\n  }\n\n  /**\n   * Exit all scenes, end all dialogues.\n   *\n   * TODO: detach listeners for scenes, directors, transcripts and improv\n  */\n  shutdown () {\n    if (this.log) this.log.info('Playbook shutting down')\n    _.invokeMap(this.scenes, 'exitAll')\n    _.invokeMap(this.dialogues, 'end')\n  }\n\n  /**\n   * Shutdown and re-initialise instance (mostly for tests).\n   *\n   * @return {Playbook} - The reset instance\n  */\n  reset () {\n    if (instance !== null) {\n      instance.shutdown()\n      instance.improv.reset()\n      instance = null\n    }\n    return new Playbook()\n  }\n\n  /**\n   * Load outline and setup scene listeners for _global_ bits.\n   *\n   * @param  {*} [args] Outline constructor args\n   * @return {Playbook} The reset instance\n   */\n  outline (bits, ...args) {\n    let outline = new this.Outline(this.robot, bits, ...args)\n    outline.getSceneArgs().map((args) => this.sceneListen(...args))\n    this.outlines.push(outline)\n  }\n}\n\nexport default new Playbook()\n"]}