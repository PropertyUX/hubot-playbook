// Generated by CoffeeScript 1.12.5
(function() {
  var Base, Outline, YAML, _, fs,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  fs = require('fs');

  _ = require('lodash');

  Base = require('./Base');

  YAML = require('yamljs');


  /**
   * Define a conversation using an outline object (can load from yaml file)
   * Using Playbook, it maps the bits to scene and paths-branch listeners
   * Will throw if Playbook not attached to robot
   * TODO: requires through docs on possible outline model attributes
   * @param {Robot} robot      - The Hubot instance
   * @param {Object} @bits     - Collection of outline attributes (see docs)
   * @param {Object} [options] - Key/val options for config
   * @param {String} [key]     - Key name for this instance
   */

  Outline = (function(superClass) {
    extend(Outline, superClass);

    function Outline() {
      var args, bits, robot;
      robot = arguments[0], bits = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      this.bits = bits;
      this.defaults = {};
      Outline.__super__.constructor.apply(this, ['outline', robot].concat(slice.call(args)));
      if (_.isString(this.bits && fs.existsSync(this.bits))) {
        this.bits = YAML.load(this.bits);
      }
      _.forEach(_.filter(this.bits, 'listen'), (function(_this) {
        return function(bit) {
          return _this.setup(bit);
        };
      })(this));
    }

    Outline.prototype.setup = function(bit) {
      if (bit.scene != null) {
        bit.regex = new RegExp("\\b" + bit.condition + "\\b", 'i');
        return this.playbook.sceneListen(bit.listen, bit.regex, bit.scene, bit.options, (function(_this) {
          return function(res, dlg) {
            return _this["do"](bit, res, dlg);
          };
        })(this));
      }
    };

    Outline.prototype["do"] = function(bit, res, dlg) {
      _.forEach(_.castArray(bit.send), function(text) {
        return dlg.send(text);
      });
      _.forEach(_.castArray(bit.callback), function(callback) {
        return callback(res, dlg);
      });
      if (bit.next != null) {
        return _.forEach(_.castArray(bit.next), (function(_this) {
          return function(key) {
            var next;
            next = _this.bits[bit.next];
            return console.log(next);
          };
        })(this));
      }
    };

    return Outline;

  })(Base);

}).call(this);
