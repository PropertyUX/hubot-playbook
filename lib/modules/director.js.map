{"version":3,"sources":["../../src/modules/director.js"],"names":["Director","robot","args","authArg","isFunction","shift","defaults","type","scope","deniedReply","process","env","DENIED_REPLY","authorise","includes","config","error","log","info","listEnv","toUpperCase","names","split","toString","id","union","castArray","without","res","name","message","user","room","isAllowed","Promise","resolve","text","then","allowed","debug","emit","reply","regex","listenerMiddleware","context","next","done","response","match","finish","listener","options","scene","director","registerMiddleware","module","exports"],"mappings":"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","file":"director.js","sourcesContent":["'use strict'\n\nimport _ from 'lodash'\nimport Base from './base'\n\n/**\n * Directors provide conversation firewalls, allowing listed users to be\n * authorised or blocked from entering scenes or preventing listeners from\n * firing.\n *\n * Access is determined by blacklist or whitelist, or if defined, a custom\n * fallback function can determine to allow or deny anyone not on the list.\n *\n * A director can be attached to whole scenes or dialogues, or even specific\n * listeners.\n *\n * _Authorise_ function is given the user or room name (depending on the scope\n * configured for the direcrot) and response object. It must return a boolean to\n * determine access.\n *\n * `config.deniedReply` can be set globally with environment var `DENIED_REPLY`\n *\n * Environment vars can also provide global default lists:\n * - `WHITELIST_USERNAMES` for whitelist type and username scope directors\n * - `WHITELIST_ROOMS` for whitelist type and room scope directors\n * - `BLACKLIST_USERNAMES` for blacklist type and username scope directors\n * - `BLACKLIST_ROOMS` for blacklist type and room scope directors\n *\n * @param {Robot}    robot               Hubot Robot instance\n * @param {Function} [authorise]         Function to determine access (as fallback)\n * @param {Object} [options]             Key/val options for config\n * @param {string} [options.type]        `'whitelist'` (default) or `'blacklist'`\n * @param {string} [options.deniedReply] Sent when denied access\n * @param {string} [key]                 Key name for this instance\n *\n *\n * @example <caption>check if user has a particular role in platform</caption>\n * let adminsOnly = new Director(robot, (username) => {\n *   return chatPlatform.userHasPermission(username, 'admin')\n * })\n * // ...when directing a scene, will only allow platform admins to enter.\n*/\nclass Director extends Base {\n  constructor (robot, ...args) {\n    let authArg = _.isFunction(args[0]) ? args.shift() : null\n    super('director', robot, ...args)\n    this.defaults({\n      type: 'whitelist',\n      scope: 'username',\n      deniedReply: process.env.DENIED_REPLY || null\n    })\n    this.authorise = authArg\n\n    if (!_.includes(['whitelist', 'blacklist'], this.config.type)) this.error('Invalid type')\n    if (!_.includes(['username', 'room'], this.config.scope)) this.error('Invalid scope')\n    this.log.info(`New ${this.config.scope} Director ${this.config.type}`)\n\n    const listEnv = this.config.type.toUpperCase()\n    switch (this.config.scope) {\n      case 'username': this.names = process.env[`${listEnv}_USERNAMES`]\n        break\n      case 'room': this.names = process.env[`${listEnv}_ROOMS`]\n    }\n    if (this.names != null) this.names = this.names.split(',')\n    if (this.names == null) this.names = []\n  }\n\n  /**\n   * Add new usernames/rooms to list.\n   *\n   * @param  {string/array} names Usernames or Room names (depending on scope)\n   * @return {Director}           Self, for chaining methods\n  */\n  add (names) {\n    this.log.info(`Adding ${names.toString()} to ${this.id} ${this.config.type}`)\n    this.names = _.union(this.names, _.castArray(names))\n    return this\n  }\n\n  /**\n   * Remove new usernames/rooms from list.\n   *\n   * @param  {string/array} names Usernames or Room names (depending on scope)\n   * @return {Director}           Self, for chaining methods\n  */\n  remove (names) {\n    this.log.info(`Removing ${names.toString()} from ${this.id} ${this.config.type}`)\n    this.names = _.without(this.names, ..._.castArray(names))\n    return this\n  }\n\n  /**\n   * Determine if user has access, checking usernames/rooms against lists.\n   *\n   * _Blacklist_ blocks names on list, let anyone else through. _Whitelist_ lets\n   * names on list through, block anyone else. Whitelist is default behaviour.\n   *\n   * @param  {Response} res Hubot Response object\n   * @return {boolean}      Access allowed\n   *\n   * @example <caption>assumes res1, res2 are valid Response objects</caption>\n   * let noHomers = new Director(robot, { type: 'blacklist' }).add('homer')\n   * res1.message.user.name = 'homer'\n   * res2.message.user.name = 'marge'\n   * noHomers.isAllowed(res1) // false\n   * noHomers.isAllowed(res2) // true\n  */\n  isAllowed (res) {\n    let name\n    switch (this.config.scope) {\n      case 'username': name = res.message.user.name\n        break\n      case 'room': name = res.message.room\n    }\n\n    if (this.config.type === 'blacklist') {\n      if (_.includes(this.names, name)) return false\n      if (this.authorise == null) return true\n    } else {\n      if (_.includes(this.names, name)) return true\n      if (this.authorise == null) return false\n    }\n    return this.authorise(name, res)\n  }\n\n  /**\n   * Process access or denial (either silently or with reply, as configured).\n   *\n   * @param  {Response} res Hubot Response object\n   * @return {Promise}      Resolves with boolean, access allowed/denied\n  */\n  process (res) {\n    const isAllowed = Promise.resolve(this.isAllowed(res))\n    const user = res.message.user.name\n    const message = res.message.text\n    return isAllowed.then((allowed) => {\n      if (allowed) {\n        this.log.debug(`${this.id} allowed ${user} on receiving ${message}`)\n        this.emit('allow', res)\n      } else {\n        this.log.info(`${this.id} denied ${user} on receiving: ${message}`)\n        this.emit('deny', res)\n        if (!_.includes(['', null], this.config.deniedReply)) res.reply(this.config.deniedReply)\n      }\n      return allowed\n    })\n  }\n\n  /**\n   * Let this director control access to any listener matching regex.\n   *\n   * @param  {Regex}  regex Listener match pattern\n   * @return {Director}     Self, for chaining methods\n  */\n  directMatch (regex) {\n    this.log.info(`${this.id} now controlling access to listeners matching ${regex}`)\n    this.robot.listenerMiddleware((context, next, done) => {\n      if (!context.response.message.text.match(regex)) return next(done)\n      this.process(context.response).then((allowed) => {\n        if (allowed) return next(done)\n        context.response.message.finish() // don't process this message further\n        return done() // don't process further middleware\n      })\n    }) // nothing matched or user allowed\n    return this\n  }\n\n  /**\n   * Let this director control access to a listener by listener ID.\n   *\n   * If multiple listeners use the same ID, it's assumed to deny all of them.\n   *\n   * @param  {string}   id Listener ID (may be multiple for scene)\n   * @return {Director}    Self, for chaining methods\n  */\n  directListener (id) {\n    this.log.info(`Director ${this.id} now controlling access to listener ${id}`)\n    this.robot.listenerMiddleware((context, next, done) => {\n      if (context.listener.options.id !== id) return next(done)\n      this.process(context.response).then((allowed) => {\n        if (allowed) return next(done)\n        context.response.message.finish() // don't process this message further\n        return done() // don't process further middleware\n      })\n    }) // nothing matched or user allowed\n    return this\n  }\n\n  /**\n   * Let this director control access to a given scene's listener.\n   *\n   * Also hooks into `Scene.enter` to control access to manually entered scenes.\n   *\n   * @param  {Scene} scene The Scene instance\n   * @return {Director}    Self, for chaining methods\n  */\n  directScene (scene) {\n    this.log.info(`${this.id} now controlling ${scene.id}`)\n    const director = this\n    scene.registerMiddleware((context, next, done) => {\n      director.process(context.response).then((allowed) => {\n        if (allowed) next(done)\n        else done()\n      })\n    })\n    return this\n  }\n}\n\nmodule.exports = Director\n"]}