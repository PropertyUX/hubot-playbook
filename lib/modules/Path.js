// Generated by CoffeeScript 1.12.5
(function() {
  var Base, Path, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Base = require('./Base');


  /**
   * Path usually with one or more branches to follow upon matching input
   * Path is opened when branches added, closed when branch is matched
   * Branches may also be added after constructor and by callbacks on a match
   * @param  {Robot} robot       - Hubot Robot instance
   * @param  {Array} [branches]  - Arguments for each brancch, each containing:
   *                               - regex for listener
   *                               - string for sending on match OR
   *                               - callback to fire on match
   * @param  {Object} [opts]     - Config key/vals
   */

  Path = (function(superClass) {
    extend(Path, superClass);

    function Path(robot, branches, opts) {
      Path.__super__.constructor.call(this, 'path', robot, opts);
      this.branches = [];
      this.closed = true;
      if (branches != null) {
        if (!_.isArray(branches)) {
          this.error("Branches must be Array");
        }
        if (!_.isArray(branches[0])) {
          branches = [branches];
        }
        _.forEach(branches, (function(_this) {
          return function(branch) {
            return _this.addBranch.apply(_this, branch);
          };
        })(this));
      }
    }


    /**
     * Add a branch (matching expression and handler) for optional dialogue input
     * On match, handler either fires callback, sends a message or both
     * @param {RegExp}   regex      - Matching pattern
     * @param {String}   [message]  - Message text for response on match
     * @param {Function} [callback] - Function called when matched
     */

    Path.prototype.addBranch = function() {
      var args, callback, message, regex;
      regex = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!_.isRegExp(regex)) {
        this.error('Invalid RegExp for branch');
      }
      if (_.isString(args[0])) {
        message = args.shift();
      }
      if (_.isFunction(args[0])) {
        callback = args.shift();
      }
      if (!((message != null) || (callback != null))) {
        this.error("Missing args for branch");
      }
      this.branches.push({
        regex: regex,
        handler: function(res, dialogue) {
          if (message != null) {
            dialogue.send(message);
          }
          if (callback != null) {
            return callback(res, dialogue);
          }
        }
      });
      this.closed = false;
    };


    /**
     * Called when nothing matches, runs as configured in constructor options:
     * - catchMessage: Message to send via handler
     * - catchCallback: Function to call within handler
     * @return {Object}     Contains .handler (function) or null if not configured
     */

    Path.prototype["catch"] = function() {
      if (!(this.config.catchMessage || this.config.catchCallback)) {
        return;
      }
      return {
        handler: (function(_this) {
          return function(res, dialogue) {
            if (_this.config.catchMessage != null) {
              dialogue.send(_this.config.catchMessage);
            }
            if (_this.config.catchCallback != null) {
              return _this.config.catchCallback(res, dialogue);
            }
          };
        })(this)
      };
    };


    /**
     * Attempt to match an incoming response object
     * Overrides the response match (from dialogue listener) even if null match
     * Matching closes the path, but the handler may add branches, re-opening it
     * Without match, will attempt catch (may also return null)
     * @param  {Response} res     - Hubot Response object
     * @return {Object|undefined} - Matched branch with regex and handler
     */

    Path.prototype.match = function(res) {
      var branch, text;
      text = res.message.text;
      branch = _.find(this.branches, function(branch) {
        res.match = text.match(branch.regex);
        return res.match;
      });
      if (branch != null) {
        this.closed = true;
      }
      return branch || this["catch"]();
    };

    return Path;

  })(Base);

  module.exports = Path;

}).call(this);
