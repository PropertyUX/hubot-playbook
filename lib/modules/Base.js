// Generated by CoffeeScript 1.12.5
(function() {
  var Base, _,
    slice = [].slice;

  _ = require('lodash');


  /**
   * Common structure and behaviour inherited by all Playbook modules
   * Provides unique ID, error handling, event routing and accepts options and
   * named key as final arguments (inherited config is merged with options)
   * @param {String} name      - The module/class name
   * @param {Robot}  robot     - Robot instance
   * @param {Object} [options] - Key/val options for config
   * @param {String} [key]     - Key name for this instance
   */

  Base = (function() {
    function Base() {
      var args, name, robot;
      name = arguments[0], robot = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      this.name = name;
      this.robot = robot;
      if (!_.isString(this.name)) {
        this.error('Module requires a name');
      }
      if (!_.isObject(this.robot)) {
        this.error('Module requires a robot object');
      }
      if (this.config == null) {
        this.config = {};
      }
      if (_.isObject(args[0])) {
        this.configure(args.shift());
      }
      if (_.isString(args[0])) {
        this.key = args.shift();
      }
      this.log = this.robot.logger;
      this.id = _.uniqueId();
    }


    /**
     * Generic error handling, logs and emits event before throwing
     * @param  {String} [err] - Description of error (optional)
     * @param  {Error} [err]  - Error instance (optional)
     */

    Base.prototype.error = function(err) {
      var text;
      if (_.isString(err)) {
        text = (this.id || 'constructor') + ": " + err;
        err = new Error(text);
      }
      if (this.robot != null) {
        this.robot.emit('error', err);
      }
      throw err;
    };


    /**
     * Merge options with defaults to produce configuration
     * @param  {Object} options - Key/vals to merge with defaults, existing config
     * @return {Self}           - for chaining
     */

    Base.prototype.configure = function(options) {
      if (!_.isObject(options)) {
        this.error("Non-object received for config");
      }
      this.config = _.defaultsDeep(options, this.config);
      return this;
    };


    /**
     * Emit events using robot's event emmitter, allows listening from any module
     * Prepends instance's unique ID, so event listens can be implicitly targeted
     * @param  {String} event   Name of event
     * @param  {Mixed} args...  Arguments passed to event
     */

    Base.prototype.emit = function() {
      var args, event, ref;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      (ref = this.robot).emit.apply(ref, [event, this].concat(slice.call(args)));
    };


    /**
     * Fire callback on robot events if event's ID arguement matches this instance
     * @param  {String}   event    Name of event
     * @param  {Function} callback Function to call
     */

    Base.prototype.on = function(event, callback) {
      this.robot.on(event, (function(_this) {
        return function() {
          var args, instance;
          instance = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (instance === _this) {
            return callback.apply(null, [instance].concat(slice.call(args)));
          }
        };
      })(this));
    };

    return Base;

  })();

  module.exports = Base;

}).call(this);
