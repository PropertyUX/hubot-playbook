{"version":3,"sources":["../../src/modules/scene.js"],"names":["Scene","args","defaults","scope","config","sendReplies","validTypes","includes","error","engaged","robot","receiveMiddleware","c","n","d","middleware","context","next","done","res","response","participants","whoSpeaks","log","debug","finish","receive","type","regex","callback","isRegExp","isFunction","id","scene","enter","listen","message","room","toString","user","inDialogue","options","isObject","shift","dialogue","key","on","lastRes","other","exit","isComplete","path","closed","emit","info","status","clearTimeout","invokeMap","keys"],"mappings":"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","file":"scene.js","sourcesContent":["'use strict'\n\nimport _ from 'lodash'\nimport Base from './base'\nimport Dialogue from './dialogue'\n\n/**\n * Scenes conduct participation in dialogue. They use listeners to enter an\n * audience into a new dialogue with the bot.\n *\n * Once entered into a scene, the audience is engaged and isolated from global\n * listeners. The bot will only respond to branches defined by dialogue in that\n * scene. The scope of audience can be:\n *\n * - user - engage the user (in any room)\n * - room - engage the whole room\n * - direct - engage the user in that room only\n *\n * @param {Robot} robot                   Hubot Robot instance\n * @param {Object} [options]              Key/val options for config\n * @param {string} [options.scope]        How to address participants: user(default)|room|direct\n * @param {boolean} [options.sendReplies] Toggle replying/sending (prefix message with \"@user\")\n * @param {string} [key]                  Key name for this instance\n *\n * @example\n * let roomScene = new Scene(robot, { scope: 'room' })\n*/\nclass Scene extends Base {\n  constructor (...args) {\n    super('scene', ...args)\n    this.defaults({ scope: 'user' })\n\n    // by default, prefix @user in room scene (to identify target recipient)\n    if (this.config.scope === 'room') this.defaults({ sendReplies: true })\n\n    const validTypes = [ 'room', 'user', 'direct' ]\n    if (!_.includes(validTypes, this.config.scope)) this.error('invalid scene scope')\n\n    this.engaged = {}\n    this.robot.receiveMiddleware((c, n, d) => this.middleware(c, n, d))\n  }\n\n  /**\n   * Process incoming messages, re-route to dialogue for engaged participants.\n   *\n   * @param {Object} context Passed through the middleware stack, with res\n   * @param {Function} next  Called when all middleware is complete\n   * @param {Function} done  Initial (final) completion callback\n  */\n  middleware (context, next, done) {\n    const res = context.response\n    const participants = this.whoSpeaks(res)\n\n    // are incoming messages from this scenes' engaged participants\n    if (participants in this.engaged) {\n      this.log.debug(`${participants} is engaged, routing dialogue.`)\n      res.finish() // don't process regular listeners\n      this.engaged[participants].receive(res) // let dialogue handle the response\n      done() // don't process further middleware.\n    } else {\n      this.log.debug(`${participants} not engaged, continue as normal.`)\n      next(done)\n    }\n  }\n\n  /**\n   * Add listener that enters the audience into the scene with callback, to then\n   * add dialogue branches or process response as required.\n   *\n   * @param  {String} type       The listener type: hear|respond\n   * @param  {RegExp} regex      Matcher for listener\n   * @param  {Function} callback Called when matched, with Response and Dialogue as arguments\n   *\n   * @example\n   * let scene = new Scene(robot, { scope: 'user' })\n   * scene.listen('respond', /hello/, (res) => {\n   *   res.reply('you are now in a scene')\n   *   // add dialogue branches now...\n   * })\n  */\n  listen (type, regex, callback) {\n    if (!_.includes(['hear', 'respond'], type)) this.error('Invalid listener type')\n    if (!_.isRegExp(regex)) this.error('Invalid regex for listener')\n    if (!_.isFunction(callback)) this.error('Invalid callback for listener')\n\n    // setup listener with scene as attribute for later/external reference\n    // may fail if enter hooks override (from Director)\n    this.robot[type](regex, {id: this.id, scene: this}, res => {\n      if (this.enter(res) !== null) callback(res)\n    })\n  }\n\n  /**\n   * Alias of Scene.listen with `hear` as specified type.\n  */\n  hear (...args) {\n    return this.listen('hear', ...args)\n  }\n\n  /**\n   * Alias of Scene.listen with `respond` as specified type.\n  */\n  respond (...args) {\n    return this.listen('respond', ...args)\n  }\n\n  /**\n   * Identify the source of a message relative to the scene scope.\n   *\n   * @param  {Response} res Hubot Response object\n   * @return {string}       ID of room, user or composite\n  */\n  whoSpeaks (res) {\n    switch (this.config.scope) {\n      case 'room': return res.message.room.toString()\n      case 'user': return res.message.user.id.toString()\n      case 'direct': return `${res.message.user.id}_${res.message.room}`\n    }\n  }\n\n  /**\n   * Engage the participants in dialogue. A new Dialogue instance is created and\n   * all further messages from the audience in this scene's scope will be passed\n   * to that dialogue, untill they are exited from the scene.\n   *\n   * Would usually be invoked by a listener, using the Scene `.listen`, `.hear`\n   * or `respond` methods, but could be called directly to force audience into\n   * a scene unprompted.\n   *\n   * @param  {Response} res     Hubot Response object\n   * @param  {Object} [options] Dialogue options merged with scene config\n   * @param  {*} args           Any additional args for Dialogue constructor\n   * @return {Dialogue}         The started dialogue\n  */\n  enter (res, ...args) {\n    const participants = this.whoSpeaks(res)\n    if (this.inDialogue(participants)) return\n    let options = _.isObject(args[0]) ? args.shift() : {}\n    options = _.defaults({}, this.config, options)\n    const dialogue = new Dialogue(res, options, ...args)\n    dialogue.scene = this\n    if (!dialogue.key && this.key) dialogue.key = this.key\n    dialogue.on('timeout', (lastRes, other) => {\n      return this.exit(lastRes, 'timeout')\n    })\n    dialogue.on('end', (lastRes) => {\n      let isComplete = (lastRes.dialogue.path) ? lastRes.dialogue.path.closed : false\n      return this.exit(lastRes, `${(isComplete) ? '' : 'in'}complete`)\n    })\n    this.engaged[participants] = dialogue\n    this.emit('enter', res, dialogue)\n    this.log.info(`Engaging ${this.config.scope} ${participants} in dialogue`)\n    return dialogue\n  }\n\n  /**\n   * Disengage participants from dialogue e.g. in case of timeout or error.\n   *\n   * @param  {Response} res    Hubot Response object\n   * @param  {string} [status] Some context, for logs\n   * @return {boolean}         Exit success (may fail if already disengaged)\n  */\n  exit (res, status = 'unknown') {\n    const participants = this.whoSpeaks(res)\n    if (this.engaged[participants] != null) {\n      this.engaged[participants].clearTimeout()\n      delete this.engaged[participants]\n      this.emit('exit', res, status)\n      this.log.info(`Disengaged ${this.config.scope} ${participants} (${status})`)\n      return true\n    }\n    this.log.debug(`Cannot disengage ${participants}, not in scene`)\n    return false\n  }\n\n  /**\n   * End all engaged dialogues.\n  */\n  exitAll () {\n    this.log.info(`Disengaging all in ${this.config.scope} scene`)\n    _.invokeMap(this.engaged, 'clearTimeout')\n    this.engaged = []\n  }\n\n  /**\n   * Get the dialogue for engaged participants (relative to scene scope).\n   *\n   * @param  {string} participants ID of user, room or composite\n   * @return {Dialogue}            Engaged dialogue instance\n  */\n  getDialogue (participants) {\n    return this.engaged[participants]\n  }\n\n  /**\n   * Get the engaged status for participants.\n   *\n   * @param  {string} participants ID of user, room or composite\n   * @return {boolean}             Is engaged status\n  */\n  inDialogue (participants) {\n    return (_.includes(_.keys(this.engaged), participants))\n  }\n}\n\nexport default Scene\n"]}