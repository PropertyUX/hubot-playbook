{"version":3,"sources":["../../src/modules/scene.js"],"names":["Scene","constructor","robot","args","defaults","scope","config","sendReplies","validTypes","includes","error","Dialogue","engaged","receiveMiddleware","c","n","d","_middleware","context","next","done","res","response","participants","whoSpeaks","log","debug","finish","receive","listen","type","regex","callback","isRegExp","isFunction","id","scene","dialogue","enter","hear","respond","message","room","toString","user","inDialogue","options","isObject","shift","on","dlg","exit","isComplete","path","closed","emit","info","status","clearTimeout","exitAll","invokeMap","getDialogue","keys"],"mappings":"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","file":"scene.js","sourcesContent":["import _ from 'lodash'\nimport Base from './base'\nimport Dialogue from './dialogue'\n\n/**\n * Scenes conduct participantion in dialogues with the bot. They use listeners\n * to enter an audience into a new dialogue. They can handle multiple concurrent\n * users and rooms in either isolated or group dialogues as required.\n *\n * Once entered into a scene, the audience is _engaged_ and the bot will only\n * respond to dialogue choices defined by that scene. The type of audience is\n * determined by the scene's scope:\n * - entering a _user_ scene will engage the user (in any room)\n * - entering a _room_ scene will engage the whole room\n * - entering a _direct_ scene will engage the user in that room only\n *\n * @param {Robot} robot                   Hubot Robot instance\n * @param {Object} [options]              Key/val options for config\n * @param {string} [options.scope]        How to address participants: user(default)|room|direct\n * @param {boolean} [options.sendReplies] Toggle replying/sending (prefix message with \"@user\")\n * @param {string} [key]                  Key name for this instance\n *\n * @example\n * let roomScene = new Scene(robot, { scope: 'room' })\n*/\nclass Scene extends Base {\n  constructor (robot, ...args) {\n    super('scene', robot, ...args)\n    this.defaults({ scope: 'user' })\n\n    // by default, prefix @user in room scene (to identify target recipient)\n    if (this.config.scope === 'room') this.defaults({ sendReplies: true })\n\n    const validTypes = [ 'room', 'user', 'direct' ]\n    if (!validTypes.includes(this.config.scope)) this.error('invalid scene scope')\n\n    this.Dialogue = Dialogue\n    this.engaged = {}\n    this.robot.receiveMiddleware((c, n, d) => this._middleware(c, n, d))\n  }\n\n  /**\n   * Process incoming messages, re-route to dialogue for engaged participants.\n   *\n   * @param {Object} context Passed through the middleware stack, with res\n   * @param {Function} next  Called when all middleware is complete\n   * @param {Function} done  Initial (final) completion callback\n  */\n  _middleware (context, next, done) {\n    const res = context.response\n    const participants = this.whoSpeaks(res)\n\n    // are incoming messages from this scenes' engaged participants\n    if (participants in this.engaged) {\n      this.log.debug(`${participants} is engaged, routing dialogue.`)\n      res.finish() // don't process regular listeners\n      this.engaged[participants].receive(res) // let dialogue handle the response\n      done() // don't process further middleware.\n    } else {\n      this.log.debug(`${participants} not engaged, continue as normal.`)\n      next(done)\n    }\n  }\n\n  /**\n   * Add listener that enters the audience into the scene with callback, to then\n   * add dialogue branches or process response as required.\n   *\n   * @param  {String} type       The listener type: hear|respond\n   * @param  {RegExp} regex      Matcher for listener\n   * @param  {Function} callback Called when matched, with Response and Dialogue as arguments\n   *\n   * @example\n   * let scene = new Scene(robot, { scope: 'user' })\n   * scene.listen('respond', /hello/, (res, dlg) => {\n   *   res.reply('you are now in a scene')\n   *   // add dialogue branches now...\n   * })\n  */\n  listen (type, regex, callback) {\n    if (!['hear', 'respond'].includes(type)) this.error('Invalid listener type')\n    if (!_.isRegExp(regex)) this.error('Invalid regex for listener')\n    if (!_.isFunction(callback)) this.error('Invalid callback for listener')\n\n    // setup listener with scene as attribute for later/external reference\n    this.robot[type](regex, {id: this.id, scene: this}, res => {\n      const dialogue = this.enter(res) // may fail if enter hooks override (from Director)\n      if (dialogue != null) callback(res, dialogue)\n    })\n  }\n\n  /**\n   * Alias of Scene.listen with `hear` as specified type.\n  */\n  hear (...args) {\n    return this.listen('hear', ...args)\n  }\n\n  /**\n   * Alias of Scene.listen with `respond` as specified type.\n  */\n  respond (...args) {\n    return this.listen('respond', ...args)\n  }\n\n  /**\n   * Identify the source of a message relative to the scene scope.\n   *\n   * @param  {Response} res Hubot Response object\n   * @return {string}       ID of room, user or composite\n  */\n  whoSpeaks (res) {\n    switch (this.config.scope) {\n      case 'room': return res.message.room.toString()\n      case 'user': return res.message.user.id.toString()\n      case 'direct': return `${res.message.user.id}_${res.message.room}`\n    }\n  }\n\n  /**\n   * Engage the participants in dialogue. A new Dialogue instance is created and\n   * all further messages from the audience in this scene's scope will be passed\n   * to that dialogue, untill they are exited from the scene.\n   *\n   * Would usually be invoked by a listener, using the Scene `.listen`, `.hear`\n   * or `respond` methods, but could be called directly to force audience into\n   * a scene unprompted.\n   *\n   * @param  {Response} res       Hubot Response object\n   * @param  {Object}   [options] Dialogue options merged with scene config\n   * @param  {Mixed}    args      Any additional args for Dialogue constructor\n   * @return {Dialogue}           The started dialogue\n  */\n  enter (res, ...args) {\n    const participants = this.whoSpeaks(res)\n    if (this.inDialogue(participants)) return\n    let options = _.isObject(args[0]) ? args.shift() : {}\n    options = _.defaults({}, this.config, options)\n    const dialogue = new this.Dialogue(res, options, ...args)\n    dialogue.on('timeout', (dlg, res) => {\n      return this.exit(res, 'timeout')\n    })\n    dialogue.on('end', (dlg, res) => {\n      let isComplete = (dlg.path) ? dlg.path.closed : false\n      return this.exit(res, `${(isComplete) ? '' : 'in'}complete`)\n    })\n    this.engaged[participants] = dialogue\n    this.emit('enter', res, dialogue)\n    this.log.info(`Engaging ${this.config.scope} ${participants} in dialogue`)\n    return dialogue\n  }\n\n  /**\n   * Disengage participants from dialogue e.g. in case of timeout or error.\n   *\n   * @param  {Response} res    Hubot Response object\n   * @param  {string} [status] Some context, for logs\n   * @return {boolean}         Exit success (may fail if already disengaged)\n  */\n  exit (res, status = 'unknown') {\n    const participants = this.whoSpeaks(res)\n    if (this.engaged[participants] != null) {\n      this.engaged[participants].clearTimeout()\n      delete this.engaged[participants]\n      this.emit('exit', res, status)\n      this.log.info(`Disengaged ${this.config.scope} ${participants} (${status})`)\n      return true\n    }\n    this.log.debug(`Cannot disengage ${participants}, not in scene`)\n    return false\n  }\n\n  /**\n   * End all engaged dialogues.\n  */\n  exitAll () {\n    this.log.info(`Disengaging all in ${this.config.scope} scene`)\n    _.invokeMap(this.engaged, 'clearTimeout')\n    this.engaged = []\n  }\n\n  /**\n   * Get the dialogue for engaged participants (relative to scene scope).\n   *\n   * @param  {string} participants ID of user, room or composite\n   * @return {Dialogue}            Engaged dialogue instance\n  */\n  getDialogue (participants) {\n    return this.engaged[participants]\n  }\n\n  /**\n   * Get the engaged status for participants.\n   *\n   * @param  {string} participants ID of user, room or composite\n   * @return {boolean}             Is engaged status\n  */\n  inDialogue (participants) {\n    return (_.keys(this.engaged).includes(participants))\n  }\n}\n\nexport default Scene\n"]}