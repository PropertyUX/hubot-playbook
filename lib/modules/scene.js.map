{"version":3,"sources":["../../src/modules/scene.js"],"names":["Scene","args","defaults","scope","enterMiddleware","config","sendReplies","validTypes","includes","error","engaged","robot","receiveMiddleware","c","n","d","middleware","context","next","done","res","response","participants","whoSpeaks","log","debug","finish","receive","type","regex","callback","isString","isRegExp","RegExp","isFunction","id","scene","enter","dialogue","listen","message","room","toString","user","piece","register","inDialogue","Promise","reject","Error","length","pop","options","isObject","shift","execute","arguments","processEnter","bind","Array","from","key","on","lastRes","other","exit","isComplete","path","closed","emit","info","process","nextTick","status","clearTimeout","invokeMap","keys"],"mappings":"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","file":"scene.js","sourcesContent":["'use strict'\n\nimport _ from 'lodash'\nimport Base from './base'\nimport Dialogue from './dialogue'\nimport Middleware from '../utils/middleware'\n\n/**\n * Scenes conduct participation in dialogue. They use listeners to enter an\n * audience into a new dialogue with the bot.\n *\n * Once entered into a scene, the audience is engaged and isolated from global\n * listeners. The bot will only respond to branches defined by dialogue in that\n * scene. The scope of audience can be:\n *\n * - user - engage the user (in any room)\n * - room - engage the whole room\n * - direct - engage the user in that room only\n *\n * @param {Robot} robot                   Hubot Robot instance\n * @param {Object} [options]              Key/val options for config\n * @param {string} [options.scope]        How to address participants: user(default)|room|direct\n * @param {boolean} [options.sendReplies] Toggle replying/sending (prefix message with \"@user\")\n * @param {string} [key]                  Key name for this instance\n *\n * @example\n * let roomScene = new Scene(robot, { scope: 'room' })\n*/\nclass Scene extends Base {\n  constructor (...args) {\n    super('scene', ...args)\n    this.defaults({ scope: 'user' })\n\n    // setup internal middleware stack for processing entry\n    this.enterMiddleware = new Middleware(this)\n\n    // by default, prefix @user in room scene (to identify target recipient)\n    if (this.config.scope === 'room') this.defaults({ sendReplies: true })\n\n    const validTypes = [ 'room', 'user', 'direct' ]\n    if (!_.includes(validTypes, this.config.scope)) this.error('invalid scene scope')\n\n    this.engaged = {}\n    this.robot.receiveMiddleware((c, n, d) => this.middleware(c, n, d))\n  }\n\n  /**\n   * Process incoming messages, re-route to dialogue for engaged participants.\n   *\n   * @param {Object} context Passed through the middleware stack, with res\n   * @param {Function} next  Called when all middleware is complete\n   * @param {Function} done  Initial (final) completion callback\n  */\n  middleware (context, next, done) {\n    const res = context.response\n    const participants = this.whoSpeaks(res)\n\n    // are incoming messages from this scenes' engaged participants\n    if (participants in this.engaged) {\n      this.log.debug(`${participants} is engaged, routing dialogue.`)\n      res.finish() // don't process regular listeners\n      this.engaged[participants].receive(res) // let dialogue handle the response\n      done() // don't process further middleware.\n    } else {\n      this.log.debug(`${participants} not engaged, continue as normal.`)\n      next(done)\n    }\n  }\n\n  /**\n   * Add listener that enters the audience into the scene with callback, to then\n   * add dialogue branches or process response as required.\n   *\n   * @param  {String} type       The listener type: hear|respond\n   * @param  {RegExp} regex      Matcher for listener (accepts string, will cast as RegExp)\n   * @param  {Function} callback Called when matched, with Response and Dialogue as arguments\n   *\n   * @example\n   * let scene = new Scene(robot, { scope: 'user' })\n   * scene.listen('respond', /hello/, (res) => {\n   *   res.reply('you are now in a scene')\n   *   // add dialogue branches now...\n   * })\n  */\n  listen (type, regex, callback) {\n    if (!_.includes(['hear', 'respond'], type)) this.error('Invalid listener type')\n    if (_.isString(regex) && _.isRegExp(new RegExp(regex))) regex = new RegExp(regex)\n    if (!_.isRegExp(regex)) this.error('Invalid regex for listener')\n    if (!_.isFunction(callback)) this.error('Invalid callback for listener')\n\n    // setup listener with scene as attribute for later/external reference\n    // may fail if enter hooks override (from Director)\n    this.robot[type](regex, {id: this.id, scene: this}, res => {\n      this.enter(res, (context) => {\n        if (context.dialogue) callback(context.response, context)\n      })\n    })\n  }\n\n  /**\n   * Alias of Scene.listen with `hear` as specified type.\n  */\n  hear (...args) {\n    return this.listen('hear', ...args)\n  }\n\n  /**\n   * Alias of Scene.listen with `respond` as specified type.\n  */\n  respond (...args) {\n    return this.listen('respond', ...args)\n  }\n\n  /**\n   * Identify the source of a message relative to the scene scope.\n   *\n   * @param  {Response} res Hubot Response object\n   * @return {string}       ID of room, user or composite\n  */\n  whoSpeaks (res) {\n    switch (this.config.scope) {\n      case 'room': return res.message.room.toString()\n      case 'user': return res.message.user.id.toString()\n      case 'direct': return `${res.message.user.id}_${res.message.room}`\n    }\n  }\n\n  /**\n    * Add a function to the enter middleware stack, to continue or interrupt the\n    * pipeline. Called with:\n    * - bound 'this' containing the current scene\n    * - context, object containing relevant attributes for the pipeline\n    * - next, function to call to continue the pipeline\n    * - done, final pipeline function, optionally given as argument to next\n    *\n    * @param  {Function} piece Pipeline function to add to the stack.\n   */\n  registerMiddleware (piece) {\n    this.enterMiddleware.register(piece)\n  }\n\n  /*\n   * Trrgger scene enter middleware to begin, calling optional callback if/when\n   * pipeline completes. Processing may reject promise, so should be caught.\n   *\n   * @param  {Response} res        Hubot Response object\n   * @param  {Object} [options]    Dialogue options merged with scene config\n   * @param  {*} args              Any additional args for Dialogue constructor\n   * @param  {Function} [callback] Called after middleware with final context\n   * @return {Promise}             Resolves with new Dialogue middleware completes\n  */\n  enter (res, ...args) {\n    const participants = this.whoSpeaks(res)\n    if (this.inDialogue(participants)) return Promise.reject(new Error('Already engaged'))\n\n    let callback // not required (undefined by default)\n    if (_.isFunction(args[ args.length - 1 ])) callback = args.pop()\n\n    let options = _.isObject(args[0]) ? args.shift() : {}\n    options = _.defaults({}, this.config, options)\n\n    // setup context and execute middleware stack, calling processEnter as\n    // final step if pipeline is allowed to complete\n    return this.enterMiddleware.execute({\n      response: res,\n      participants: participants,\n      options: options,\n      arguments: args\n    }, this.processEnter.bind(this), callback)\n  }\n\n  /**\n   * Engage the participants in dialogue. A new Dialogue instance is created and\n   * all further messages from the audience in this scene's scope will be passed\n   * to that dialogue, untill they are exited from the scene.\n   *\n   * Would usually be invoked as the final piece of enter middleware, after\n   * stack execution is triggered by a scene listener but could be called\n   * directly to force audience into a scene unprompted.\n   *\n   * @param  {Object} context              The final context after middleware completed\n   * @param  {Object} context.response     The hubot response object\n   * @param  {string} context.participants Who is being entered to the scene\n   * @param  {Object} [context.options]    Options object given to dialogue\n   * @param  {Array}  [context.arguments]  Additional arguments given to dialogue\n   * @param  {Function} [done]             Optional final callback after processed - given context\n   * @return {Dialogue}                    The final dialogue\n   */\n  processEnter (context, done) {\n    let args = Array.from(context.arguments)\n    const dialogue = new Dialogue(context.response, context.options, ...args)\n    dialogue.scene = this\n    if (!dialogue.key && this.key) dialogue.key = this.key\n    dialogue.on('timeout', (lastRes, other) => {\n      return this.exit(lastRes, 'timeout')\n    })\n    dialogue.on('end', (lastRes) => {\n      let isComplete = (lastRes.dialogue.path) ? lastRes.dialogue.path.closed : false\n      return this.exit(lastRes, `${(isComplete) ? '' : 'in'}complete`)\n    })\n    this.engaged[context.participants] = dialogue\n    this.emit('enter', context.response, dialogue)\n    this.log.info(`Engaging ${this.config.scope} ${context.participants} in dialogue`)\n    context.dialogue = dialogue\n    process.nextTick(() => done(context))\n    return dialogue\n  }\n\n  /**\n   * Disengage participants from dialogue e.g. in case of timeout or error.\n   *\n   * @param  {Response} res    Hubot Response object\n   * @param  {string} [status] Some context, for logs\n   * @return {boolean}         Exit success (may fail if already disengaged)\n  */\n  exit (res, status = 'unknown') {\n    const participants = this.whoSpeaks(res)\n    if (this.engaged[participants] != null) {\n      this.engaged[participants].clearTimeout()\n      delete this.engaged[participants]\n      this.emit('exit', res, status)\n      this.log.info(`Disengaged ${this.config.scope} ${participants} (${status})`)\n      return true\n    }\n    this.log.debug(`Cannot disengage ${participants}, not in scene`)\n    return false\n  }\n\n  /**\n   * End all engaged dialogues.\n  */\n  exitAll () {\n    this.log.info(`Disengaging all in ${this.config.scope} scene`)\n    _.invokeMap(this.engaged, 'clearTimeout')\n    this.engaged = []\n  }\n\n  /**\n   * Get the dialogue for engaged participants (relative to scene scope).\n   *\n   * @param  {string} participants ID of user, room or composite\n   * @return {Dialogue}            Engaged dialogue instance\n  */\n  getDialogue (participants) {\n    return this.engaged[participants]\n  }\n\n  /**\n   * Get the engaged status for participants.\n   *\n   * @param  {string} participants ID of user, room or composite\n   * @return {boolean}             Is engaged status\n  */\n  inDialogue (participants) {\n    return (_.includes(_.keys(this.engaged), participants))\n  }\n}\n\nexport default Scene\n"]}