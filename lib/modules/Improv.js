// Generated by CoffeeScript 1.12.5
(function() {
  var Base, Handlebars, HandlebarsIntl, ImprovSingleton, _, icu,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Base = require('./Base');

  icu = require('full-icu');

  Handlebars = require('handlebars');

  HandlebarsIntl = require('handlebars-intl');

  HandlebarsIntl.registerWith(Handlebars);


  /**
   * Merge template tags with contextual content (using handlebars), from app
   * environment, user attributes or manually populated keys.
   * Improv uses singleton pattern, all replacements are handled by one module
   * TODO: support fallback/replacement and locale/formats
   * Config keys:
   * - save: keep app context in hubot brain
   * - fallback: Fallback content replace any unknowns within messages
   * - replacement: Replaces all messages containing unknowns, overrides fallback
   * - locale: Locale for format internationalization - yahoo/handlebars-intl
   * - formats: Additional named date/time formats
   * - app: Data object with app context attributes to merge into tempaltes
   * - admins: Array of usernames authorised to populate context data
   */

  ImprovSingleton = (function() {
    var ImprovPrivate, instance;

    function ImprovSingleton() {}

    instance = null;

    ImprovPrivate = (function(superClass) {
      extend(ImprovPrivate, superClass);


      /**
       * Create new private Improv class - returned by singleton
       * Resets config
       * @param {Robot}  robot     - Hubot Robot instance
       * @param {Object} [options] - Key/val options for config
       * @param {String} [key]     - Key name for this instance
       */

      function ImprovPrivate() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        this.init();
        ImprovPrivate.__super__.constructor.apply(this, ['improv'].concat(slice.call(args)));
        this.use(this.robot);
        this.icu = icu;
        this.icuInfo = icu.icu_small ? "english only" : "international";
        this.log.debug("Improv loaded, has ICU for locale translation: " + this.hasICU);
      }


      /**
       * Start with fresh settings, possibly after config changed
       */

      ImprovPrivate.prototype.init = function() {
        this.config = {
          save: true,
          fallback: process.env.IMRPOV_FALLBACK || 'unknown',
          replace: process.env.IMRPOV_REPLACE || null,
          locale: process.env.IMRPOV_LOCALE || 'en',
          formats: {},
          data: {}
        };
        this.extensions = [];
      };


      /**
       * Use a robot and get data from the brain - modular for testing with resets
       * @param  {Robot} robot The robot to use, usually existing from constructor
       * @return {Self} - The instance for chaining
       */

      ImprovPrivate.prototype.use = function(robot) {
        if (!_.isEqual(robot, this.robot)) {
          this.robot = robot;
          if (!this.robot.brain.get('improv')) {
            this.robot.brain.set('improv', {});
          }
          this.robot.responseMiddleware((function(_this) {
            return function(c, n, d) {
              return _this.middleware.call(_this, c, n, d);
            };
          })(this));
        }
        return this;
      };


      /**
       * Allows adding extra functions to provide further context
       * e.g. extend merge data with user transcript history...
       * improv.extend (data) ->
       *  transcript.findRecords message: user: id: data.user.id
       * @param  {Function} dataFunc - Receives merge data, to more return data
       * @return {Self} - The instance for chaining
       */

      ImprovPrivate.prototype.extend = function(dataFunc) {
        if (_.isFunction(dataFunc)) {
          this.extensions.push(dataFunc);
        }
        return this;
      };


      /**
       * Provdies current known user and app data for merging with tempalte
       * Runs any extension functions, e.g. to merge data from other sources
       * TODO: allow tagging other user's data by merge with robot.brain.userForId
       * @param  {Object} user - User (usually from middleware context)
       * @return {Object}      - App and user (from brain) data, with any extras
       */

      ImprovPrivate.prototype.mergeData = function(user) {
        var data, dataSources;
        dataSources = [
          this.config.data, {
            user: user
          }
        ];
        if (this.config.save) {
          dataSources.push(this.robot.brain.get('improv'));
        }
        data = _.defaultsDeep.apply(_, [{}].concat(slice.call(dataSources)));
        return _.reduce(this.extensions, function(merge, func) {
          return _.defaultsDeep(merge, func(merge));
        }, data);
      };


      /**
       * Merge templated messages with data (replace unknowns as configured)
       * @param  {Array}  string  - One or more strings being posted
       * @param  {Object} context - Key/vals for template tags (app and/or user)
       * @return {Array}          - Strings populated with context values
       * TODO: use fallback/replace for unknowns
       */

      ImprovPrivate.prototype.parse = function(strings, context) {
        return _.map(strings, (function(_this) {
          return function(string) {
            var data, template;
            template = Handlebars.compile(string);
            data = {
              intl: {
                formats: _this.config.formats
              }
            };
            if (_this.hasICU) {
              data.intl.locale = _this.config.locale;
            }
            return template(context, {
              data: data
            });
          };
        })(this));
      };


      /**
       * Middleware checks for template tags and parses if required
       * @param  {Object}   context - Passed through middleware stack, with res
       * @param  {Function} next    - Called when all middleware is complete
       * @param  {Function} done    - Initial (final) completion callback
       */

      ImprovPrivate.prototype.middleware = function(context, next, done) {
        var data, hasTag;
        hasTag = _.some(context.strings, function(str) {
          return str.match(/{{.*}}/);
        });
        if (hasTag) {
          data = this.mergeData(context.response.message.user);
          context.strings = this.parse(context.strings, data);
        }
        return next(done);
      };

      ImprovPrivate.prototype.prepare = function(strings) {};

      ImprovPrivate.prototype.warn = function(unknowns) {};

      ImprovPrivate.prototype.remember = function(key, content) {};

      ImprovPrivate.prototype.forget = function(key) {};


      /**
       * Shutdown and re-initialise instance (mostly for tests)
       * @return {Self} - The reset instance
       */

      ImprovPrivate.prototype.reset = function() {
        this.init();
        return this;
      };

      return ImprovPrivate;

    })(Base);


    /**
     * Static method either updates existing or creates new Improv
     * Only attaches robot first time, but uses extra args to reconfigure if given
     * If given no arguments, it will just fetch and return the existing instance
     * @param  {Robot}  [robot]   - The hubot instance to use
     * @param  {Object} [options] - Key/val options for config
     * @param  {String} [key]     - Key name for this instance
     * @return {Improv}           - New or existing instance
     */

    ImprovSingleton.get = function() {
      var args, robot;
      robot = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (robot == null) {
        return instance;
      }
      if (instance == null) {
        instance = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(ImprovPrivate, [robot].concat(slice.call(args)), function(){});
      } else {
        if (args.length) {
          instance.configure.apply(instance, args);
        }
        if (!_.isEqual(robot, instance.robot)) {
          instance.use(robot);
        }
      }
      return instance;
    };

    return ImprovSingleton;

  })();

  module.exports = ImprovSingleton;

}).call(this);
