// Generated by CoffeeScript 1.12.5
(function() {
  var Base, Handlebars, HandlebarsIntl, Improv, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Base = require('./Base');

  Handlebars = require('handlebars');

  HandlebarsIntl = require('handlebars-intl');

  HandlebarsIntl.registerWith(Handlebars);


  /**
   * Merge template tags with contextual content (using handlebars), from app
   * environment, user attributes or manually populated keys.
   * TODO: support fallback/replacement and locale/formats
   * Config keys:
   * - save: keep app context in hubot brain
   * - fallback: Fallback content replace any unknowns within messages
   * - replacement: Replaces all messages containing unknowns, overrides fallback
   * - locale: Locale for format internationalization - yahoo/handlebars-intl
   * - formats: Additional named date/time formats
   * @param {Robot}  robot     - Hubot Robot instance
   * @param {Array}  [admins]  - Usernames authorised to populate context data
   * @param {Object} [options] - Key/val options for config
   * @param {String} [key]     - Key name for this instance
   */

  Improv = (function(superClass) {
    extend(Improv, superClass);

    function Improv() {
      var args, robot;
      robot = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.defaults = {
        save: true,
        fallback: process.env.IMRPOV_FALLBACK || 'unknown',
        replace: process.env.IMRPOV_REPLACE || null,
        locale: process.env.IMRPOV_LOCALE || 'en',
        formats: {},
        app: {}
      };
      this.admins = _.isArray(args[0]) ? args.shift() : [];
      this.extensions = [];
      Improv.__super__.constructor.apply(this, ['improv', robot].concat(slice.call(args)));
      if (this.config.save) {
        if (!this.robot.brain.get('app')) {
          this.robot.brain.set('app', {});
        }
        this.appData = _.defaultsDeep(this.config.app, this.robot.brain.get('app'));
      } else {
        this.appData = this.config.app;
      }
      robot.responseMiddleware((function(_this) {
        return function(c, n, d) {
          return _this.middleware.call(_this, c, n, d);
        };
      })(this));
    }


    /**
     * Allows adding extra functions to provide further context
     * e.g. extend merge data with user transcript history...
     * improv.extend (data) ->
     *  transcript.findRecords message: user: id: data.user.id
     * @param  {Function} dataFunc - Receives merge data, to more return data
     */

    Improv.prototype.extendData = function(dataFunc) {
      if (_.isFunction(dataFunc)) {
        return this.extensions.push(dataFunc);
      }
    };


    /**
     * Provdies current known user and app data for merging with tempalte
     * TODO: allow tagging another users data by merge with robot.brain.userForId
     * @param  {Object} user - User (usually from middleware context)
     * @return {Object}      - App and user (from brain) data, with any extras
     */

    Improv.prototype.mergeData = function(user) {
      var data;
      data = {
        user: {
          name: user.name,
          id: user.id
        },
        app: this.appData
      };
      return _.reduce(this.extensions, function(merge, dataFunc) {
        return _.defaultsDeep(merge, dataFunc(merge));
      }, data);
    };


    /**
     * Merge templated messages with data (replace unknowns as configured)
     * @param  {Array}  string  - One or more strings being posted
     * @param  {Object} context - Key/vals for template tags (app and/or user)
     * @return {Array}          - Strings populated with context values
     * TODO: use fallback/replace for unknowns
     */

    Improv.prototype.parse = function(strings, context) {
      return _.map(strings, (function(_this) {
        return function(string) {
          var template;
          template = Handlebars.compile(string);
          return template(context, {
            data: {
              intl: {
                locales: _this.config.locale,
                formats: _this.config.formats
              }
            }
          });
        };
      })(this));
    };


    /**
     * Middleware checks for template tags and parses if required
     * @param  {Object}   context - Passed through the middleware stack, with res
     * @param  {Function} next    - Called when all middleware is complete
     * @param  {Function} done    - Initial (final) completion callback
     */

    Improv.prototype.middleware = function(context, next, done) {
      var data, hasTag;
      hasTag = _.some(context.strings, function(str) {
        return str.match(/{{.*}}/);
      });
      if (hasTag) {
        data = this.mergeData(context.response.message.user);
        context.strings = this.parse(context.strings, data);
      }
      return next(done);
    };

    Improv.prototype.prepare = function(strings) {};

    Improv.prototype.warn = function(unknowns) {};

    Improv.prototype.remember = function(key, content) {};

    Improv.prototype.forget = function(key) {};

    return Improv;

  })(Base);

  module.exports = Improv;

}).call(this);
