// Generated by CoffeeScript 1.12.5
(function() {
  var Base, Dialogue, Scene, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  Base = require('./Base');

  Dialogue = require('./Dialogue');


  /**
   * Handle array of participants engaged in dialogue with bot
   * Credit to lmarkus/hubot-conversation for the original concept
   * Config keys:
   * - scope: How to address participants; user(default)|room|direct
   * - sendReplies: Toggle replying/sending (prefix message with "@user")
   * Engaged bot will ignore global listeners, only respond to dialogue choices
   * - entering a user scene will engage the user
   * - entering a room scene will engage the whole room
   * - entering a direct scene will engage the user in that room only
   * @param {Robot}  robot     - Hubot Robot instance
   * @param {Object} [options] - Key/val options for config
   * @param {String} [key]     - Key name for this instance
   */

  Scene = (function(superClass) {
    extend(Scene, superClass);

    function Scene() {
      var args, base, ref, robot, validTypes;
      robot = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.config = {
        scope: 'user'
      };
      Scene.__super__.constructor.apply(this, ['scene', robot].concat(slice.call(args)));
      if (this.config.scope === 'room') {
        if ((base = this.config).sendReplies == null) {
          base.sendReplies = true;
        }
      }
      validTypes = ['room', 'user', 'direct'];
      if (ref = this.config.scope, indexOf.call(validTypes, ref) < 0) {
        this.error("invalid scene scope");
      }
      this.Dialogue = Dialogue;
      this.engaged = {};
      this.robot.receiveMiddleware((function(_this) {
        return function(c, n, d) {
          return _this.middleware.call(_this, c, n, d);
        };
      })(this));
    }


    /**
     * Process incoming messages, re-route to dialogue for engaged participants
     * @param  {Object}   context - Passed through the middleware stack, with res
     * @param  {Function} next    - Called when all middleware is complete
     * @param  {Function} done    - Initial (final) completion callback
     */

    Scene.prototype.middleware = function(context, next, done) {
      var participants, res;
      res = context.response;
      participants = this.whoSpeaks(res);
      if (participants in this.engaged) {
        this.log.debug(participants + " is engaged, routing dialogue.");
        res.finish();
        this.engaged[participants].receive(res);
        done();
      } else {
        this.log.debug(participants + " not engaged, continue as normal.");
        next(done);
      }
    };


    /**
     * Add listener with callback to enter scene
     * @param  {String} type       - The listener type: hear|respond
     * @param  {RegExp} regex      - Matcher for listener
     * @param  {Function} callback - Callback to fire when matched
     */

    Scene.prototype.listen = function(type, regex, callback) {
      if (type !== 'hear' && type !== 'respond') {
        this.error("Invalid listener type");
      }
      if (!_.isRegExp(regex)) {
        this.error("Invalid regex for listener");
      }
      if (!_.isFunction(callback)) {
        this.error("Invalid callback for listener");
      }
      this.robot[type](regex, {
        id: this.id,
        scene: this
      }, (function(_this) {
        return function(res) {
          var dialogue;
          dialogue = _this.enter(res);
          if (dialogue != null) {
            return callback(res, dialogue);
          }
        };
      })(this));
    };


    /**
     * Alias of .listen with hear as specified type
     */

    Scene.prototype.hear = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.listen.apply(this, ['hear'].concat(slice.call(args)));
    };


    /**
     * Alias of .listen with respond as specified type
     */

    Scene.prototype.respond = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.listen.apply(this, ['respond'].concat(slice.call(args)));
    };


    /**
     * Identify the source of a message relative to the scene scope
     * @param  {Response} res - Hubot Response object
     * @return {String}       - ID of room, user or composite
     */

    Scene.prototype.whoSpeaks = function(res) {
      switch (this.config.scope) {
        case 'room':
          return res.message.room.toString();
        case 'user':
          return res.message.user.id.toString();
        case 'direct':
          return res.message.user.id + "_" + res.message.room;
      }
    };


    /**
     * Engage the participants in dialogue
     * @param  {Response} res       - Hubot Response object
     * @param  {Object}   [options] - Dialogue options merged with scene config
     * @param  {Mixed}    args      - Any additional args for Dialogue constructor
     * @return {Dialogue}           - The started dialogue
     */

    Scene.prototype.enter = function() {
      var args, dialogue, options, participants, res;
      res = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      participants = this.whoSpeaks(res);
      if (this.inDialogue(participants)) {
        return;
      }
      options = _.isObject(args[0]) ? args.shift() : {};
      options = _.defaults({}, this.config, options);
      dialogue = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this.Dialogue, [res, options].concat(slice.call(args)), function(){});
      dialogue.on('timeout', (function(_this) {
        return function(dlg, res) {
          return _this.exit(res, 'timeout');
        };
      })(this));
      dialogue.on('end', (function(_this) {
        return function(dlg, res) {
          var ref;
          return _this.exit(res, (((ref = dlg.path) != null ? ref.closed : void 0) ? '' : 'in') + "complete");
        };
      })(this));
      this.engaged[participants] = dialogue;
      this.emit('enter', res, dialogue);
      this.log.info("Engaging " + this.config.scope + " " + participants + " in dialogue");
      return dialogue;
    };


    /**
     * Disengage participants from dialogue e.g. in case of timeout or error
     * @param  {Response} res    - Hubot
     * @param  {String} [status] - Some context, for logs
     * @return {Boolean}         - Exit success (may fail if already disengaged)
     */

    Scene.prototype.exit = function(res, status) {
      var participants;
      if (status == null) {
        status = 'unknown';
      }
      participants = this.whoSpeaks(res);
      if (this.engaged[participants] != null) {
        this.engaged[participants].clearTimeout();
        delete this.engaged[participants];
        this.emit('exit', res, status);
        this.log.info("Disengaged " + this.config.scope + " " + participants + " (" + status + ")");
        return true;
      }
      this.log.debug("Cannot disengage " + participants + ", not in scene");
      return false;
    };


    /**
     * End all engaged dialogues
     */

    Scene.prototype.exitAll = function() {
      this.log.info("Disengaging all in " + this.config.scope + " scene");
      _.invokeMap(this.engaged, 'clearTimeout');
      this.engaged = [];
    };


    /**
     * Get the dialogue for engaged participants (relative to scene scope)
     * @param  {String} participants - ID of user, room or composite
     * @return {Dialogue}            - Engaged dialogue instance
     */

    Scene.prototype.getDialogue = function(participants) {
      return this.engaged[participants];
    };


    /**
     * Get the engaged status for participants
     * @param  {String} participants - ID of user, room or composite
     * @return {Boolean}             - Is engaged status
     */

    Scene.prototype.inDialogue = function(participants) {
      return indexOf.call(_.keys(this.engaged), participants) >= 0;
    };

    return Scene;

  })(Base);

  module.exports = Scene;

}).call(this);
