// Generated by CoffeeScript 1.12.5
(function() {
  var Base, Dialogue, Path, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Base = require('./Base');

  Path = require('./Path');


  /**
   * Controller for multiple-choice dialogue interactions
   * Credit to lmarkus/hubot-conversation for the original concept
   * Config keys:
   * - sendReplies: Toggle replying/sending (prefix message with "@user")
   * - timeout: Allowed time to reply (in miliseconds) before cancelling listeners
   * - timeoutText: What to send when timeout reached, set null to not send
   * @param {Response} res     - Hubot Response object
   * @param {Object} [options] - Key/val options for config
   * @param {String} [key]     - Key name for this instance
   */

  Dialogue = (function(superClass) {
    extend(Dialogue, superClass);

    function Dialogue() {
      var args, res;
      res = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.res = res;
      this.config = {
        sendReplies: false,
        timeout: parseInt(process.env.DIALOGUE_TIMEOUT || 30000),
        timeoutText: process.env.DIALOGUE_TIMEOUT_TEXT || 'Timed out! Please start again.'
      };
      Dialogue.__super__.constructor.apply(this, ['dialogue', this.res.robot].concat(slice.call(args)));
      this.Path = Path;
      this.path = null;
      this.ended = false;
    }


    /**
     * Shutdown and emit status (for scene to disengage participants)
     * @return {Boolean} - Shutdown status, false if was already ended
     */

    Dialogue.prototype.end = function() {
      if (this.ended) {
        return false;
      }
      if (this.countdown != null) {
        this.clearTimeout();
      }
      if (this.path != null) {
        this.log.debug("Dialog ended " + (this.path.closed ? '' : 'in') + "complete");
      } else {
        this.log.debug("Dialog ended before paths added");
      }
      this.emit('end', this.res);
      this.ended = true;
      return this.ended;
    };


    /**
     * Send or reply with message as configured (@user reply or send to room)
     * @param {String} strings Message strings
     * TODO: return promise that resolves when robot reply/send completes process
     * TODO: update tests that wait for observer to use promise instead
     */

    Dialogue.prototype.send = function() {
      var ref, ref1, sent, strings;
      strings = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this.config.sendReplies) {
        sent = (ref = this.res).reply.apply(ref, strings);
      } else {
        sent = (ref1 = this.res).send.apply(ref1, strings);
      }
      this.emit.apply(this, ['send', this.res].concat(slice.call(strings)));
    };


    /**
     * Default timeout method sends message, unless null or method overriden
     * If given a method it will call that or can be reassigned as a new function
     * @param  {Function} [override] - New function to call (optional)
     */

    Dialogue.prototype.onTimeout = function(override) {
      if (override != null) {
        this.onTimeout = override;
      } else {
        if (this.config.timeoutText != null) {
          this.send(this.config.timeoutText);
        }
      }
    };


    /**
     * Stop countdown for matching dialogue branches
     */

    Dialogue.prototype.clearTimeout = function() {
      clearTimeout(this.countdown);
      delete this.countdown;
    };


    /**
     * Start (or restart) countdown for matching dialogue branches
     * Catches the onTimeout method because it can be overriden and may throw
     */

    Dialogue.prototype.startTimeout = function() {
      if (this.countdown != null) {
        clearTimeout();
      }
      this.countdown = setTimeout((function(_this) {
        return function() {
          var err;
          _this.emit('timeout', _this.res);
          try {
            _this.onTimeout();
          } catch (error) {
            err = error;
            _this.error(err);
          }
          delete _this.countdown;
          return _this.end();
        };
      })(this), this.config.timeout);
      return this.countdown;
    };


    /**
     * Add a dialogue path, with branches to follow and a prompt (optional)
     * Any new path added overwrites the previous
     * @param  {String} [prompt]   - To send on path setup
     * @param  {Array}  [branches] - Arguments for each brancch containing:
     *                               - regex for listener
     *                               - string for sending on match AND/OR
     *                               - callback to fire on match
     * @param {Object} [options]   - Key/val options for path
     * @param {String} [key]       - Key name for this path
     * @return {Path}              - New path instance
     * TODO: when .send uses promise, return promise that resolves with @path
     */

    Dialogue.prototype.addPath = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (_.isString(args[0])) {
        this.send(args.shift());
      }
      this.path = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this.Path, [this.robot].concat(slice.call(args)), function(){});
      if (this.path.branches.length) {
        this.startTimeout();
      }
      return this.path;
    };


    /**
     * Add a branch to dialogue path, which is usually added first, created if not
     * @param {RegExp}   regex      - Matching pattern
     * @param {String}   [message]  - Message text for response on match
     * @param {Function} [callback] - Function called when matched
     */

    Dialogue.prototype.addBranch = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this.path == null) {
        this.addPath();
      }
      (ref = this.path).addBranch.apply(ref, args);
      this.startTimeout();
    };


    /**
     * Process incoming message for match against path branches
     * If matched, fire handler, restart timeout
     * if no additional paths or branches added (by handler), end dialogue
     * Overrides the original response with current one
     * @param  {Response} res - Hubot Response object
     * TODO: Wrap handler in promise, don't end() until it resolves
     * TODO: Test with handler using res.http/get to populate new path
     */

    Dialogue.prototype.receive = function(res) {
      var branch;
      this.res = res;
      if (this.ended) {
        return false;
      }
      this.log.debug("Dialogue received " + this.res.message.text);
      branch = this.path.match(this.res);
      if ((branch != null) && this.res.match) {
        this.clearTimeout();
        this.emit('match', this.res);
        branch.handler(this.res, this);
      } else if (branch != null) {
        this.emit('catch', this.res);
        branch.handler(this.res, this);
      } else {
        this.emit('mismatch', this.res);
      }
      if (this.path.closed) {
        this.end();
      }
    };

    return Dialogue;

  })(Base);

  module.exports = Dialogue;

}).call(this);
