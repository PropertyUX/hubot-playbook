// Generated by CoffeeScript 1.12.5
(function() {
  var Base, Dialogue, Path, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  Base = require('./Base');

  Path = require('./Path');


  /**
   * Controller for multiple-choice dialogue interactions
   * Credit to lmarkus/hubot-conversation for the original concept
   * @param  {Response} res   - Hubot Response object
   * @param  {Object} [opts]  - Key/val options for config
   */

  Dialogue = (function(superClass) {
    extend(Dialogue, superClass);

    function Dialogue(res, opts) {
      this.res = res;
      this.defaults = {
        sendReplies: false,
        timeout: parseInt(process.env.DIALOGUE_TIMEOUT || 30000),
        timeoutText: process.env.DIALOGUE_TIMEOUT_TEXT || 'Timed out! Please start again.'
      };
      Dialogue.__super__.constructor.call(this, 'dialogue', this.res.robot, opts);
      this.Path = Path;
      this.path = null;
      this.ended = false;
    }


    /**
     * Shutdown and emit status (for scene to disengage participants)
     * @return {Boolean} - Shutdown status, false if was already ended
     */

    Dialogue.prototype.end = function() {
      if (this.ended) {
        return false;
      }
      if (this.countdown != null) {
        this.clearTimeout();
      }
      if (this.path != null) {
        this.log.debug("Dialog ended " + (this.path.closed ? '' : 'in') + "complete");
      } else {
        this.log.debug("Dialog ended before paths added");
      }
      this.emit('end', this.res);
      this.ended = true;
      return this.ended;
    };


    /**
     * Send or reply with message as configured (@user reply or send to room)
     * @param  {String} text Message text
     * TODO: return promise that resolves when robot reply/send completes process
     * TODO: update tests that wait for observer to use promise instead
     */

    Dialogue.prototype.send = function(text) {
      if (this.config.sendReplies) {
        this.res.reply(text);
      } else {
        this.res.send(text);
      }
      this.emit('send', this.res);
    };


    /**
     * Default timeout method sends message, unless null or method overriden
     * If given a method it will call that or can be reassigned as a new function
     * @param  {Function} [override] - New function to call (optional)
     */

    Dialogue.prototype.onTimeout = function(override) {
      if (override != null) {
        this.onTimeout = override;
      } else {
        if (this.config.timeoutText != null) {
          this.send(this.config.timeoutText);
        }
      }
    };


    /**
     * Stop countdown for matching dialogue branches
     */

    Dialogue.prototype.clearTimeout = function() {
      clearTimeout(this.countdown);
      delete this.countdown;
    };


    /**
     * Start (or restart) countdown for matching dialogue branches
     * Catches the onTimeout method because it can be overriden and may throw
     */

    Dialogue.prototype.startTimeout = function() {
      if (this.countdown != null) {
        clearTimeout();
      }
      this.countdown = setTimeout((function(_this) {
        return function() {
          var err;
          _this.emit('timeout', _this.res);
          try {
            _this.onTimeout();
          } catch (error) {
            err = error;
            _this.error(err);
          }
          delete _this.countdown;
          return _this.end();
        };
      })(this), this.config.timeout);
      return this.countdown;
    };


    /**
     * Add a dialogue path, with branches to follow and a prompt (optional)
     * @param  {String} [prompt]  - To send on path setup
     * @param  {Array} [branches] - Arguments for each brancch, each containing:
     *                              - regex for listener
     *                              - string for sending on match
     *                              AND/OR
     *                              - callback to fire on match
     * @param  {Object} [opts]    - Config key/vals
     * @return {Path}             - New path instance
     * TODO: when .send uses promise, return promise that resolves with @path
     */

    Dialogue.prototype.addPath = function() {
      var args, branches, opts, prompt;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (_.isString(args[0])) {
        prompt = args.shift();
      }
      if (_.isArray(args[0])) {
        branches = args.shift();
      }
      opts = _.isObject(args[0]) ? opts = args.shift() : {};
      this.path = new this.Path(this.robot, branches, opts);
      if (prompt != null) {
        this.send(prompt);
      }
      if (branches != null) {
        this.startTimeout();
      }
      return this.path;
    };


    /**
     * Add a branch to dialogue path, which is usually added first, created if not
     * @param {RegExp}   regex      - Matching pattern
     * @param {String}   [message]  - Message text for response on match
     * @param {Function} [callback] - Function called when matched
     */

    Dialogue.prototype.addBranch = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this.path == null) {
        this.addPath();
      }
      (ref = this.path).addBranch.apply(ref, args);
      this.startTimeout();
    };


    /**
     * Process incoming message for match against path branches
     * If matched, fire handler, restart timeout
     * if no additional paths or branches added (by handler), end dialogue
     * Overrides the original response with current one
     * @param  {Response} res - Hubot Response object
     * TODO: Wrap handler in promise, don't end() until it resolves
     * TODO: Test with handler using res.http/get to populate new path
     */

    Dialogue.prototype.receive = function(res) {
      var branch;
      this.res = res;
      if (this.ended) {
        return false;
      }
      this.log.debug("Dialogue received " + this.res.message.text);
      branch = this.path.match(this.res);
      if ((branch != null) && this.res.match) {
        this.clearTimeout();
        this.emit('match', this.res);
        branch.handler(this.res, this);
      } else if (branch != null) {
        this.emit('catch', this.res);
        branch.handler(this.res, this);
      } else {
        this.emit('mismatch', this.res);
      }
      if (this.path.closed) {
        this.end();
      }
    };

    return Dialogue;

  })(Base);

  module.exports = Dialogue;

}).call(this);
