{"version":3,"sources":["../../src/modules/dialogue.js"],"names":["Dialogue","res","args","robot","defaults","sendReplies","timeout","parseInt","process","env","DIALOGUE_TIMEOUT","timeoutText","DIALOGUE_TIMEOUT_TEXT","dialogue","Path","path","ended","countdown","clearTimeout","log","debug","closed","emit","sent","config","reply","send","then","result","response","strings","method","received","override","onTimeout","setTimeout","err","error","end","isString","shift","key","branches","length","startTimeout","Promise","resolve","addPath","addBranch","message","text","handlerResult","match"],"mappings":"AAAA,a;;AAEA,gC;AACA,8B;AACA,+B;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBMA,Q;AACJ,oBAAaC,GAAb,EAA2B,4EAANC,IAAM,mEAANA,IAAM;AACnB,cADmB,EACPD,IAAIE,KADG,SACOD,IADP;AAEzB,UAAKE,QAAL,CAAc;AACZC,mBAAa,KADD;AAEZC,eAASC,SAASC,QAAQC,GAAR,CAAYC,gBAAZ,IAAgC,KAAzC,CAFG;AAGZC,mBAAaH,QAAQC,GAAR,CAAYG,qBAAZ;AACX,sCAJU,EAAd;;AAMAX,QAAIY,QAAJ;AACA,UAAKZ,GAAL,GAAWA,GAAX;AACA,UAAKa,IAAL;AACA,UAAKC,IAAL,GAAY,IAAZ;AACA,UAAKC,KAAL,GAAa,KAAb,CAZyB;AAa1B;;AAED;;;;;AAKO;AACL,UAAI,KAAKA,KAAT,EAAgB,OAAO,KAAP;AAChB,UAAI,KAAKC,SAAL,IAAkB,IAAtB,EAA4B,KAAKC,YAAL;AAC5B,UAAI,KAAKH,IAAL,IAAa,IAAjB,EAAuB;AACrB,aAAKI,GAAL,CAASC,KAAT,oBAA+B,KAAKL,IAAL,CAAUM,MAAV,GAAmB,EAAnB,GAAwB,IAAvD;AACD,OAFD,MAEO;AACL,aAAKF,GAAL,CAASC,KAAT,CAAe,iCAAf;AACD;AACD,WAAKE,IAAL,CAAU,KAAV,EAAiB,KAAKrB,GAAtB;AACA,WAAKe,KAAL,GAAa,IAAb;AACA,aAAO,KAAKA,KAAZ;AACD;;AAED;;;;;;AAMkB;AAChB,UAAIO,aAAJ;AACA,UAAI,KAAKC,MAAL,CAAYnB,WAAhB,EAA6BkB,OAAO,aAAKtB,GAAL,EAASwB,KAAT,uBAAP,CAA7B;AACKF,aAAO,cAAKtB,GAAL,EAASyB,IAAT,wBAAP;AACL,aAAOH,KAAKI,IAAL,CAAU,UAACC,MAAD,EAAY;AAC3B,eAAKN,IAAL,CAAU,MAAV,EAAkBM,OAAOC,QAAzB,EAAmC;AACjCC,mBAASF,OAAOE,OADiB;AAEjCC,kBAAQH,OAAOG,MAFkB;AAGjCC,oBAAU,OAAK/B,GAHkB,EAAnC;;AAKA,eAAO2B,MAAP;AACD,OAPM,CAAP;AAQD;;AAED;;;;;;;AAOWK,Y,EAAU;AACnB,UAAIA,YAAY,IAAhB,EAAsB,KAAKC,SAAL,GAAiBD,QAAjB,CAAtB;AACK,UAAI,KAAKT,MAAL,CAAYb,WAAZ,IAA2B,IAA/B,EAAqC,KAAKe,IAAL,CAAU,KAAKF,MAAL,CAAYb,WAAtB;AAC3C;;AAED;;;AAGgB;AACdO,mBAAa,KAAKD,SAAlB;AACA,aAAO,KAAKA,SAAZ;AACD,K;;AAED;;;;;AAKgB;AACd,UAAI,KAAKA,SAAL,IAAkB,IAAtB,EAA4BC;AAC5B,WAAKD,SAAL,GAAiBkB,WAAW,YAAM;AAChC,eAAKb,IAAL,CAAU,SAAV,EAAqB,OAAKrB,GAA1B;AACA,YAAI;AACF,iBAAKiC,SAAL;AACD,SAFD,CAEE,OAAOE,GAAP,EAAY;AACZ,iBAAKC,KAAL,CAAWD,GAAX;AACD;AACD,eAAO,OAAKnB,SAAZ;AACA,eAAO,OAAKqB,GAAL,EAAP;AACD,OATgB,EASd,KAAKd,MAAL,CAAYlB,OATE,CAAjB;AAUA,aAAO,KAAKW,SAAZ;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;AAsBkB;AAChB,UAAIW,eAAJ,CADgB,mCAAN1B,IAAM,qDAANA,IAAM;AAEhB,UAAI,iBAAEqC,QAAF,CAAWrC,KAAK,CAAL,CAAX,CAAJ,EAAyB0B,SAAS,KAAKF,IAAL,CAAUxB,KAAKsC,KAAL,EAAV,CAAT;AACzB,WAAKzB,IAAL,sCAAgB,KAAKD,IAArB,iBAA0B,KAAKX,KAA/B,GAAyCD,IAAzC;AACA,UAAI,CAAC,KAAKa,IAAL,CAAU0B,GAAX,IAAkB,KAAKA,GAA3B,EAAgC,KAAK1B,IAAL,CAAU0B,GAAV,GAAgB,KAAKA,GAArB;AAChC,WAAKnB,IAAL,CAAU,MAAV,EAAkB,KAAKP,IAAvB;AACA,UAAI,KAAKA,IAAL,CAAU2B,QAAV,CAAmBC,MAAvB,EAA+B,KAAKC,YAAL;AAC/B,aAAOC,QAAQC,OAAR,CAAgBlB,MAAhB,EAAwBD,IAAxB,CAA6B,oBAAM,OAAKZ,IAAX,EAA7B,CAAP;AACD;;AAED;;;;;;;;AAQoB;AAClB,UAAI,KAAKA,IAAL,IAAa,IAAjB,EAAuB,KAAKgC,OAAL;AACvB,oBAAKhC,IAAL,EAAUiC,SAAV;AACA,WAAKJ,YAAL;AACD;;AAED;;;;;;;;;;;;;AAaS3C,O,EAAK;AACZ,UAAI,KAAKe,KAAL,IAAc,KAAKD,IAAL,IAAa,IAA/B,EAAqC,OAAO,KAAP,CADzB,CACsC;AAClD,WAAKI,GAAL,CAASC,KAAT,wBAAoC,KAAKnB,GAAL,CAASgD,OAAT,CAAiBC,IAArD;AACAjD,UAAIY,QAAJ,GAAe,IAAf;AACA,WAAKZ,GAAL,GAAWA,GAAX;AACA,UAAIkD,gBAAgB,KAAKpC,IAAL,CAAUqC,KAAV,CAAgBnD,GAAhB,CAApB;AACA,UAAI,KAAKA,GAAL,CAASmD,KAAb,EAAoB,KAAKlC,YAAL;AACpB,UAAI,KAAKH,IAAL,CAAUM,MAAd,EAAsB,KAAKiB,GAAL;AACtB,aAAOa,aAAP;AACD,K;;;AAGYnD,Q","file":"dialogue.js","sourcesContent":["'use strict'\n\nimport _ from 'lodash'\nimport Base from './base'\nimport Path from './path'\n\n/**\n * Dialogues control which paths are available and for how long. Passing\n * messages into a dialogue will match against the current path and route any\n * replies.\n *\n * Where paths are self-replicating steps, the dialogue persists along the\n * journey.\n *\n * @param {Response} res                  Hubot Response object\n * @param {Object} [options]              Key/val options for config\n * @param {boolean} [options.sendReplies] Toggle replying/sending (prefix with \"@user\")\n * @param {number} [options.timeout]      Allowed time to reply (in miliseconds) before cancelling listeners\n * @param {string} [options.timeoutText]  What to send when timeout reached, set null to not send\n * @param {string} [key]                  Key name for this instance\n *\n * @example <caption>listener sets up dialogue with user on match (10 second timeout)</caption>\n * robot.hear(/hello/, (res) => {\n *   let dlg = new Dialogue(res, { timeout: 10000 })\n *   // ...proceed to add paths\n * })\n*/\nclass Dialogue extends Base {\n  constructor (res, ...args) {\n    super('dialogue', res.robot, ...args)\n    this.defaults({\n      sendReplies: false,\n      timeout: parseInt(process.env.DIALOGUE_TIMEOUT || 30000),\n      timeoutText: process.env.DIALOGUE_TIMEOUT_TEXT ||\n        'Timed out! Please start again.'\n    })\n    res.dialogue = this\n    this.res = res\n    this.Path = Path\n    this.path = null\n    this.ended = false\n  }\n\n  /**\n   * Shutdown and emit status (for scene to disengage participants).\n   *\n   * @return {boolean} Shutdown status, false if was already ended\n  */\n  end () {\n    if (this.ended) return false\n    if (this.countdown != null) this.clearTimeout()\n    if (this.path != null) {\n      this.log.debug(`Dialog ended ${this.path.closed ? '' : 'in'}complete`)\n    } else {\n      this.log.debug('Dialog ended before paths added')\n    }\n    this.emit('end', this.res)\n    this.ended = true\n    return this.ended\n  }\n\n  /**\n   * Send or reply with message as configured (@user reply or send to room).\n   *\n   * @param {string} strings Message strings\n   * @return {Promise} Resolves with result of send (respond middleware context)\n  */\n  send (...strings) {\n    let sent\n    if (this.config.sendReplies) sent = this.res.reply(...strings)\n    else sent = this.res.send(...strings)\n    return sent.then((result) => {\n      this.emit('send', result.response, {\n        strings: result.strings,\n        method: result.method,\n        received: this.res\n      })\n      return result\n    })\n  }\n\n  /**\n   * Default timeout method sends message, unless null or method overriden.\n   *\n   * If given a method it will call that or can be reassigned as a new function.\n   *\n   * @param  {Function} [override] - New function to call (optional)\n  */\n  onTimeout (override) {\n    if (override != null) this.onTimeout = override\n    else if (this.config.timeoutText != null) this.send(this.config.timeoutText)\n  }\n\n  /**\n   * Stop countdown for matching dialogue branches.\n  */\n  clearTimeout () {\n    clearTimeout(this.countdown)\n    delete this.countdown\n  }\n\n  /**\n   * Start (or restart) countdown for matching dialogue branches.\n   *\n   * Catches the onTimeout method because it can be overriden and may throw.\n  */\n  startTimeout () {\n    if (this.countdown != null) clearTimeout()\n    this.countdown = setTimeout(() => {\n      this.emit('timeout', this.res)\n      try {\n        this.onTimeout()\n      } catch (err) {\n        this.error(err)\n      }\n      delete this.countdown\n      return this.end()\n    }, this.config.timeout)\n    return this.countdown\n  }\n\n  /**\n   * Add a dialogue path, with branches to follow and a prompt (optional).\n   *\n   * Any new path added overwrites the previous. If a path isn't given a key but\n   * the parent dialogue has one, it will be given to the path.\n   *\n   * @param {string} [prompt]   To send on path setup (e.g. presenting options)\n   * @param {array}  [branches] Array of args for each branch, each containing:<br>\n   *                            - RegExp for listener<br>\n   *                            - String to send and/or<br>\n   *                            - Function to call on match\n   * @param {Object} [options]  Key/val options for path\n   * @param {string} [key]      Key name for this path\n   * @return {Promise}          Resolves when sends complete or immediately\n   *\n   * @example\n   * let dlg = new Dialogue(res)\n   * let path = dlg.addPath('Turn left or right?', [\n   *   [ /left/, 'Ok, going left!' ]\n   *   [ /right/, 'Ok, going right!' ]\n   * ], 'which-way')\n  */\n  addPath (...args) {\n    let result\n    if (_.isString(args[0])) result = this.send(args.shift())\n    this.path = new this.Path(this.robot, ...args)\n    if (!this.path.key && this.key) this.path.key = this.key\n    this.emit('path', this.path)\n    if (this.path.branches.length) this.startTimeout()\n    return Promise.resolve(result).then(() => this.path)\n  }\n\n  /**\n   * Add a branch to dialogue path, which is usually added first, but will be\n   * created if not.\n   *\n   * @param {RegExp}   regex      Matching pattern\n   * @param {string}   [message]  Message text for response on match\n   * @param {Function} [callback] Function called when matched\n  */\n  addBranch (...args) {\n    if (this.path == null) this.addPath()\n    this.path.addBranch(...args)\n    this.startTimeout()\n  }\n\n  /**\n   * Process incoming message for match against path branches.\n   *\n   * If matched, restart timeout. If no additional paths or branches added (by\n   * matching branch handler), end dialogue.\n   *\n   * Overrides any prior response with current one.\n   *\n   * @param {Response} res Hubot Response object\n   * @return {Promise}     Resolves when matched/catch handler complete\n   *\n   * @todo Test with handler using res.http/get to populate new path\n  */\n  receive (res) {\n    if (this.ended || this.path == null) return false // dialogue is over\n    this.log.debug(`Dialogue received ${this.res.message.text}`)\n    res.dialogue = this\n    this.res = res\n    let handlerResult = this.path.match(res)\n    if (this.res.match) this.clearTimeout()\n    if (this.path.closed) this.end()\n    return handlerResult\n  }\n}\n\nexport default Dialogue\n"]}