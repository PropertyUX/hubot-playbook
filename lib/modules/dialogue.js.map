{"version":3,"sources":["../../src/modules/dialogue.js"],"names":["Dialogue","constructor","res","args","robot","defaults","sendReplies","timeout","parseInt","process","env","DIALOGUE_TIMEOUT","timeoutText","DIALOGUE_TIMEOUT_TEXT","Path","path","ended","end","countdown","clearTimeout","log","debug","closed","emit","send","strings","sent","config","reply","onTimeout","override","startTimeout","setTimeout","err","error","addPath","isString","shift","branches","length","addBranch","receive","message","text","branch","match","handler"],"mappings":"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","file":"dialogue.js","sourcesContent":["import _ from 'lodash'\nimport Base from './Base'\nimport Path from './Path'\n\n/**\n * Dialogues control which paths are available to which users in context.\n *\n * They route messages to the right paths, manage timeouts, send replies and\n * fire callbacks for the branches that match user messages.\n *\n * @param {Response} res                 Hubot Response object\n * @param {Object} [options]             Key/val options for config\n * @param {Object} [options.sendReplies] Toggle replying/sending (prefix with \"@user\")\n * @param {Object} [options.timeout]     Allowed time to reply (in miliseconds) before cancelling listeners\n * @param {Object} [options.timeoutText] What to send when timeout reached, set null to not send\n * @param {String} [key]                 Key name for this instance\n *\n * @example <caption>listener sets up dialogue with user, with 10 second timeout</caption>\n * robot.hear(/hello/, (res) => {\n *   let dlg = new Dialogue(res, { timeout: 10000 })\n *   // ...proceed to add paths\n * })\n*/\nclass Dialogue extends Base {\n  constructor (res, ...args) {\n    super('dialogue', res.robot, ...args)\n    this.defaults({\n      sendReplies: false,\n      timeout: parseInt(process.env.DIALOGUE_TIMEOUT || 30000),\n      timeoutText: process.env.DIALOGUE_TIMEOUT_TEXT ||\n        'Timed out! Please start again.'\n    })\n    this.res = res\n    this.Path = Path\n    this.path = null\n    this.ended = false\n  }\n\n  /**\n   * Shutdown and emit status (for scene to disengage participants).\n   *\n   * @return {Boolean} Shutdown status, false if was already ended\n  */\n  end () {\n    if (this.ended) return false\n    if (this.countdown != null) this.clearTimeout()\n    if (this.path != null) {\n      this.log.debug(`Dialog ended ${this.path.closed ? '' : 'in'}complete`)\n    } else {\n      this.log.debug('Dialog ended before paths added')\n    }\n    this.emit('end', this.res)\n    this.ended = true\n    return this.ended\n  }\n\n  /**\n   * Send or reply with message as configured (@user reply or send to room).\n   *\n   * @param {String} strings Message strings\n   *\n   * @return {Promise} From hubot async middleware (if supported)\n   * @todo update tests that wait for observer to use promise instead\n  */\n  send (...strings) {\n    let sent\n    if (this.config.sendReplies) sent = this.res.reply(...strings)\n    else sent = this.res.send(...strings)\n    this.emit('send', this.res, ...strings)\n    return sent\n  }\n\n  /**\n   * Default timeout method sends message, unless null or method overriden.\n   *\n   * If given a method it will call that or can be reassigned as a new function.\n   *\n   * @param  {Function} [override] - New function to call (optional)\n  */\n  onTimeout (override) {\n    if (override != null) this.onTimeout = override\n    else if (this.config.timeoutText != null) this.send(this.config.timeoutText)\n  }\n\n  /**\n   * Stop countdown for matching dialogue branches.\n  */\n  clearTimeout () {\n    clearTimeout(this.countdown)\n    delete this.countdown\n  }\n\n  /**\n   * Start (or restart) countdown for matching dialogue branches.\n   *\n   * Catches the onTimeout method because it can be overriden and may throw.\n  */\n  startTimeout () {\n    if (this.countdown != null) { clearTimeout() }\n    this.countdown = setTimeout(() => {\n      this.emit('timeout', this.res)\n      try {\n        this.onTimeout()\n      } catch (err) {\n        this.error(err)\n      }\n      delete this.countdown\n      return this.end()\n    }, this.config.timeout)\n    return this.countdown\n  }\n\n  /**\n   * Add a dialogue path, with branches to follow and a prompt (optional).\n   *\n   * Any new path added overwrites the previous.\n   *\n   * @param  {String} [prompt]  To send on path setup (e.g. presenting options)\n   * @param {array}  [branches] Array of args for each branch, each containing:<br>\n   *                            - RegExp for listener<br>\n   *                            - String to send and/or<br>\n   *                            - Function to call on match\n   * @param {Object} [options]  Key/val options for path\n   * @param {String} [key]      Key name for this path\n   * @return {Path}             New path instance\n   * @todo when .send uses promise, return promise that resolves with this.path\n   *\n   * @example\n   * let dlg = new Dialogue(res)\n   * let path = dlg.addPath('Turn left or right?', [\n   *   [ /left/, 'Ok, going left!' ]\n   *   [ /right/, 'Ok, going right!' ]\n   * ], 'which-way')\n  */\n  addPath (...args) {\n    if (_.isString(args[0])) this.send(args.shift())\n    this.path = new this.Path(this.robot, ...args)\n    if (this.path.branches.length) this.startTimeout()\n    return this.path\n  }\n\n  /**\n   * Add a branch to dialogue path, which is usually added first, but will be\n   * created if not.\n   *\n   * @param {RegExp}   regex      Matching pattern\n   * @param {String}   [message]  Message text for response on match\n   * @param {Function} [callback] Function called when matched\n  */\n  addBranch (...args) {\n    if (this.path == null) this.addPath()\n    this.path.addBranch(...args)\n    this.startTimeout()\n  }\n\n  /**\n   * Process incoming message for match against path branches.\n   *\n   * If matched, fire handler, restart timeout.\n   *\n   * if no additional paths or branches added (by handler), end dialogue.\n   *\n   * Overrides the original response with current one.\n   *\n   * @param {Response} res Hubot Response object\n   * @todo Wrap handler in promise, don't end() until it resolves\n   * @todo Test with handler using res.http/get to populate new path\n  */\n  receive (res) {\n    this.res = res\n    if (this.ended) return false // dialogue is over, don't process\n    this.log.debug(`Dialogue received ${this.res.message.text}`)\n    const branch = this.path.match(this.res)\n    if ((branch != null) && this.res.match) {\n      this.clearTimeout()\n      this.emit('match', this.res)\n      branch.handler(this.res, this)\n    } else if (branch != null) {\n      this.emit('catch', this.res)\n      branch.handler(this.res, this)\n    } else {\n      this.emit('mismatch', this.res)\n    }\n    if (this.path.closed) this.end()\n  }\n}\n\nexport default Dialogue\n"]}