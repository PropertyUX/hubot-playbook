// Generated by CoffeeScript 1.12.5
(function() {
  var Dialogue, Director, Playbook, Scene, Transcript, _, ref,
    slice = [].slice;

  _ = require('lodash');

  ref = require('./modules'), Dialogue = ref.Dialogue, Scene = ref.Scene, Director = ref.Director, Transcript = ref.Transcript;


  /**
   * Playbook is a conversation branching library for Hubots, with many utilities
   * Modules are available as properties and their instances as collection items
   * @param  {Robot}     robot - Hubot Robot instance
   */

  Playbook = (function() {
    function Playbook(robot) {
      this.robot = robot;
      this.log = this.robot.logger;
      this.log.info('Playbook starting up');
      this.transcripts = [];
      this.directors = [];
      this.scenes = [];
      this.dialogues = [];
      this.Transcript = Transcript;
      this.Director = Director;
      this.Dialogue = Dialogue;
      this.Scene = Scene;
    }


    /**
     * Create a transcript with optional config to record events from modules
     * @param  {Mixed}      args - Constructor args ./modules/Transcript.coffee
     * @return {Transcript}      - The new transcript
     */

    Playbook.prototype.transcript = function() {
      var args, transcript;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      transcript = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this.Transcript, [this.robot].concat(slice.call(args)), function(){});
      this.transcripts.push(transcript);
      return transcript;
    };


    /**
     * Create transcript and record a given module in one step
     * @param  {Mixed}  instance - A Playbook module (dialogue, scene, director)
     * @param  {Mixed}      args - Constructor args ./modules/Transcript.coffee
     * @return {Transcript}      - The new transcript
     */

    Playbook.prototype.transcribe = function() {
      var args, instance, transcript;
      instance = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      transcript = this.transcript.apply(this, args);
      if (instance instanceof this.Dialogue) {
        transcript.recordDialogue(instance);
      }
      if (instance instanceof this.Scene) {
        transcript.recordScene(instance);
      }
      if (instance instanceof this.Director) {
        transcript.recordDirector(instance);
      }
      return transcript;
    };


    /**
     * Create new Director
     * @param  {Mixed} args - Constructor args ./modules/Director.coffee
     * @return {Director}   - New Director instance
     */

    Playbook.prototype.director = function() {
      var args, director;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      director = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this.Director, [this.robot].concat(slice.call(args)), function(){});
      this.directors.push(director);
      return director;
    };


    /**
     * Create new Scene
     * @param  {Mixed} args - Scene constructor args ./modules/Director.coffee
     * @return {Scene}      - New Scene instance
     */

    Playbook.prototype.scene = function() {
      var args, scene;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      scene = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this.Scene, [this.robot].concat(slice.call(args)), function(){});
      this.scenes.push(scene);
      return scene;
    };


    /**
     * Create and enter Scene
     * @param  {String} [type]    - Scene type
     * @param  {Mixed} args       - Scene.enter args ./modules/Scene.coffee
     * @return {Dialogue|Boolean} - Enter result, Dialogue or false if failed
     */

    Playbook.prototype.sceneEnter = function() {
      var args, dialogue, scene, type;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (typeof args[0] === 'string') {
        type = args.shift();
      }
      scene = new this.Scene(this.robot, type);
      dialogue = scene.enter.apply(scene, args);
      this.scenes.push(scene);
      return dialogue;
    };


    /**
     * Create scene and setup listener to enter
     * @param  {String}   listenType - Robot listener type: hear|respond
     * @param  {RegExp}   regex      - Match pattern
     * @param  {Mixed}    args       - Scene constructor args
     * @param  {Function} callback   - Callback to fire after entered
     * @return {Scene}               - New Scene instance
     */

    Playbook.prototype.sceneListen = function() {
      var args, callback, i, listenType, regex, scene;
      listenType = arguments[0], regex = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), callback = arguments[i++];
      scene = this.scene.apply(this, args);
      scene.listen(listenType, regex, callback);
      return scene;
    };


    /**
     * Alias of sceneListen with hear as specified type
     */

    Playbook.prototype.sceneHear = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.sceneListen.apply(this, ['hear'].concat(slice.call(args)));
    };


    /**
     * Alias of sceneListen with respond as specified type
     */

    Playbook.prototype.sceneRespond = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.sceneListen.apply(this, ['respond'].concat(slice.call(args)));
    };


    /**
     * Create stand-alone dialogue (not within scene)
     * @param  {Mixed} args - Dialogue constructor args ./modules/Dialogue.coffee
     * @return {Scene}      - New Scene instance
     */

    Playbook.prototype.dialogue = function() {
      var args, dialogue;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      dialogue = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this.Dialogue, args, function(){});
      this.dialogues.push(dialogue);
      return dialogue;
    };


    /**
     * Exit all scenes, end all dialogues
     */

    Playbook.prototype.shutdown = function() {
      this.log.info('Playbook shutting down');
      _.invokeMap(this.scenes, 'exitAll');
      _.invokeMap(this.dialogues, 'end');
    };

    return Playbook;

  })();

  module.exports = Playbook;

}).call(this);
