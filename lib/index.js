// Generated by CoffeeScript 1.12.5
(function() {
  var Dialogue, Director, Improv, PlaybookSingleton, Scene, Transcript, _, ref,
    slice = [].slice;

  _ = require('lodash');

  ref = require('./modules'), Dialogue = ref.Dialogue, Scene = ref.Scene, Director = ref.Director, Transcript = ref.Transcript, Improv = ref.Improv;


  /**
   * Playbook is a conversation branching library for Hubots, with many utilities
   * Modules are available as properties and their instances as collection items
   * Uses singleton pattern to make sure only one Playbook is created when used
   * in multiple script files loaded by the same Hubot
   */

  PlaybookSingleton = (function() {
    var PlaybookPrivate, instance;

    function PlaybookSingleton() {}

    instance = null;

    PlaybookPrivate = (function() {

      /**
       * Initialise new Playbook
       */
      function PlaybookPrivate() {
        this.init();
      }


      /**
       * Init module collections and prototypes
       */

      PlaybookPrivate.prototype.init = function() {
        this.dialogues = [];
        this.scenes = [];
        this.directors = [];
        this.transcripts = [];
        this.improv = null;
        this.Scene = Scene;
        this.Dialogue = Dialogue;
        this.Director = Director;
        this.Transcript = Transcript;
        return this.Improv = Improv;
      };


      /**
       * Attach Playbook to Hubot unless already done
       * @param  {Robot}    @robot Hubot instance
       * @return {Playbook}        Self for chaining
       */

      PlaybookPrivate.prototype.use = function(robot1) {
        this.robot = robot1;
        if (this.robot.playbook === this) {
          return this.robot.playbook;
        }
        this.robot.playbook = this;
        this.log = this.robot.logger;
        this.log.info("Playbook using " + this.robot.name + " bot");
        return this;
      };


      /**
       * Create stand-alone dialogue (not within scene)
       * @param  {Mixed} args - Dialogue constructor args
       * @return {Scene}      - New Scene instance
       */

      PlaybookPrivate.prototype.dialogue = function() {
        var args, dialogue;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        dialogue = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(this.Dialogue, args, function(){});
        this.dialogues.push(dialogue);
        return dialogue;
      };


      /**
       * Create new Scene
       * @param  {Mixed} args - Scene constructor args
       * @return {Scene}      - New Scene instance
       */

      PlaybookPrivate.prototype.scene = function() {
        var args, scene;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        scene = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(this.Scene, [this.robot].concat(slice.call(args)), function(){});
        this.scenes.push(scene);
        return scene;
      };


      /**
       * Create and enter Scene
       * @param  {Response} res     - Response object from entering participant
       * @param  {Mixed}   [args]   - Both Scene and Dialogue constructor options
       * @return {Dialogue|Boolean} - Enter result, Dialogue or false if failed
       */

      PlaybookPrivate.prototype.sceneEnter = function() {
        var args, dialogue, res, scene;
        res = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        scene = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(this.Scene, [this.robot].concat(slice.call(args)), function(){});
        dialogue = scene.enter.apply(scene, [res].concat(slice.call(args)));
        this.scenes.push(scene);
        return dialogue;
      };


      /**
       * Create scene and setup listener to enter
       * @param  {String}   type     - Robot listener type: hear|respond
       * @param  {RegExp}   regex    - Match pattern
       * @param  {Mixed}    args     - Scene constructor args
       * @param  {Function} callback - Callback to fire after entered
       * @return {Scene}             - New Scene instance
       */

      PlaybookPrivate.prototype.sceneListen = function() {
        var args, callback, i, regex, scene, type;
        type = arguments[0], regex = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), callback = arguments[i++];
        scene = this.scene.apply(this, args);
        scene.listen(type, regex, callback);
        return scene;
      };


      /**
       * Alias of sceneListen with hear as specified type
       */

      PlaybookPrivate.prototype.sceneHear = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return this.sceneListen.apply(this, ['hear'].concat(slice.call(args)));
      };


      /**
       * Alias of sceneListen with respond as specified type
       */

      PlaybookPrivate.prototype.sceneRespond = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return this.sceneListen.apply(this, ['respond'].concat(slice.call(args)));
      };


      /**
       * Create new Director
       * @param  {Mixed} args - Constructor args
       * @return {Director}   - New Director instance
       */

      PlaybookPrivate.prototype.director = function() {
        var args, director;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        director = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(this.Director, [this.robot].concat(slice.call(args)), function(){});
        this.directors.push(director);
        return director;
      };


      /**
       * Create a transcript with optional config to record events from modules
       * @param  {Mixed}      args - Constructor args
       * @return {Transcript}      - The new transcript
       */

      PlaybookPrivate.prototype.transcript = function() {
        var args, transcript;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        transcript = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(this.Transcript, [this.robot].concat(slice.call(args)), function(){});
        this.transcripts.push(transcript);
        return transcript;
      };


      /**
       * Create transcript and record a given module in one step
       * TODO: allow passing instance key instead of object, to find from arrays
       * @param  {Mixed}  instance - A Playbook module (dialogue, scene, director)
       * @param  {Mixed}      args - Constructor args
       * @return {Transcript}      - The new transcript
       */

      PlaybookPrivate.prototype.transcribe = function() {
        var args, instance, transcript;
        instance = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        transcript = this.transcript.apply(this, args);
        if (instance instanceof this.Dialogue) {
          transcript.recordDialogue(instance);
        }
        if (instance instanceof this.Scene) {
          transcript.recordScene(instance);
        }
        if (instance instanceof this.Director) {
          transcript.recordDirector(instance);
        }
        return transcript;
      };


      /**
       * Initialise Improv singleton module, or update configuration if exists
       * Access methods via `Playbook.improv` property
       * @param {Object} [options] - Key/val options for config
       * @param {String} [key]     - Key name for this instance
       * @return {Improv} - Improv instance
       */

      PlaybookPrivate.prototype.improvise = function() {
        var args, ref1;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        this.improv = (ref1 = this.Improv).get.apply(ref1, [this.robot].concat(slice.call(args)));
        return this.improv;
      };


      /**
       * Exit all scenes, end all dialogues
       * TODO: detach listeners for scenes, directors, transcripts and improv
       */

      PlaybookPrivate.prototype.shutdown = function() {
        this.log.info('Playbook shutting down');
        _.invokeMap(this.scenes, 'exitAll');
        _.invokeMap(this.dialogues, 'end');
      };


      /**
       * Shutdown and re-initialise instance (mostly for tests)
       * @return {Playbook} - The reset instance
       */

      PlaybookPrivate.prototype.reset = function() {
        this.shutdown();
        this.init();
        return this;
      };

      return PlaybookPrivate;

    })();


    /**
     * Static method either retrieves Playbook instance or creates new one
     * @return {Playbook}       - New or existing instance
     */

    PlaybookSingleton.get = function() {
      return instance != null ? instance : instance = new PlaybookPrivate();
    };


    /**
     * Static method creates new Playbook instance
     * @return {Playbook}       - New instance
     */

    PlaybookSingleton["new"] = function() {
      return instance = new PlaybookPrivate();
    };

    return PlaybookSingleton;

  })();

  module.exports = {
    playbook: PlaybookSingleton.get(),
    get: function() {
      return PlaybookSingleton.get();
    },
    create: function() {
      return PlaybookSingleton["new"]();
    },
    use: function(robot) {
      return PlaybookSingleton.get().use(robot);
    }
  };

}).call(this);
